<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>The real world</title>
  
  <subtitle>You can do something</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kepler-ecnu.github.io/"/>
  <updated>2019-09-25T03:19:29.107Z</updated>
  <id>https://kepler-ecnu.github.io/</id>
  
  <author>
    <name>kepler</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>排序总结</title>
    <link href="https://kepler-ecnu.github.io/2019/09/24/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://kepler-ecnu.github.io/2019/09/24/排序总结/</id>
    <published>2019-09-24T13:34:38.000Z</published>
    <updated>2019-09-25T03:19:29.107Z</updated>
    
    <content type="html"><![CDATA[<p>本部分资料来源: 不该相遇在秋天 五分钟学算法(<a href="https://mp.weixin.qq.com/s/Qf416rfT4pwURpW3aDHuCg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Qf416rfT4pwURpW3aDHuCg</a>)<br>对于常见的排序算法分类，稳定性和时间复杂度等如图所示<br><img src="/images/%E6%8E%92%E5%BA%8F.png" alt></p><h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序无疑是最为出名的排序算法之一，从序列的一端开始往另一端冒泡（你可以从左 往右冒泡，也可以从右往左冒泡，看心情），依次比较相邻的两个数的大小（到底是比大 还是比小也看你心情）。<br>这里从左往右依次冒泡，将小的往右移动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line"><span class="comment">//外层表示冒泡论述</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arr.length - <span class="number">1</span> ; i++ )&#123;</span><br><span class="line"><span class="comment">// 里层依次比较</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; arr.length - <span class="number">1</span> - i ; j++)&#123;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(arr[j] &lt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line"> temp = arr[j];</span><br><span class="line"> arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line"> arr[j + <span class="number">1</span>] = temp;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>冒泡的代码还是相当简单的，两层循环，外层冒泡轮数，里层依次比较，江湖中人人尽皆 知。我们看到嵌套循环，应该立马就可以得出这个算法的时间复杂度为 O(n^2)。</p><p>冒泡有一个最大的问题就是这种算法不管不管你有序还是没序，闭着眼睛把你循环比较了再说。 比如我举个数组例子：[ 9，8，7，6，5 ]，一个有序的数组，根本不需要排序，它仍然 是 双 层 循 环 一 个 不 少 的 把 数 据 遍 历 干 净 ， 这 其 实 就 是 做 了 没 必 要 做 的 事 情 ， 属 于 浪 费 资 源。针对这个问题，我们可以设定一个临时遍历来标记该数组是否已经有序，如果有序了就不 用遍历了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length - <span class="number">1</span> ; i++ )&#123;</span><br><span class="line"><span class="keyword">boolean</span> isSort = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>;j &lt; arr.length - <span class="number">1</span> - i ; j++ )&#123;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(arr[j] &lt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line"> temp = arr[j];</span><br><span class="line"> arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line"> arr[j + <span class="number">1</span>] = temp;</span><br><span class="line"> isSort = <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">if</span>(isSort)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序的核心思想也是<strong>分治法</strong>，分而治之。它的实现方式是每次从序列中选出一个基准 值，其他数依次和基准值做比较，比基准值大的放右边，比基准值小的放左边，然后再对左边和右边的两组数分别选出一个基准值，进行同样的比较移动，重复步骤，直到最后都 变成单个元素，整个数组就成了有序的序列。</p><ul><li><p>单边扫面<br>快速排序的关键之处在于切分，切分的同时要进行比较和移动，这里先介绍一种单边扫描的做法。 我们随意抽取一个数作为基准值，同时设定一个标记 mark 代表左边序列最右侧的下标位置，当然初始为 0 ，接下来遍历数组，如果元素大于基准值，无操作，继续遍历，如 果元素小于基准值，则把 mark + 1 ，再将 mark 所在位置的元素和遍历到的元素交换 位置，mark 这个位置存储的是比基准值小的数据，当遍历结束后，将基准值与 mark 所 在元素交换位置即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"> sort(arr， <span class="number">0</span>， arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr， <span class="keyword">int</span> startIndex， <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (endIndex &lt;= startIndex) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//切分</span></span><br><span class="line"><span class="keyword">int</span> pivotIndex = partition(arr， startIndex， endIndex);</span><br><span class="line"> sort(arr， startIndex， pivotIndex-<span class="number">1</span>);</span><br><span class="line"> sort(arr， pivotIndex+<span class="number">1</span>， endIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr， <span class="keyword">int</span> startIndex， <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pivot = arr[startIndex];<span class="comment">//取基准值</span></span><br><span class="line"><span class="keyword">int</span> mark = startIndex;<span class="comment">//Mark初始化为起始下标</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=startIndex+<span class="number">1</span>; i&lt;=endIndex; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i]&lt;pivot)&#123;</span><br><span class="line"><span class="comment">//小于基准值 则mark+1，并交换位置。</span></span><br><span class="line"> mark ++;</span><br><span class="line"><span class="keyword">int</span> p = arr[mark];</span><br><span class="line"> arr[mark] = arr[i];</span><br><span class="line"> arr[i] = p;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//基准值与mark对应元素调换位置</span></span><br><span class="line"> arr[startIndex] = arr[mark];</span><br><span class="line"> arr[mark] = pivot;</span><br><span class="line"><span class="keyword">return</span> mark;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>双边扫描<br>另外还有一种双边扫描的做法，看起来比较直观：我们随意抽取一个数作为基准值，然后从数组左右两边进行扫描 ，先从左往找到一个大于基准值的元素 ，将下标指 针记录下来，然后转到从右往左扫描，找到一个小于基准值的元素，交换这两个元素的位置，重复步骤，直到左右两个指针相遇，再将基准值与左侧最右边的元素交换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"> sort(arr， <span class="number">0</span>， arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr， <span class="keyword">int</span> startIndex， <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (endIndex &lt;= startIndex) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//切分</span></span><br><span class="line"><span class="keyword">int</span> pivotIndex = partition(arr， startIndex， endIndex);</span><br><span class="line"> sort(arr， startIndex， pivotIndex-<span class="number">1</span>);</span><br><span class="line"> sort(arr， pivotIndex+<span class="number">1</span>， endIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr， <span class="keyword">int</span> startIndex， <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = startIndex;</span><br><span class="line"><span class="keyword">int</span> right = endIndex;</span><br><span class="line"><span class="keyword">int</span> pivot = arr[startIndex];<span class="comment">//取第一个元素为基准值</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">//从左往右扫描</span></span><br><span class="line"><span class="keyword">while</span> (arr[left] &lt;= pivot) &#123;</span><br><span class="line"> left++;</span><br><span class="line"><span class="keyword">if</span> (left == right) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//从右往左扫描</span></span><br><span class="line"><span class="keyword">while</span> (pivot &lt; arr[right]) &#123;</span><br><span class="line"> right--;</span><br><span class="line"><span class="keyword">if</span> (left == right) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//左右指针相遇</span></span><br><span class="line"><span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//交换左右数据</span></span><br><span class="line"><span class="keyword">int</span> temp = arr[left];</span><br><span class="line"> arr[left] = arr[right];</span><br><span class="line"> arr[right] = temp;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//将基准值插入序列</span></span><br><span class="line"><span class="keyword">int</span> temp = arr[startIndex];</span><br><span class="line"> arr[startIndex] = arr[right];</span><br><span class="line"> arr[right] = temp;</span><br><span class="line"><span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>快速排序的时间复杂度和归并排序一样，O(nlogn)，但这是建立在每次切分都能把数组 一刀切两半差不多大的前提下，如果出现极端情况，比如排一个有序的序列，如[ 9，8， 7，6，5，4，3，2，1 ]，选取基准值 9 ，那么需要切分 n - 1 次才能完成整个快速排序的过程，这种情况下，时间复杂度就退化成了 O(n^2)，当然极端情况出现的概率也是比 较低的。 所以说，快速排序的时间复杂度是 O(nlogn)，极端情况下会退化成 O(n^2)，为了避免极 端情况的发生，选取基准值应该做到随机选取，或者是打乱一下数组再选取。 另外，快速排序的空间复杂度为 O(1)。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序的思路是这样的：首先，找到数组中最小的元素，拎出来，将它和数组的第一个元素交换位置，第二步，在剩下的元素中继续寻找最小的元素，拎出来，和数组的第二个元素交换位置，如此循环，直到整个数组排序完成。 至于选大还是选小，这个都无所谓，你也可以每次选择最大的拎出来排，也可以每次选择 最小的拎出来的排，只要你的排序的手段是这种方式，都叫选择排序。</p><h3 id="直接排序"><a href="#直接排序" class="headerlink" title="直接排序"></a>直接排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++ )&#123;</span><br><span class="line"><span class="keyword">int</span> min = i;<span class="comment">//最小元素的下标</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++ )&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[j] &lt; arr[min])&#123;</span><br><span class="line"> min = j;<span class="comment">//找最小值</span></span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//交换位置</span></span><br><span class="line"><span class="keyword">int</span> temp = arr[i];</span><br><span class="line"> arr[i] = arr[min];</span><br><span class="line"> arr[min] = temp;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双层循环，时间复杂度和冒泡一模一样，都是O(n^2)。</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆是一种优先队列，两种实现，最大堆和最小堆，由于我们这里排序按升序排，所以就直接以最大堆来说吧。</p><p>我们完全可以把堆（以下全都默认为最大堆）看成一棵完全二叉树，但是位于堆顶的元素总是整棵树的最大值，每个子节点的值都比父节点小，由于堆要时刻保持这样的规则特性，所以一旦堆里面的数据发生变化，我们必须对堆重新进行一次构建。</p><p>既然堆顶元素永远都是整棵树中的最大值，那么我们将数据构建成堆后，只需要从堆顶取元素不就好了吗？ 第一次取的元素，是否取的就是最大值？取完后把堆重新构建一下，然后再取堆顶的元素，是否取的就是第二大的值？ 反复的取，取出来的数据也就是有序的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = arr.length;</span><br><span class="line">    <span class="comment">//构建堆</span></span><br><span class="line">    buildHeap(arr， length);</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- ) &#123;</span><br><span class="line">        <span class="comment">//将堆顶元素与末位元素调换</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">        <span class="comment">//数组长度-1 隐藏堆尾元素</span></span><br><span class="line">        length--;</span><br><span class="line">        <span class="comment">//将堆顶元素下沉 目的是将最大的元素浮到堆顶来</span></span><br><span class="line">        sink(arr， <span class="number">0</span>， length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] arr， <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        sink(arr， i， length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下沉调整</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 调整位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length 数组范围</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span>[] arr， <span class="keyword">int</span> index， <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leftChild = <span class="number">2</span> * index + <span class="number">1</span>;<span class="comment">//左子节点下标</span></span><br><span class="line">    <span class="keyword">int</span> rightChild = <span class="number">2</span> * index + <span class="number">2</span>;<span class="comment">//右子节点下标</span></span><br><span class="line">    <span class="keyword">int</span> present = index;<span class="comment">//要调整的节点下标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//下沉左边</span></span><br><span class="line">    <span class="keyword">if</span> (leftChild &lt; length &amp;&amp; arr[leftChild] &gt; arr[present]) &#123;</span><br><span class="line">        present = leftChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下沉右边</span></span><br><span class="line">    <span class="keyword">if</span> (rightChild &lt; length &amp;&amp; arr[rightChild] &gt; arr[present]) &#123;</span><br><span class="line">        present = rightChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果下标不相等 证明调换过了</span></span><br><span class="line">    <span class="keyword">if</span> (present != index) &#123;</span><br><span class="line">        <span class="comment">//交换值</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[index];</span><br><span class="line">        arr[index] = arr[present];</span><br><span class="line">        arr[present] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//继续下沉</span></span><br><span class="line">        sink(arr， present， length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆排序和快速排序的时间复杂度都一样是 O(nlogn)。</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序的思想和我们打扑克摸牌的时候一样 ，从牌堆里一张一张摸起来的牌都是乱序的，我们会把摸起来的牌插入到左手中合适的位置，让左手中的牌时刻保持一个有序的状态。那如果我们不是从牌堆里摸牌，而是左手里面初始化就是一堆乱牌呢？ 一样的道理，我们把牌往手的右边挪一挪，把手的左边空出一点位置来，然后在乱牌中抽一张出来，插入到左边，再抽一张出来，插入到左边，再抽一张，插入到左边，每次插入都插入到左边合适的位置，时刻保持左边的牌是有序的，直到右边的牌抽完，则排序完毕。</p><h3 id="直接插入"><a href="#直接插入" class="headerlink" title="直接插入"></a>直接插入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = arr.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> value = arr[i];</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;<span class="comment">//插入的位置</span></span><br><span class="line"><span class="keyword">for</span> (j = i-<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; value) &#123;</span><br><span class="line"> arr[j+<span class="number">1</span>] = arr[j];<span class="comment">//移动数据</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> arr[j+<span class="number">1</span>] = value; <span class="comment">//插入数据</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码里我们可以看出，如果找到了合适的位置，就不会再进行比较了，就好比牌堆里抽 出的一张牌本身就比我手里的牌都小，那么我只需要直接放在末尾就行了，不用一个一个去移动数据腾出位置插入到中间。 所以说，最好情况的时间复杂度是 O(n)，最坏情况的时间复杂度是 O(n^2)，然而时间复杂度这个指标看的是最坏的情况 ，而不是最好的情况 ，所以插入排序的时间复杂度是O(n^2)。</p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序这个名字，来源于它的发明者希尔，也称作“缩小增量排序”，是插入排序的一种更高效的改进版本。 我们知道，插入排序对于大规模的乱序数组的时候效率是比较慢的，因为它每次只能将数据移动一位，希尔排序为了加快插入的速度，让数据移动的时候可以实现跳跃移动，节省了一部分的时间开支。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> length = arr.length;</span><br><span class="line"><span class="comment">//区间</span></span><br><span class="line"><span class="keyword">int</span> gap = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (gap &lt; length) &#123;</span><br><span class="line"> gap = gap * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; length; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> tmp = arr[i];</span><br><span class="line"><span class="keyword">int</span> j = i - gap;</span><br><span class="line"><span class="comment">//跨区间排序</span></span><br><span class="line"><span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; tmp) &#123;</span><br><span class="line"> arr[j + gap] = arr[j];</span><br><span class="line">  j -= gap;</span><br><span class="line"> &#125;</span><br><span class="line"> arr[j + gap] = tmp;</span><br><span class="line"> &#125;</span><br><span class="line"> gap = gap / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能你会问为什么区间要以 gap = gap*3+1 去计算，其实最优的区间计算方法是没 有答案的，这是一个长期未解决的问题，不过差不多都会取在三分之一到二分之一附近。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并字面上的意思是合并，归并算法的核心思想是<strong>分治法</strong>，就是将一个数组一刀切两半， 递归切，直到切成单个元素，然后重新组装合并，单个元素合并成小数组，两个小数组合并成大数组，直到最终合并完成，排序完毕。<br>分而治之，将一个大问题分解成无数的小问题进行处理，处理之后再合并，这里我们采用递归来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] tempArr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        sort(arr， tempArr， <span class="number">0</span>， arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归并排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 排序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tempArr 临时存储数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startIndex 排序起始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endIndex 排序终止位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr，<span class="keyword">int</span>[] tempArr，<span class="keyword">int</span> startIndex，<span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(endIndex &lt;= startIndex)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//中部下标</span></span><br><span class="line">        <span class="keyword">int</span> middleIndex = startIndex + (endIndex - startIndex) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分解</span></span><br><span class="line">        sort(arr，tempArr，startIndex，middleIndex);</span><br><span class="line">        sort(arr，tempArr，middleIndex + <span class="number">1</span>，endIndex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//归并</span></span><br><span class="line">        merge(arr，tempArr，startIndex，middleIndex，endIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归并</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 排序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tempArr 临时存储数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startIndex 归并起始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> middleIndex 归并中间位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endIndex 归并终止位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr， <span class="keyword">int</span>[] tempArr， <span class="keyword">int</span> startIndex， <span class="keyword">int</span> middleIndex， <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//复制要合并的数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = startIndex; s &lt;= endIndex; s++) &#123;</span><br><span class="line">            tempArr[s] = arr[s];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = startIndex;<span class="comment">//左边首位下标</span></span><br><span class="line">        <span class="keyword">int</span> right = middleIndex + <span class="number">1</span>;<span class="comment">//右边首位下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = startIndex; k &lt;= endIndex; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(left &gt; middleIndex)&#123;</span><br><span class="line">                <span class="comment">//如果左边的首位下标大于中部下标，证明左边的数据已经排完了。</span></span><br><span class="line">                arr[k] = tempArr[right++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right &gt; endIndex)&#123;</span><br><span class="line">                <span class="comment">//如果右边的首位下标大于了数组长度，证明右边的数据已经排完了。</span></span><br><span class="line">                arr[k] = tempArr[left++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tempArr[right] &lt; tempArr[left])&#123;</span><br><span class="line">                arr[k] = tempArr[right++];<span class="comment">//将右边的首位排入，然后右边的下标指针+1。</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr[k] = tempArr[left++];<span class="comment">//将左边的首位排入，然后左边的下标指针+1。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们可以发现 merge 方法中只有一个 for循环，直接就可以得出每次合并的时间复杂度为 O(n) ，而分解数组每次对半切割，属于对数时间 O(logn) ，合起来等于 O(log2n) ，也就是说，总的时间复杂度为 O(nlogn) 。</p><p>关于空间复杂度，其实大部分人写的归并都是在 merge方法里面申请临时数组，用临时数组来辅助排序工作，空间复杂度为 O(n)，而我这里做的是原地归并，只在最开始申请了一个临时数组，所以空间复杂度为 O(1)。</p><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序是一种非基于比较的排序算法，我们之前介绍的各种排序算法几乎都是基于元素之间的比较来进行排序的，计数排序的时间复杂度为 O(n + m)，m指的是数据量，说的简单点，计数排序算法的时间复杂度约等于 O(n)，快于任何比较型的排序算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//找出数组中的最大值</span></span><br><span class="line">    <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化计数数组</span></span><br><span class="line">    <span class="keyword">int</span>[] countArr = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        countArr[arr[i]]++;</span><br><span class="line">        arr[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; countArr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (countArr[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            arr[index++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>稳定排序<br>有一个需求就是当对成绩进行排名次的时候，如何在原来排前面的人，排序后还是处于相同成绩的人的前面。<br>解题的思路是对 countArr 计数数组进行一个变形，变来和名次挂钩，我们知道 countArr 存放的是分数的出现次数，那么其实我们可以算出每个分数的最大名次，就是将 countArr 中的每个元素顺序求和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//找出数组中的最大值</span></span><br><span class="line">    <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化计数数组</span></span><br><span class="line">    <span class="keyword">int</span>[] countArr = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; ++i) &#123;</span><br><span class="line">        countArr[arr[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//顺序累加</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; max + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        countArr[i] = countArr[i-<span class="number">1</span>] + countArr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//排序后的数组</span></span><br><span class="line">    <span class="keyword">int</span>[] sortedArr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        sortedArr[countArr[arr[i]]-<span class="number">1</span>] = arr[i];</span><br><span class="line">        countArr[arr[i]]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将排序后的数据拷贝到原数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; ++i) &#123;</span><br><span class="line">        arr[i] = sortedArr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>计数局限性<br>计数排序的毛病很多，我们来找找 bug 。</p></li></ul><p>如果我要排的数据里有 0 呢？ int[] 初始化内容全是 0 ，排毛线。</p><p>如果我要排的数据范围比较大呢？比如[ 1，9999 ]，我排两个数你要创建一个 int[10000] 的数组来计数？</p><p>对于第一个 bug ，我们可以使用偏移量来解决，比如我要排[ -1，0，-3 ]这组数字，这个简单，我全给你们加 10 来计数，变成[ 9，10，7 ]计完数后写回原数组时再减 10。不过有可能也会踩到坑，万一你数组里恰好有一个 -10，你加上 10 后又变 0 了，排毛线。</p><p>对于第二个 bug ，确实解决不了，如果是[ 9998，9999 ]这种虽然值大但是相差范围不大的数据我们也可以使用偏移量解决，比如这两个数据，我减掉 9997 后只需要申请一个 int[3] 的数组就可以进行计数。</p><p>由此可见，计数排序只适用于<strong>正整数并且取值范围相差不大的数组排序</strong>使用，它的排序的速度是非常可观的。</p><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序可以看成是计数排序的升级版，它将要排的数据分到多个有序的桶里，每个桶里的数据再单独排序，再把每个桶的数据依次取出，即可完成排序。<br>这个桶排序乍一看好像挺简单的，但是要敲代码就需要考虑几个问题了。<br>桶这个东西怎么表示？<br>怎么确定桶的数量？<br>桶内排序用什么方法排？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="comment">//最大最小值</span></span><br><span class="line">    <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> min = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> length = arr.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] &lt; min) &#123;</span><br><span class="line">            min = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大值和最小值的差</span></span><br><span class="line">    <span class="keyword">int</span> diff = max - min;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//桶列表</span></span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">        bucketList.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个桶的存数区间</span></span><br><span class="line">    <span class="keyword">float</span> section = (<span class="keyword">float</span>) diff / (<span class="keyword">float</span>) (length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据入桶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">        <span class="comment">//当前数除以区间得出存放桶的位置 减1后得出桶的下标</span></span><br><span class="line">        <span class="keyword">int</span> num = (<span class="keyword">int</span>) (arr[i] / section) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bucketList.get(num).add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//桶内排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketList.size(); i++)&#123;</span><br><span class="line">        <span class="comment">//jdk的排序速度当然信得过</span></span><br><span class="line">        Collections.sort(bucketList.get(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入原数组</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ArrayList&lt;Integer&gt; arrayList : bucketList)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> value : arrayList)&#123;</span><br><span class="line">            arr[index] = value;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>桶当然是一个可以存放数据的集合，我这里使用 arrayList ，如果你使用 LinkedList 那其实也是没有问题的。</p><p>桶的数量我认为设置为原数组的长度是合理的，因为理想情况下每个数据装一个桶。</p><p>数据入桶的映射算法其实是一个开放性问题，我承认我这里写的方案并不佳，因为我测试过不同的数据集合来排序，如果你有什么更好的方案或想法，欢迎留言讨论。</p><p>桶内排序为了方便起见使用了当前语言提供的排序方法，如果对于稳定排序有所要求，可以选择使用自定义的排序算法。</p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序是一种<strong>非比较型</strong>整数排序算法，其原理是将数据按位数切割成不同的数字，然后按每个位数分别比较。<br>假设说，我们要对 100 万个手机号码进行排序，应该选择什么排序算法呢？排的快的有归并、快排时间复杂度是 O(nlogn)，计数排序和桶排序虽然更快一些，但是手机号码位数是11位，那得需要多少桶？内存条表示不服。这个时候，我们使用基数排序是最好的选择。<br>基数排序可以看成桶排序的扩展，也是用桶来辅助排序，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = arr.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大值</span></span><br><span class="line">    <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &gt; max)&#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前排序位置</span></span><br><span class="line">    <span class="keyword">int</span> location = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//桶列表</span></span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//长度为10 装入余数0-9的数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        bucketList.add(<span class="keyword">new</span> ArrayList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断是否排完</span></span><br><span class="line">        <span class="keyword">int</span> dd = (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>，(location - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span>(max &lt; dd)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数据入桶</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//计算余数 放入相应的桶</span></span><br><span class="line">            <span class="keyword">int</span> number = ((arr[i] / dd) % <span class="number">10</span>);</span><br><span class="line">            bucketList.get(number).add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写回数组</span></span><br><span class="line">        <span class="keyword">int</span> nn = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> size = bucketList.get(i).size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> ii = <span class="number">0</span>;ii &lt; size;ii ++)&#123;</span><br><span class="line">                arr[nn++] = bucketList.get(i).get(ii);</span><br><span class="line">            &#125;</span><br><span class="line">            bucketList.get(i).clear();</span><br><span class="line">        &#125;</span><br><span class="line">        location++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实它的思想很简单，不管你的数字有多大，按照一位一位的排，0 - 9 最多也就十个桶：先按权重小的位置排序，然后按权重大的位置排序。</p><p>当然，如果你有需求，也可以选择从高位往低位排。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本部分资料来源: 不该相遇在秋天 五分钟学算法(&lt;a href=&quot;https://mp.weixin.qq.com/s/Qf416rfT4pwURpW3aDHuCg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.c
      
    
    </summary>
    
      <category term="算法基础" scheme="https://kepler-ecnu.github.io/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="排序算法" scheme="https://kepler-ecnu.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>场景题</title>
    <link href="https://kepler-ecnu.github.io/2019/08/29/%E5%9C%BA%E6%99%AF%E9%A2%98/"/>
    <id>https://kepler-ecnu.github.io/2019/08/29/场景题/</id>
    <published>2019-08-29T11:35:49.000Z</published>
    <updated>2019-09-02T08:47:41.435Z</updated>
    
    <content type="html"><![CDATA[<p>知识点来源牛客等总结，题目详解来自网络</p><h1 id="TOPN问题的M个数中最大的前N个数"><a href="#TOPN问题的M个数中最大的前N个数" class="headerlink" title="TOPN问题的M个数中最大的前N个数"></a>TOPN问题的M个数中最大的前N个数</h1><h2 id="找出十万个数据中-重复次数最多的十个数据并打印"><a href="#找出十万个数据中-重复次数最多的十个数据并打印" class="headerlink" title="找出十万个数据中,重复次数最多的十个数据并打印"></a>找出十万个数据中,重复次数最多的十个数据并打印</h2><p>利用集合 ,找出十万个数据中,重复次数最多的十个数据并打印.<br>先通过Hashmap存储, key为数据,value为它出现的次数.<br>然后用优先级队列,存储类型为Map.Entry,重写比较器类,利用value进行比较.<br>优先级队列中利用小根堆形式,只存储十个.<br>接下来遍历其他的,如果比小根堆堆顶的要大,对优先级队列进行remove和add操作.<br>最终,优先级队列中只会存储下来十个value最大的Entry<br>详细源码见原文链接：<a href="https://blog.csdn.net/weixin_43584947/article/details/84244440" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43584947/article/details/84244440</a></p><p>类似于<strong>现在有十万个单词，请你找出重复次数最多的十个</strong><br>归结为<strong>统计一篇很长的英文文章中频次出现最高的10个单词</strong><br>思路：<br>1.读入文件，按行将文字拼接成字符串str<br>2.用正则过滤字符串中的标点，再分割成str[]<br>3.用hashmap依次统计每个单词出现的次数（可以加黑名单过滤情态动词等）<br>4.对hashmap的值排序（利用Collections的sort，重写比较器Comparator的compare）<br>5.输出hashmap前10个单词<br>详细源码见原文链接：<a href="https://blog.csdn.net/lizhentao0707/article/details/80925715" target="_blank" rel="noopener">https://blog.csdn.net/lizhentao0707/article/details/80925715</a></p><p>还需要注意大文件数据的处理<br>如<strong>统计一篇超过10G的文章中每个单词出现的次数</strong><br>详细源码见原文链接：<a href="https://blog.csdn.net/xiaofeng10330111/article/details/87958174" target="_blank" rel="noopener">https://blog.csdn.net/xiaofeng10330111/article/details/87958174</a></p><h1 id="面试必须掌握的海量数据问题及解决方案"><a href="#面试必须掌握的海量数据问题及解决方案" class="headerlink" title="面试必须掌握的海量数据问题及解决方案"></a>面试必须掌握的海量数据问题及解决方案</h1><p>一些总结详见链接：<a href="https://blog.csdn.net/hitxueliang/article/details/52153476" target="_blank" rel="noopener">https://blog.csdn.net/hitxueliang/article/details/52153476</a><br><a href="http://www.360doc.com/content/16/0331/22/16915_546938410.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/16/0331/22/16915_546938410.shtml</a><br><a href="https://blog.csdn.net/v_july_v/article/category/1106578" target="_blank" rel="noopener">https://blog.csdn.net/v_july_v/article/category/1106578</a><br>其中整理比较全面的是<a href="https://blog.csdn.net/v_july_v/article/details/7382693" target="_blank" rel="noopener">https://blog.csdn.net/v_july_v/article/details/7382693</a></p><h1 id="在淘宝购物，这个场景下，你会怎样来设计消息队列？"><a href="#在淘宝购物，这个场景下，你会怎样来设计消息队列？" class="headerlink" title="在淘宝购物，这个场景下，你会怎样来设计消息队列？"></a>在淘宝购物，这个场景下，你会怎样来设计消息队列？</h1><p>消息队列在电商中的应用的几个问题，比如在下单，秒杀场景中使用的疑惑。<br>详见 <a href="https://bbs.csdn.net/topics/392169691?page=1" target="_blank" rel="noopener">https://bbs.csdn.net/topics/392169691?page=1</a></p><h1 id="谈一谈，分布式集群中-如何保证线程安全？"><a href="#谈一谈，分布式集群中-如何保证线程安全？" class="headerlink" title="谈一谈，分布式集群中 如何保证线程安全？"></a>谈一谈，分布式集群中 如何保证线程安全？</h1><p>链接：<a href="https://www.jianshu.com/p/8c9e98a6e936" target="_blank" rel="noopener">https://www.jianshu.com/p/8c9e98a6e936</a></p><h1 id="请你设计一种方案，给每个组分配不同的IP段，并且可以快速得知某个IP是哪个组的"><a href="#请你设计一种方案，给每个组分配不同的IP段，并且可以快速得知某个IP是哪个组的" class="headerlink" title="请你设计一种方案，给每个组分配不同的IP段，并且可以快速得知某个IP是哪个组的?"></a>请你设计一种方案，给每个组分配不同的IP段，并且可以快速得知某个IP是哪个组的?</h1><p>类似于二分查找：如何快速定位IP对应的省份地址？<br>链接：<a href="https://blog.csdn.net/qq_16399991/article/details/86249224" target="_blank" rel="noopener">https://blog.csdn.net/qq_16399991/article/details/86249224</a></p><h1 id="有一个外卖平台，平台有很多外卖商家，但是平台上的广告位有限，如何使用有限的广告位来推广这些商家，假如平台每天会从10000个商家里面推荐50个商家放在广告为，每个商家有一个权值，你如何来做推荐？第二天怎么更新推荐的商家？"><a href="#有一个外卖平台，平台有很多外卖商家，但是平台上的广告位有限，如何使用有限的广告位来推广这些商家，假如平台每天会从10000个商家里面推荐50个商家放在广告为，每个商家有一个权值，你如何来做推荐？第二天怎么更新推荐的商家？" class="headerlink" title="有一个外卖平台，平台有很多外卖商家，但是平台上的广告位有限，如何使用有限的广告位来推广这些商家，假如平台每天会从10000个商家里面推荐50个商家放在广告为，每个商家有一个权值，你如何来做推荐？第二天怎么更新推荐的商家？"></a>有一个外卖平台，平台有很多外卖商家，但是平台上的广告位有限，如何使用有限的广告位来推广这些商家，假如平台每天会从10000个商家里面推荐50个商家放在广告为，每个商家有一个权值，你如何来做推荐？第二天怎么更新推荐的商家？</h1><p>从推荐算法中找灵感吧<br><a href="https://blog.csdn.net/fyq201749/article/details/81026950" target="_blank" rel="noopener">https://blog.csdn.net/fyq201749/article/details/81026950</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;知识点来源牛客等总结，题目详解来自网络&lt;/p&gt;
&lt;h1 id=&quot;TOPN问题的M个数中最大的前N个数&quot;&gt;&lt;a href=&quot;#TOPN问题的M个数中最大的前N个数&quot; class=&quot;headerlink&quot; title=&quot;TOPN问题的M个数中最大的前N个数&quot;&gt;&lt;/a&gt;TOPN问
      
    
    </summary>
    
      <category term="java知识点整理" scheme="https://kepler-ecnu.github.io/categories/java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    
    
      <category term="java知识点" scheme="https://kepler-ecnu.github.io/tags/java%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>list去重问题</title>
    <link href="https://kepler-ecnu.github.io/2019/08/26/list%E5%8E%BB%E9%87%8D%E9%97%AE%E9%A2%98/"/>
    <id>https://kepler-ecnu.github.io/2019/08/26/list去重问题/</id>
    <published>2019-08-26T07:52:55.000Z</published>
    <updated>2019-08-26T08:32:24.786Z</updated>
    
    <content type="html"><![CDATA[<p>对于面试中经常被提及的list如何去重问题，用于考察对list数据结构，以及相关方法的掌握，体现出对Java基础掌握程度。</p><p>set集合的特点是没有重复的元素。如果集合中的数据类型是<strong>基本数据类型</strong>，可以直接将list集合转换成set，就会自动去除重复的元素，这个相对比较简单。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="number">11</span>);</span><br><span class="line">        list.add(<span class="number">12</span>);</span><br><span class="line">        list.add(<span class="number">13</span>);</span><br><span class="line">        list.add(<span class="number">14</span>);</span><br><span class="line">        list.add(<span class="number">15</span>);</span><br><span class="line">        list.add(<span class="number">11</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        Set set = <span class="keyword">new</span> HashSet();</span><br><span class="line">        List newList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        set.addAll(list);</span><br><span class="line">        newList.addAll(set);</span><br><span class="line">        System.out.println(newList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">11</span>]</span><br><span class="line">[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]</span><br></pre></td></tr></table></figure><p>可以看到去重成功。</p><p>但是在面试中被问到list去重问题，大部分回答都是list和set互转，利用set自动去重方法去重，但是这样的回答并不会得分。</p><p>原因在于当list集合中存储的类型是<strong>对象类型</strong>时，我们就不能简单的只把list集合转换成set集合。<br>我们定义一个对象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String phoneNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPhoneNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> phoneNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPhoneNumber</span><span class="params">(String phoneNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.phoneNumber = phoneNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name, String phoneNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.phoneNumber = phoneNumber;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"People&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", phoneNumber='"</span> + phoneNumber + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用上面的set去重的方法去重：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;People&gt; listPeople = <span class="keyword">new</span> ArrayList&lt;People&gt;();</span><br><span class="line">    listPeople.add(<span class="keyword">new</span> People(<span class="string">"张三"</span>, <span class="string">"11111"</span>));</span><br><span class="line">    listPeople.add(<span class="keyword">new</span> People(<span class="string">"张三"</span>,  <span class="string">"22222"</span>));</span><br><span class="line">    listPeople.add(<span class="keyword">new</span> People(<span class="string">"李四"</span>,  <span class="string">"33333"</span>));</span><br><span class="line">    listPeople.add(<span class="keyword">new</span> People(<span class="string">"张三"</span>,  <span class="string">"22222"</span>));</span><br><span class="line">    Set&lt;People&gt; setData = <span class="keyword">new</span> HashSet&lt;People&gt;();</span><br><span class="line">    setData.addAll(listPeople);</span><br><span class="line">    System.out.println(<span class="string">"list："</span> + listPeople.toString());</span><br><span class="line">    System.out.println(<span class="string">"set："</span> + setData.toString());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后输出的结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list：[People&#123;name=<span class="string">'张三'</span>, phoneNumber=<span class="string">'11111'</span>&#125;, People&#123;name=<span class="string">'张三'</span>, phoneNumber=<span class="string">'22222'</span>&#125;, People&#123;name=<span class="string">'李四'</span>, phoneNumber=<span class="string">'33333'</span>&#125;, People&#123;name=<span class="string">'张三'</span>, phoneNumber=<span class="string">'22222'</span>&#125;]</span><br><span class="line">set：[People&#123;name=<span class="string">'张三'</span>, phoneNumber=<span class="string">'11111'</span>&#125;, People&#123;name=<span class="string">'李四'</span>, phoneNumber=<span class="string">'33333'</span>&#125;, People&#123;name=<span class="string">'张三'</span>, phoneNumber=<span class="string">'22222'</span>&#125;, People&#123;name=<span class="string">'张三'</span>, phoneNumber=<span class="string">'22222'</span>&#125;]</span><br></pre></td></tr></table></figure><p>我们可以看到第二个张三和最后一个张三，信息都一样，却没有被去重。<br>当list集合中存储的是<strong>对象</strong>时，我们需要在对象的实体类中去<strong>重写equals()方法和hashCode()方法</strong>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String phoneNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPhoneNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> phoneNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPhoneNumber</span><span class="params">(String phoneNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.phoneNumber = phoneNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name, String phoneNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.phoneNumber = phoneNumber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"People&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", phoneNumber='"</span> + phoneNumber + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object arg0)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        People p = (People) arg0;</span><br><span class="line">        <span class="keyword">return</span> name.equals(p.name) &amp;&amp; phoneNumber.equals(p.phoneNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        String str = name + phoneNumber;</span><br><span class="line">        <span class="keyword">return</span> str.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行上述test方法，可以得出去重成功：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list：[People&#123;name=<span class="string">'张三'</span>, phoneNumber=<span class="string">'11111'</span>&#125;, People&#123;name=<span class="string">'张三'</span>, phoneNumber=<span class="string">'22222'</span>&#125;, People&#123;name=<span class="string">'李四'</span>, phoneNumber=<span class="string">'33333'</span>&#125;, People&#123;name=<span class="string">'张三'</span>, phoneNumber=<span class="string">'22222'</span>&#125;]</span><br><span class="line">set：[People&#123;name=<span class="string">'张三'</span>, phoneNumber=<span class="string">'22222'</span>&#125;, People&#123;name=<span class="string">'张三'</span>, phoneNumber=<span class="string">'11111'</span>&#125;, People&#123;name=<span class="string">'李四'</span>, phoneNumber=<span class="string">'33333'</span>&#125;]</span><br></pre></td></tr></table></figure><p>最后，我们拿出String中的equals()方法和hashCode()方法源码来加深认识：<br><strong>equals()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            String anotherString = (String)anObject;</span><br><span class="line">            <span class="keyword">int</span> n = count;</span><br><span class="line">            <span class="keyword">if</span> (n == anotherString.count) &#123;</span><br><span class="line">                <span class="keyword">char</span> v1[] = value;</span><br><span class="line">                <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">                <span class="keyword">int</span> i = offset;</span><br><span class="line">                <span class="keyword">int</span> j = anotherString.offset;</span><br><span class="line">                <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v1[i++] != v2[j++])</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>比较两个对象时，首先先去判断两个对象是否具有相同的地址，如果是同一个对象的引用，则直接放回true；如果地址不一样，则证明不是引用同一个对象，接下来就是挨个去比较两个字符串对象的内容是否一致，完全相等返回true，否则false。</p><p><strong>hashCode()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h = hash;</span><br><span class="line">       <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">int</span> off = offset;</span><br><span class="line">           <span class="keyword">char</span> val[] = value;</span><br><span class="line">           <span class="keyword">int</span> len = count;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">               h = <span class="number">31</span>*h + val[off++];</span><br><span class="line">           &#125;</span><br><span class="line">           hash = h;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> h;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>hashCode()官方定义：</strong><br>hashcode方法返回该对象的哈希码值。支持该方法是为哈希表提供一些优点，例如，java.util.Hashtable 提供的哈希表。<br><strong>hashCode 的常规协定是：</strong><br>在 Java 应用程序执行期间，在同一对象上多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是对象上 equals 比较中所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。<br>如果根据 equals(Object) 方法，两个对象是相等的，那么在两个对象中的每个对象上调用 hashCode 方法都必须生成相同的整数结果。<br>以下情况不是必需的：如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么在两个对象中的任一对象上调用 hashCode 方法必定会生成不同的整数结果。但是，程序员应该知道，为不相等的对象生成不同整数结果可以提高哈希表的性能。<br>实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。）<br>当equals方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于面试中经常被提及的list如何去重问题，用于考察对list数据结构，以及相关方法的掌握，体现出对Java基础掌握程度。&lt;/p&gt;
&lt;p&gt;set集合的特点是没有重复的元素。如果集合中的数据类型是&lt;strong&gt;基本数据类型&lt;/strong&gt;，可以直接将list集合转换成se
      
    
    </summary>
    
      <category term="java知识点整理" scheme="https://kepler-ecnu.github.io/categories/java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    
    
      <category term="java知识点" scheme="https://kepler-ecnu.github.io/tags/java%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>单例问题</title>
    <link href="https://kepler-ecnu.github.io/2019/08/26/%E5%8D%95%E4%BE%8B%E9%97%AE%E9%A2%98/"/>
    <id>https://kepler-ecnu.github.io/2019/08/26/单例问题/</id>
    <published>2019-08-26T04:17:10.000Z</published>
    <updated>2019-08-26T05:20:31.089Z</updated>
    
    <content type="html"><![CDATA[<p>在早期的项目代码中，如果我们想使用类的某个方法，我们基本都会创建一个类的对象实例然后再调用方法，这样的实现往往在系统内存在某个类的大量实例。久而久之，项目框架很难管理大量的对象，而且如果Java虚拟机不能及时回收，也很容易造成内存溢出。</p><p>所谓<strong>单例</strong>就是在项目框架内某个类的对象实例只存在一个，任何调用方获取到的对象实例都是一个，那么很明显这个类是不能被外部直接调用类构造器创建的。</p><p>首先看一个简单的单例设计（<strong>饱汉式</strong>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码在单线程中是没有问题的，而且只有当线程调用类的静态方法时，才会生成类的静态变量。但是当多线程访问时，上面代码是有问题的，会生成多个对象的实例。<br><strong>注：为什么要特意加一个空的构造函数呢？</strong><br>如果使用默认的构造函数，那么new一个依然可以获取到另一份单例实体，这是不允许的。因此这里显示的把构造函数置空，同时加上private保证外界无法访问，用户即使new了一个也无法再次创建单例对象，要用这个对象只能通过暴露给外界的getInstance方法获取。简言之，将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例.</p><p>那么，我们可以用另外一种方法实现，比如说在类加载时就初始化对象的实例，这样后面无论怎么调用类静态方法都不创建新的实例。还有一种方法，但是会牺牲部分系统性能，即在多线程访问方法时通过锁机制让线程排队访问。我们先通过在类方法上加锁来实现类的单例，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法能实现单例，而且采用的思路是延迟加载，但是执行效率比较低。</p><p>还可以使用双重锁(Double CheckLock)机制来实现单例模式，一方面需要在实例上加上volatile关键字通知操作系统实现线程访问时内存屏障，然后还需要在方法中通过虚拟机实现的synchronized来同步方法访问，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line"><span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不考虑服务负载问题，在多线程环境下可以预先加载类的静态实例，当虚拟机加载完成类后就会创建类的静态变量，不管用不用，先实例化再说。所有线程访问到的都是同一静态实例，也称这种方式为<strong>饿汉式</strong>，写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面写法实现单例也是没有问题的，但是觉得如果我只是想调用一个类的某个静态方法，并不想生成它的实例，那有没有其他方法呢，经过各路大神的指点结合自身的总结，可以使用<strong>内部静态类</strong>来实现这个需求。<br>虚拟机在加载类的过程中一开始并不会初始化类的内部静态类。如果线程调用内部静态类时，虚拟机只会初始化一次，这样既可以实现单例，同时也是线程安全的。具体写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> InnerClass.singleton;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了以上讲到的几种方式外，JDK自身的<strong>枚举类型</strong>本身就是单例的实现，调用者不能显式的调用构造器完成实例创建，因此很多Java规范文档推荐使用枚举来实现单例。<br>当然对于初级开发人员而言，现在的主流开发框架都提供单例/多例模式供开发者选择，这样的好处让开发者更多关注业务功能开发，而不用过多关注虚拟机内部类实例创建问题。例如spring中默认类注入就是单例的，可以根据实际情况设置scope为singleton(单例)或者prototype(多例),如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"dateUtil"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.microsoft.manage.DateUtil"</span> init-method=<span class="string">"init"</span> scope=<span class="string">"Singleton"</span>&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在早期的项目代码中，如果我们想使用类的某个方法，我们基本都会创建一个类的对象实例然后再调用方法，这样的实现往往在系统内存在某个类的大量实例。久而久之，项目框架很难管理大量的对象，而且如果Java虚拟机不能及时回收，也很容易造成内存溢出。&lt;/p&gt;
&lt;p&gt;所谓&lt;strong&gt;单
      
    
    </summary>
    
      <category term="java知识点整理" scheme="https://kepler-ecnu.github.io/categories/java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    
    
      <category term="java知识点" scheme="https://kepler-ecnu.github.io/tags/java%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Swagger-前后端分离开发的API接口框架</title>
    <link href="https://kepler-ecnu.github.io/2019/08/15/Swagger/"/>
    <id>https://kepler-ecnu.github.io/2019/08/15/Swagger/</id>
    <published>2019-08-15T11:54:01.000Z</published>
    <updated>2019-08-15T13:50:50.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Swagger-UI"><a href="#Swagger-UI" class="headerlink" title="Swagger-UI"></a>Swagger-UI</h1><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>随着互联网技术的发展，现在的网站架构基本都是由原来的后端渲染，变成了前端渲染、前后端分离的形态，而且前端技术和后端技术在各自的道路上越走越远。<br>前端和后端的唯一联系，变成了API接口；API文档变成了前后端开发人员联系的纽带，变得越来越重要，swagger就是这样一个可以更好的书写API文档的框架。</p><h2 id="认识Swagger"><a href="#认识Swagger" class="headerlink" title="认识Swagger"></a>认识Swagger</h2><p>Swagger是一个规范和完整的框架，用于生成、描述、调用和可视化RESTful风格的Web服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法、参数和模型紧密集成到服务器端的代码，允许API来始终保持同步。<br><strong>作用</strong></p><ul><li>接口的文档在线自动生成</li><li>功能测试</li></ul><p><strong>目标</strong><br>Swagger的目标是为REST APIs定义一个标准的，与语言无关的接口，使人和计算机在看不到源码或者看不到文档或者不能通过网络流量检测的情况下额能发现和理解各种服务的功能。<br><strong>Swagger是一组开源项目，其中主要项目如下：</strong></p><ul><li>Swagger-tools：提供各种与Swagger进行集成和交互的工具。例如模式检验、swagger 1.2文档转换成swagger 2.0文档等功能。</li><li>Swagger-core：用于Java/Scala的Swagger实现。与JAX-RS(Jersy、Resteasy、CXF…)、Servlet和Play框架进行集成。</li><li>Swagger-js：用于JavaScript的Swagger实现。</li><li>Swagger-node-express：Swagger模块、用于node.js的Express web应用框架。</li><li>Swagger-ui：一个无依赖的HTML、JS和CSS集合，可以为Swagger兼容API动态生成优雅文档。</li><li>Swagger-codegen：一个模板驱动引擎，通过分析用户Swagger资源声明以各种语言生成客户端代码。</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li><p>Maven-POM文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- swagger-api 依赖开始--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- swagger-api 依赖结束--&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Swagger配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.config;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.EnableWebMvc;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.Contact;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 必须存在</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span> <span class="comment">// 必须存在</span></span><br><span class="line"><span class="meta">@EnableSwagger</span>2 <span class="comment">// 必须存在</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"swagger"</span>) <span class="comment">// swagger 与 yml 文件中一致</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"com.example.demo.controller"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">customDocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket( DocumentationType.SWAGGER_2).apiInfo(apiInfo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Contact contact = <span class="keyword">new</span> Contact(<span class="string">"kepler"</span>, <span class="string">"kepler-ecnu.github.io"</span>, <span class="string">"1519535214@qq,.com"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                .title(<span class="string">"测试项目API接口"</span>)</span><br><span class="line">                .description(<span class="string">"API接口"</span>)</span><br><span class="line">                .contact(contact)</span><br><span class="line">                .version(version)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>WebMvc配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.config;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">"swagger-ui.html"</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">"classpath:/META-INF/resources/"</span>);</span><br><span class="line"></span><br><span class="line">        registry.addResourceHandler(<span class="string">"/webjars/**"</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">"classpath:/META-INF/resources/webjars/"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>控制器类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.controller;</span><br><span class="line"><span class="keyword">import</span> com.example.demo.user.User;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.Api;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiImplicitParam;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiOperation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Api</span>(value = <span class="string">"用户模块"</span>,description = <span class="string">"用户模块的接口信息"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟数据库</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> List&lt;User&gt; users = <span class="keyword">new</span> ArrayList&lt;&gt;(  );</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        users.add( <span class="keyword">new</span> User(<span class="string">"张三"</span>,<span class="string">"123"</span>) );</span><br><span class="line">        users.add( <span class="keyword">new</span> User(<span class="string">"李四"</span>,<span class="string">"123456"</span>) );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取用户列表的方法</span></span><br><span class="line">    <span class="meta">@ApiOperation</span>( value = <span class="string">"获取用户列表"</span>,notes = <span class="string">"获取所有用户的列表"</span>)</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/users"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Object <span class="title">users</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put( <span class="string">"users"</span>,users );</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  根据ID查询某个用户的信息</span></span><br><span class="line">    <span class="meta">@ApiOperation</span>( value = <span class="string">"获取单个用户"</span>,notes = <span class="string">"根据ID查询某个用户的信息"</span>)</span><br><span class="line">    <span class="meta">@ApiImplicitParam</span>(value = <span class="string">"用户的ID"</span>,paramType = <span class="string">"path"</span>)</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">int</span> id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> users.get( id );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加用户</span></span><br><span class="line">    <span class="meta">@ApiOperation</span>( value =<span class="string">"添加用户"</span>,notes = <span class="string">"根据传入的用户信息添加用户"</span>)</span><br><span class="line">    <span class="meta">@ApiImplicitParam</span>(value = <span class="string">"用户对象"</span>,paramType = <span class="string">"query"</span>)</span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">add</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> users.add( user );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除对象</span></span><br><span class="line">    <span class="meta">@ApiOperation</span>( value = <span class="string">"删除用户"</span>,notes = <span class="string">"根据传入的用户ID删除对应下标的用户"</span>)</span><br><span class="line">    <span class="meta">@ApiImplicitParam</span>(value = <span class="string">"用户的ID"</span>,paramType = <span class="string">"path"</span>)</span><br><span class="line">    <span class="meta">@DeleteMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">delete</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">int</span> id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> users.remove( id );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.EnableWebMvc;</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span> <span class="comment">// 添加</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run( DemoApplication.class, args );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>打开浏览器<br>通过 <a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a> 打开swagger API页面<br><img src="/images/swagger%E9%A1%B5%E9%9D%A2.png" alt="swagger页面"></p></li><li><p>测试页面截图<br><img src="/images/swagger%E9%A1%B9%E7%9B%AE%E6%B5%8B%E8%AF%95.png" alt="swagger项目测试"></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Swagger-UI&quot;&gt;&lt;a href=&quot;#Swagger-UI&quot; class=&quot;headerlink&quot; title=&quot;Swagger-UI&quot;&gt;&lt;/a&gt;Swagger-UI&lt;/h1&gt;&lt;h2 id=&quot;背景知识&quot;&gt;&lt;a href=&quot;#背景知识&quot; class=&quot;head
      
    
    </summary>
    
      <category term="Java" scheme="https://kepler-ecnu.github.io/categories/Java/"/>
    
      <category term="Swagger" scheme="https://kepler-ecnu.github.io/categories/Java/Swagger/"/>
    
    
      <category term="Java" scheme="https://kepler-ecnu.github.io/tags/Java/"/>
    
      <category term="api" scheme="https://kepler-ecnu.github.io/tags/api/"/>
    
      <category term="Swagger" scheme="https://kepler-ecnu.github.io/tags/Swagger/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-08</title>
    <link href="https://kepler-ecnu.github.io/2019/08/14/SpringBoot-08/"/>
    <id>https://kepler-ecnu.github.io/2019/08/14/SpringBoot-08/</id>
    <published>2019-08-14T14:39:41.000Z</published>
    <updated>2019-08-15T11:32:28.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="配置文件的注入"><a href="#配置文件的注入" class="headerlink" title="配置文件的注入"></a>配置文件的注入</h1><h2 id="单值注入"><a href="#单值注入" class="headerlink" title="单值注入"></a>单值注入</h2><p>使用 @Value 注解注入单个属性的值</p><ul><li><p>yml配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">"zhangsan \n  lisi"</span></span><br><span class="line"><span class="attr">  age:</span> <span class="number">23</span></span><br><span class="line"><span class="attr">  boss:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  birth:</span> <span class="number">2018</span><span class="string">/12/01</span></span><br></pre></td></tr></table></figure></li><li><p>Java代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相较之前方式</span></span><br><span class="line"><span class="comment">//datasource.properties 数据源的配置文件</span></span><br><span class="line"><span class="comment">//&lt;bean ..&gt; &lt;property name="url" value="$&#123;url&#125;"&gt;&lt;/property&gt; &lt;/bean&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;person.name&#125;"</span>) </span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure></li></ul><p>${key} :来引用属性文件中key对应的值</p><h2 id="批量注入"><a href="#批量注入" class="headerlink" title="批量注入"></a>批量注入</h2><p>使用 @ConfigurationProperties 注解批量注入配置文件中的多个值</p><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">王二</span></span><br><span class="line"><span class="attr">  age:</span> <span class="number">18</span></span><br><span class="line"><span class="attr">  boss:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  birth:</span> <span class="number">2017</span><span class="string">/12/12</span></span><br><span class="line"><span class="attr">  maps:</span> <span class="string">&#123;k1:</span> <span class="string">v1,</span> <span class="attr">k2:</span> <span class="number">12</span><span class="string">&#125;</span></span><br><span class="line"><span class="attr">  lists:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">张三</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">李四</span></span><br><span class="line"><span class="attr">  dog:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">小奶狗</span></span><br><span class="line"><span class="attr">    age:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装配置文件中person中的数据</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用@ConfigurationProperties注解必须同时添加@Component讲当前的配置类放入IOC容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    Logger log = LoggerFactory.getLogger( HelloWorld.class );</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">user</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.info(user.toString() );</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>控制台的输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User(name=王二, age=<span class="number">18</span>, maps=&#123;k1=v1, k2=<span class="number">12</span>&#125;, lists=[张三, 李四], dog=Dog(name=小奶狗, age=<span class="number">2</span>))</span><br></pre></td></tr></table></figure></li></ul><p>@Data是一个lombok插件，免去了getter/setter和toString这些繁琐的东西<br>在POM文件的节点中间添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">&gt;      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">&gt;      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">&gt;      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">&gt;      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">&gt;  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>javaBean：</p><ul><li>将配置文件中配置的每一个属性的值，映射到这个组件中</li><li>@ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；</li><li>prefix = “person”：配置文件中哪个下面的所有属性进行一一映射</li><li>只有这个组件是容器中的组件，才能使用容器提供的@ConfigurationProperties功能；</li><li>@Data是一个插件，免去了getter/setter和toString这些繁琐的东西</li></ul><p>如果在编写yml文件的时候没有出现属性提示：<br>我们可以导入配置文件处理器，以后编写配置就有提示了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="两种注入的区别"><a href="#两种注入的区别" class="headerlink" title="两种注入的区别"></a>两种注入的区别</h2><ul><li>@Value获取值和@ConfigurationProperties获取值的区别</li></ul><table><thead><tr><th></th><th>@ConfigurationProperties</th><th>@Value</th></tr></thead><tbody><tr><td>功能</td><td>批量注入配置文件中的属性</td><td>一个个指定</td></tr><tr><td>松散绑定（松散语法）</td><td>支持</td><td>不支持</td></tr><tr><td>SpEL： #{}</td><td>不支持</td><td>支持</td></tr><tr><td>JSR303数据校验</td><td>支持</td><td>不支持</td></tr><tr><td>复杂类型封装</td><td>支持</td><td>不支持</td></tr></tbody></table><p>松散语法绑定：last_name = last-name = lastName 他们取的值都是相同的<br>配置文件yml还是properties他们都能获取到值；</p><p>总结：</p><ul><li>如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value；</li><li>如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties；</li></ul><h2 id="注入值的数据检验"><a href="#注入值的数据检验" class="headerlink" title="注入值的数据检验"></a>注入值的数据检验</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Validated</span> <span class="comment">//数据校验</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Email</span>(message = <span class="string">"用户名必须是一个正确的邮箱格式"</span>)</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="meta">@Max</span>(value = <span class="number">200</span>,message = <span class="string">"年龄不能超过200岁"</span>)</span><br><span class="line">    <span class="meta">@Min</span>(value = <span class="number">0</span>,message = <span class="string">"年龄必须大于0岁"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过测试得出，两个注解不能同时作用在一个属性上。</p><h1 id="其他配置文件"><a href="#其他配置文件" class="headerlink" title="其他配置文件"></a>其他配置文件</h1><h2 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h2><ul><li><p>@PropertySource：加载指定的配置文件；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource</span>( value=&#123;<span class="string">"classpath:application.yml"</span>&#125;)</span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">    <span class="comment">//private Map&lt;String, Object&gt; maps;</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  请注意 [字串，bool，时间，列表可以注入]，map不能注入，<br>  简单的数据类型Spring注入数据后进行了类型转换<br>输出注入的数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User(name=王二, age=<span class="number">18</span>, lists=[张三, 李四], dog=Dog(name=小奶狗, age=<span class="number">2</span>))</span><br></pre></td></tr></table></figure></li></ul><p>IDEA设置x.properties文件的默认编码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Settings</span><br><span class="line">–&gt; Editor</span><br><span class="line">–&gt; File Encoding</span><br><span class="line">–&gt; Properties Files(*.properties)</span><br><span class="line">–&gt; Default encoding for properties files: UTF-8</span><br><span class="line">–&gt; OK</span><br></pre></td></tr></table></figure><h2 id="ImportResource"><a href="#ImportResource" class="headerlink" title="@ImportResource"></a>@ImportResource</h2><ul><li><p>@ImportResource：导入Spring的配置文件，让配置文件里面的内容生效；<br>想让Spring的配置文件生效，@ImportResource标注在一个配置类上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ImportResource</span>(locations = &#123;<span class="string">"classpath:beans.xml"</span>&#125;)</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(SpringbootApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Spring的配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"p123"</span> <span class="attr">class</span>=<span class="string">"site.accp.demo7.pojo.People"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lastName"</span> <span class="attr">value</span>=<span class="string">"123"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7ApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ApplicationContext ioc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> p123 = ioc.containsBean(<span class="string">"p123"</span>);</span><br><span class="line">        System.out.println(p123);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h2><p>SpringBoot推荐使用全注解的方式给容器中添加组件</p><ol><li>配置类@Configuration –&gt; Spring配置文件</li><li>使用@Bean给容器中添加组件<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Configuration</span>：指明当前类是一个配置类；就是来替代之前的Spring配置文件</span></span><br><span class="line"><span class="comment"> * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloService <span class="title">helloService02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"配置类@Bean给容器中添加组件了..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHelloService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> b = ioc.containsBean(<span class="string">"helloService02"</span>);</span><br><span class="line">    System.out.println(b); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：配置类@Bean给容器中添加组件了… 同时返回true</p><h2 id="配置文件占位符"><a href="#配置文件占位符" class="headerlink" title="配置文件占位符"></a>配置文件占位符</h2><ul><li><p>随机数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;random.value&#125;、$&#123;random.<span class="keyword">int</span>&#125;、$&#123;random.<span class="keyword">long</span>&#125;</span><br><span class="line">$&#123;random.<span class="keyword">int</span>(<span class="number">10</span>)&#125;、$&#123;random.<span class="keyword">int</span>[<span class="number">1024</span>,<span class="number">65536</span>]&#125;</span><br></pre></td></tr></table></figure></li><li><p>占位符获取之前配置的值<br>  如果没有可以使用的:指定默认值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">person.last-name=张三$&#123;random.uuid&#125;</span><br><span class="line">person.age=$&#123;random.<span class="keyword">int</span>&#125;</span><br><span class="line">person.birth=<span class="number">2017</span>/<span class="number">12</span>/<span class="number">15</span></span><br><span class="line">person.boss=<span class="keyword">false</span></span><br><span class="line">person.maps.k1=v1</span><br><span class="line">person.maps.k2=<span class="number">14</span></span><br><span class="line">person.lists=a,b,c</span><br><span class="line"># 没有取到:后面是默认值</span><br><span class="line">person.dog.name=$&#123;person.hello:hello&#125;_dog</span><br><span class="line">person.dog.age=<span class="number">15</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;配置文件的注入&quot;&gt;&lt;a href=&quot;#配置文件的注入&quot; class=&quot;headerlink&quot; title=&quot;配置文件的注入&quot;&gt;&lt;/a&gt;配置文件的注入&lt;/h1&gt;&lt;h2 id=&quot;单值注入&quot;&gt;&lt;a href=&quot;#单值注入&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="Java" scheme="https://kepler-ecnu.github.io/categories/Java/"/>
    
      <category term="Spring" scheme="https://kepler-ecnu.github.io/categories/Java/Spring/"/>
    
      <category term="Spring Boot" scheme="https://kepler-ecnu.github.io/categories/Java/Spring/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="https://kepler-ecnu.github.io/tags/Spring-Boot/"/>
    
      <category term="Java" scheme="https://kepler-ecnu.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-07</title>
    <link href="https://kepler-ecnu.github.io/2019/08/14/SpringBoot-07/"/>
    <id>https://kepler-ecnu.github.io/2019/08/14/SpringBoot-07/</id>
    <published>2019-08-14T13:52:09.000Z</published>
    <updated>2019-08-14T14:35:45.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="配置文件详解"><a href="#配置文件详解" class="headerlink" title="配置文件详解"></a>配置文件详解</h1><h2 id="YML是什么"><a href="#YML是什么" class="headerlink" title="YML是什么"></a>YML是什么</h2><p>SpringBoot使用一个全局的配置文件，配置文件名是固定的；</p><ul><li>application.properties</li><li>application.yml</li></ul><p>配置文件的作用：修改SpringBoot自动配置的默认值；</p><p>YAML（YAML Ain’t Markup Language）</p><pre><code>YAML A Markup Language：是一个标记语言YAML isn’t Markup Language：不是一个标记语言</code></pre><p>标记语言：</p><pre><code>以前的配置文件；大多都使用的是xxx.xml文件；YAML：以数据为中心，比json、xml等更适合做配置文件；</code></pre><ul><li><p>YAML：配置例子</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure></li><li><p>XML：配置例子</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">port</span>&gt;</span>8081<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="YML语法"><a href="#YML语法" class="headerlink" title="YML语法"></a>YML语法</h2><p>k:(空格)v：表示一对键值对（空格必须有）；<br>以<strong>空格</strong>的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">/hello</span></span><br></pre></td></tr></table></figure><p> 属性和值也是大小写敏感；</p><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><pre><code>普通的值（数字，字符串，布尔）</code></pre><p>k: v 字面量直接来写</p><pre><code>字符串默认不用加上单引号或者双引号；&quot;&quot;：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思    name:   &quot;zhangsan \n lisi&quot;：输出；zhangsan 换行  lisi&apos;&apos;：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据    name:   ‘zhangsan \n lisi’：输出；zhangsan \n  lisi</code></pre><h3 id="对象、-Map"><a href="#对象、-Map" class="headerlink" title="对象、 Map"></a>对象、 Map</h3><pre><code>(属性和值) (键值对)：</code></pre><p>k: v：在下一行来写对象的属性和值的关系；注意缩进<br>​ 对象还是k: v的方式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">friends:</span></span><br><span class="line"><span class="attr">  lastName:</span> <span class="string">zhangsan</span></span><br><span class="line"><span class="attr">  age:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>行内写法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">friends:</span> <span class="string">&#123;lastName:</span> <span class="string">zhangsan,</span> <span class="attr">age:</span> <span class="number">18</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><pre><code>（List、Set）</code></pre><p>用-值表示数组中的一个元素</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pets:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">cat</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">dog</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">pig</span></span><br></pre></td></tr></table></figure><p>行内写法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pets:</span> <span class="string">[cat,</span> <span class="string">dog,</span> <span class="string">pig]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;配置文件详解&quot;&gt;&lt;a href=&quot;#配置文件详解&quot; class=&quot;headerlink&quot; title=&quot;配置文件详解&quot;&gt;&lt;/a&gt;配置文件详解&lt;/h1&gt;&lt;h2 id=&quot;YML是什么&quot;&gt;&lt;a href=&quot;#YML是什么&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="Java" scheme="https://kepler-ecnu.github.io/categories/Java/"/>
    
      <category term="Spring" scheme="https://kepler-ecnu.github.io/categories/Java/Spring/"/>
    
      <category term="Spring Boot" scheme="https://kepler-ecnu.github.io/categories/Java/Spring/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="https://kepler-ecnu.github.io/tags/Spring-Boot/"/>
    
      <category term="Java" scheme="https://kepler-ecnu.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-06</title>
    <link href="https://kepler-ecnu.github.io/2019/08/14/SpringBoot-06/"/>
    <id>https://kepler-ecnu.github.io/2019/08/14/SpringBoot-06/</id>
    <published>2019-08-14T13:11:22.000Z</published>
    <updated>2019-08-14T13:50:05.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="配置文件的使用"><a href="#配置文件的使用" class="headerlink" title="配置文件的使用"></a>配置文件的使用</h1><h2 id="修改配置方式"><a href="#修改配置方式" class="headerlink" title="修改配置方式"></a>修改配置方式</h2><ul><li>修改配置方式1：<strong>src\main\resources\application.properties</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#修改端口号</span><br><span class="line">server.port=8081</span><br><span class="line">#端口号后需额外添加字符</span><br><span class="line">server.servlet.context-path=/kepler</span><br></pre></td></tr></table></figure></li></ul><p>如访问：<a href="http://localhost:8081/kepler/user" target="_blank" rel="noopener">http://localhost:8081/kepler/user</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HelloWorld!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修改配置方式2：src\main\resources\application.yml<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">  servlet:</span></span><br><span class="line"><span class="attr">    context-path:</span> <span class="string">/kepler</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="切换配置文件"><a href="#切换配置文件" class="headerlink" title="切换配置文件"></a>切换配置文件</h2><h3 id="多配置文件"><a href="#多配置文件" class="headerlink" title="多配置文件"></a>多配置文件</h3><ul><li><p>src\main\resources\application-dev.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure></li><li><p>src\main\resources\application-prod.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></li><li><p>src\main\resources\application.yml<br>根据active:来切换配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span></span><br><span class="line"><span class="attr">    active:</span> <span class="string">prod</span></span><br><span class="line"><span class="string">或</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span></span><br><span class="line"><span class="attr">    active:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="单配置文件（分块）"><a href="#单配置文件（分块）" class="headerlink" title="单配置文件（分块）"></a>单配置文件（分块）</h3><ul><li>在单一文件中，可以用连续三个连字号（-）区分多个文件</li><li>根据active：来切换配置文件<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">prod</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">dev</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span></span><br><span class="line"><span class="attr">    active:</span> <span class="string">prod</span> <span class="string">或</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="激活指定profile"><a href="#激活指定profile" class="headerlink" title="激活指定profile"></a>激活指定profile</h2><ul><li>在配置文件中指定spring.profiles.active=dev</li><li>命令行： java -jar xxxx.jar –spring.profiles.active=dev<br>可以直接在测试的时候，配置传入命令行参数</li><li>虚拟机参数，在IDEA或Eclipse中的run configuration中可以进行配置<br>  -Dspring.profiles.active=dev</li></ul><h2 id="配置文件加载位置"><a href="#配置文件加载位置" class="headerlink" title="配置文件加载位置"></a>配置文件加载位置</h2><p>springboot 启动后扫描以下位置的application.properties或者application.yml文件，<br>作为Spring boot的默认配置文件</p><table><thead><tr><th>位置</th><th>说明</th></tr></thead><tbody><tr><td>–file:./config/</td><td>项目目录下的config</td></tr><tr><td>–file:./</td><td>项目目录下</td></tr><tr><td>–classpath:/config/</td><td>resources目录下的config</td></tr><tr><td>–classpath:/</td><td>resources目录下</td></tr></tbody></table><p>优先级由高到底，高优先级的配置会覆盖低优先级的配置；</p><p>SpringBoot会从这四个位置全部加载主配置文件；<strong>互补配置</strong>；</p><p>我们还可以通过spring.config.location来改变默认的配置文件位置</p><p><strong>项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置</strong>；</p><p><strong>指定配置文件和默认加载的这些配置文件共同起作用形成互补配置</strong>；</p><p>java -jar xxx.jar -–spring.config.location=E:/application.yml</p><p>从spring的运行日志中可以看到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Loaded config file <span class="string">'file:./config/application.yml'</span> (file:./config/application.yml)</span><br><span class="line">Loaded config file <span class="string">'file:./application.yml'</span> (file:./application.yml)</span><br><span class="line">Loaded config file <span class="string">'file:/C:/Users/Administrator/Desktop/demo3/target/classes/config/application.yml'</span> (classpath:/config/application.yml)</span><br><span class="line">Loaded config file <span class="string">'file:/C:/Users/Administrator/Desktop/demo3/target/classes/application.yml'</span> (classpath:/application.yml)</span><br></pre></td></tr></table></figure><p>配置文件的加载顺序：</p><ul><li>./config/application.yml 项目目录下的config目录下的配置文件</li><li>./application.yml 项目目录下的配置文件</li><li>classpath:/config/application.yml 资源路径下的config 目录下的配置文件</li><li>classpath:/application.yml 资源路径下的配配置文件</li></ul><p><strong>总结</strong>:</p><ul><li>先加载的优先级最高，后面的优先级低。</li><li>后面的配置文件中如果有不同的配置项，也会读取进来。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;配置文件的使用&quot;&gt;&lt;a href=&quot;#配置文件的使用&quot; class=&quot;headerlink&quot; title=&quot;配置文件的使用&quot;&gt;&lt;/a&gt;配置文件的使用&lt;/h1&gt;&lt;h2 id=&quot;修改配置方式&quot;&gt;&lt;a href=&quot;#修改配置方式&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="Java" scheme="https://kepler-ecnu.github.io/categories/Java/"/>
    
      <category term="Spring" scheme="https://kepler-ecnu.github.io/categories/Java/Spring/"/>
    
      <category term="Spring Boot" scheme="https://kepler-ecnu.github.io/categories/Java/Spring/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="https://kepler-ecnu.github.io/tags/Spring-Boot/"/>
    
      <category term="Java" scheme="https://kepler-ecnu.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-05</title>
    <link href="https://kepler-ecnu.github.io/2019/08/14/SpringBoot-05/"/>
    <id>https://kepler-ecnu.github.io/2019/08/14/SpringBoot-05/</id>
    <published>2019-08-14T11:06:23.000Z</published>
    <updated>2019-08-14T13:52:24.508Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SwaggerAPI框架"><a href="#SwaggerAPI框架" class="headerlink" title="SwaggerAPI框架"></a>SwaggerAPI框架</h1><p>为了方便上面的API接口调试，我们可以使用：</p><ul><li>Postman：模拟POST请求</li><li>SWAgger：描述和测试API接口</li></ul><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Swagger配置"><a href="#Swagger配置" class="headerlink" title="Swagger配置"></a>Swagger配置</h2><p>yml配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">swagger:</span><br><span class="line">  title: SpringBoot学习</span><br><span class="line">  description: SpringBoot入门</span><br><span class="line">  version: <span class="number">1.0</span>.0</span><br><span class="line">  name: ailee</span><br><span class="line">  url: https:<span class="comment">//kepler-ecnu.github.io</span></span><br><span class="line">  email: <span class="number">1519535214</span><span class="meta">@qq</span>.com</span><br></pre></td></tr></table></figure><p>Swagger配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.config;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.EnableWebMvc;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.Contact;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 必须存在</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span> <span class="comment">// 必须存在</span></span><br><span class="line"><span class="meta">@EnableSwagger</span>2 <span class="comment">// 必须存在</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"swagger"</span>) <span class="comment">// swagger 与 yml 文件中一致</span></span><br><span class="line"><span class="meta">@Data</span> <span class="comment">// lombok</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"com.example.demo.controller"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">customDocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket( DocumentationType.SWAGGER_2).apiInfo(apiInfo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Contact contact = <span class="keyword">new</span> Contact(name, url, email);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                .title(title)</span><br><span class="line">                .description(description)</span><br><span class="line">                .contact(contact)</span><br><span class="line">                .version(version)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件中的值到配置类中的注入，在第八章springboot-08-配置文件的注入中有介绍</p><p>MVC配置</p><ul><li>作用：过滤网页静态资源<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">"swagger-ui.html"</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">"classpath:/META-INF/resources/"</span>);</span><br><span class="line"></span><br><span class="line">        registry.addResourceHandler(<span class="string">"/webjars/**"</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">"classpath:/META-INF/resources/webjars/"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>Swagger的具体用法，可以学习<a href="https://www.bilibili.com/video/av37961314/" target="_blank" rel="noopener">B站Swagger视频</a></p><h2 id="Webjars的使用"><a href="#Webjars的使用" class="headerlink" title="Webjars的使用"></a>Webjars的使用</h2><p>官网：<a href="https://www.webjars.org/" target="_blank" rel="noopener">https://www.webjars.org/</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jquery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.1-1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过jar包的方式引入了jQuery<br>在浏览器中可以通过如下地址访问到，<a href="http://localhost:8080/webjars/jquery/3.4.1/jquery.js" target="_blank" rel="noopener">http://localhost:8080/webjars/jquery/3.4.1/jquery.js</a></p><p>地址说明：/webjars/jquery/3.4.1/jquery.js</p><p>对应上面的 webjars/ artifactId/version/文件名</p><p>可以到项目中的jar包中具体查看。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SwaggerAPI框架&quot;&gt;&lt;a href=&quot;#SwaggerAPI框架&quot; class=&quot;headerlink&quot; title=&quot;SwaggerAPI框架&quot;&gt;&lt;/a&gt;SwaggerAPI框架&lt;/h1&gt;&lt;p&gt;为了方便上面的API接口调试，我们可以使用：&lt;/p&gt;
&lt;ul
      
    
    </summary>
    
      <category term="Java" scheme="https://kepler-ecnu.github.io/categories/Java/"/>
    
      <category term="Spring" scheme="https://kepler-ecnu.github.io/categories/Java/Spring/"/>
    
      <category term="Spring Boot" scheme="https://kepler-ecnu.github.io/categories/Java/Spring/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="https://kepler-ecnu.github.io/tags/Spring-Boot/"/>
    
      <category term="Java" scheme="https://kepler-ecnu.github.io/tags/Java/"/>
    
      <category term="api" scheme="https://kepler-ecnu.github.io/tags/api/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-04</title>
    <link href="https://kepler-ecnu.github.io/2019/08/14/SpringBoot-04/"/>
    <id>https://kepler-ecnu.github.io/2019/08/14/SpringBoot-04/</id>
    <published>2019-08-14T07:45:44.000Z</published>
    <updated>2019-08-14T11:03:38.056Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h1><p>参数传递可以说是服务端和外界沟通的主要方式，这是非常重要的!<br>本节内容包括：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">通过url传参</span><br><span class="line">    |---get方式Url传参</span><br><span class="line">        |---<span class="meta">@PathVariable</span> 即：url/id/<span class="number">1994</span> 形式</span><br><span class="line">        |---<span class="meta">@RequestParam</span> 即：url?username=zed形式</span><br><span class="line">    |---POST方式传参</span><br><span class="line">        |---<span class="meta">@RequestParam</span></span><br><span class="line">        |---请求体中加入文本</span><br><span class="line">配置文件传参</span><br></pre></td></tr></table></figure><h2 id="get方式URL传参"><a href="#get方式URL传参" class="headerlink" title="get方式URL传参"></a>get方式URL传参</h2><p><strong>@PathVariable</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@PathVariable(<span class="string">"name"</span>)</span> String name)</span>&#123;</span><br><span class="line">        <span class="comment">// 形参的name可以随意</span></span><br><span class="line">        System.out.println(<span class="string">"获取到的name是："</span>+name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello "</span>+name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>访问： <a href="http://localhost:8080/hello/xxxxx" target="_blank" rel="noopener">http://localhost:8080/hello/xxxxx</a></li></ul><p><strong>@RequestParm</strong><br>如果请求参数的名字跟方法中的形参名字一致可以省略@RequestParam(“name”)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span> String name)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"获取到的name是："</span>+name);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello "</span>+name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">( String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + name;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>访问：<a href="http://localhost:8080/user?name=xxxx" target="_blank" rel="noopener">http://localhost:8080/user?name=xxxx</a></li></ul><p><strong>@RequestParm + 默认参数</strong><br>如果请求参数的名字跟方法中的形参名字一致可以省略@RequestParam(“name”)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam(value = <span class="string">"name"</span>,defaultValue = <span class="string">"admin"</span>)</span> String name)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"获取到的name是："</span>+name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello "</span>+name;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>访问：<a href="http://localhost:8080/user?name=xxxx" target="_blank" rel="noopener">http://localhost:8080/user?name=xxxx</a><br>注意：如果没有指定默认值，并且没有传递参数将会报错<br><code>Required String parameter &#39;name&#39; is not present</code> :name参数没有提供</li><li>解决方案<br>  1.defaultValue = “xxx” ：使用默认值<br>  2.required = false ：标注参数是非必须的<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam(value = <span class="string">"name"</span>,required = <span class="keyword">false</span>)</span> String name)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"获取到的name是："</span>+name);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello "</span>+name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="POST方式传递数据"><a href="#POST方式传递数据" class="headerlink" title="POST方式传递数据"></a>POST方式传递数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(HelloController.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span> String name,@<span class="title">RequestParam</span><span class="params">(<span class="string">"age"</span>)</span> Integer age)</span>&#123;</span><br><span class="line">        log.info(name+<span class="string">"  "</span>+age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name:"</span>+name+<span class="string">"\nage:"</span>+age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>post不能用浏览器直接访问，这里用Postman测试：<br><img src="/images/postman_post.png" alt="Postman测试截图"></p><h2 id="POST传递字符串文本"><a href="#POST传递字符串文本" class="headerlink" title="POST传递字符串文本"></a>POST传递字符串文本</h2><p>通过HttpSerletRequest获取输入流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/PostString"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">postString</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    ServletInputStream is = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        is = request.getInputStream();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            sb.append(<span class="keyword">new</span> String(buf, <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="keyword">null</span>) &#123;</span><br><span class="line">                is.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用Postman测试：<br><img src="/images/postman_text.png" alt="Postman测试截图"></p><h2 id="RequestBody接收参数"><a href="#RequestBody接收参数" class="headerlink" title="@RequestBody接收参数"></a>@RequestBody接收参数</h2><ul><li>@RequestBody可以接收GET或POST请求中的参数</li><li>把json作为参数传递，要用 RequestBody</li><li>附带说一下使用postman方式设置content-type为application/json方式测试后台接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/save"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">save</span><span class="params">(@RequestBody User user)</span></span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;String,Object&gt; ();</span><br><span class="line">    map.put(<span class="string">"user"</span>,user);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">user</span><span class="params">(@RequestBody User user)</span></span>&#123;</span><br><span class="line">    log.info(user.toString());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/postman_requestbody.png" alt="postman requestbody示例"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;参数传递&quot;&gt;&lt;a href=&quot;#参数传递&quot; class=&quot;headerlink&quot; title=&quot;参数传递&quot;&gt;&lt;/a&gt;参数传递&lt;/h1&gt;&lt;p&gt;参数传递可以说是服务端和外界沟通的主要方式，这是非常重要的!&lt;br&gt;本节内容包括：&lt;/p&gt;
&lt;figure class=&quot;h
      
    
    </summary>
    
      <category term="Java" scheme="https://kepler-ecnu.github.io/categories/Java/"/>
    
      <category term="Spring" scheme="https://kepler-ecnu.github.io/categories/Java/Spring/"/>
    
      <category term="Spring Boot" scheme="https://kepler-ecnu.github.io/categories/Java/Spring/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="https://kepler-ecnu.github.io/tags/Spring-Boot/"/>
    
      <category term="Java" scheme="https://kepler-ecnu.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-03</title>
    <link href="https://kepler-ecnu.github.io/2019/08/14/SpringBoot-03/"/>
    <id>https://kepler-ecnu.github.io/2019/08/14/SpringBoot-03/</id>
    <published>2019-08-14T03:46:33.000Z</published>
    <updated>2019-08-14T07:43:47.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="POM-文件"><a href="#POM-文件" class="headerlink" title="POM 文件"></a>POM 文件</h2><ul><li><p>父项目</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  它的父项目是</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../../spring-boot-dependencies<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>这是真正管理Spring Boot应用里面所依赖的版本<br>Spring Boot的版本仲裁中心；<br>以后我们导入依赖默认是不需要写版本；<br>（没有在dependencies里面管理的依赖自然需要声明版本号）</p><h2 id="启动器"><a href="#启动器" class="headerlink" title="启动器"></a>启动器</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>spring-boot-starter-web：</strong><br>spring-boot-starter：spring-boot场景启动器，帮我们导入了web模块正常运行所依赖的组件；<br>点击进去可以看到帮我们引入很多web相关的依赖<br>Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来，要用什么功能就导入什么场景的启动器</p><h2 id="主程序类，主入口类"><a href="#主程序类，主入口类" class="headerlink" title="主程序类，主入口类"></a>主程序类，主入口类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@SpringBootApplication</strong> : Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">      <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line">      <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br></pre></td></tr></table></figure><ul><li>@SpringBootConfiguration : Spring Boot的配置类，标注在某个类上，表示这是一个Spring Boot的配置类</li><li>@Configuration : 配置类上来标注这个注解，配置类也是容器中的一个组件@Component</li><li>@EnableAutoConfiguration：开启自动配置功能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(EnableAutoConfigurationImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br></pre></td></tr></table></figure><ul><li>将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；</li><li>调用了<code>SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)</code>；</li><li>Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；</li><li>以前我们需要自己配置的东西，自动配置类都帮我们；</li><li>有了自动配置类，免去了我们手动编写配置注入功能组件等的工作；</li><li>J2EE的整体整合解决方案和自动配置都在<code>spring-boot-autoconfigure-1.5.9.RELEASE.jar</code>；</li></ul><h2 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h2><ul><li>SpringBoot启动的时候加载主配置类，开启了自动配置功能 @EnableAutoConfiguration</li><li><strong>@EnableAutoConfiguration</strong> 作用：<br>  利用EnableAutoConfigurationImportSelector给容器中导入一些组件<br>  可以查看selectImports()方法的内容；<br>  <code>List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes)</code>;获取候选的配置<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SpringFactoriesLoader.loadFactoryNames()</span><br><span class="line">扫描所有jar包类路径下  META-INF/spring.factories</span><br><span class="line">把扫描到的这些文件的内容包装成properties对象</span><br><span class="line">从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中</span><br></pre></td></tr></table></figure></code></pre></li></ul><p>将类路径下 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中</p><p><strong>精髓</strong>：<br>​ 1） SpringBoot启动会加载大量的自动配置类<br>​ 2） 我们看我们需要的功能有没有SpringBoot默认写好的自动配置类；<br>​ 3） 我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）<br>​ 4） 给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xxxxAutoConfigurartion：自动配置类(给容器中添加组件)；</span><br><span class="line">xxxxProperties:封装配置文件中相关属性；</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;h2 id=&quot;POM-文件&quot;&gt;&lt;a href=&quot;#POM-文件&quot; class=&quot;headerlink&quot; title=&quot;POM 文件&quot;&gt;&lt;/a&gt;P
      
    
    </summary>
    
      <category term="Java" scheme="https://kepler-ecnu.github.io/categories/Java/"/>
    
      <category term="Spring" scheme="https://kepler-ecnu.github.io/categories/Java/Spring/"/>
    
      <category term="Spring Boot" scheme="https://kepler-ecnu.github.io/categories/Java/Spring/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="https://kepler-ecnu.github.io/tags/Spring-Boot/"/>
    
      <category term="Java" scheme="https://kepler-ecnu.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-02</title>
    <link href="https://kepler-ecnu.github.io/2019/08/14/SpringBoot-02/"/>
    <id>https://kepler-ecnu.github.io/2019/08/14/SpringBoot-02/</id>
    <published>2019-08-14T03:19:09.000Z</published>
    <updated>2019-08-14T03:30:30.917Z</updated>
    
    <content type="html"><![CDATA[<h1 id="再体验"><a href="#再体验" class="headerlink" title="再体验"></a>再体验</h1><h2 id="URL其他形式"><a href="#URL其他形式" class="headerlink" title="URL其他形式"></a>URL其他形式</h2><p>-窄化请求<br>    url的其他形式：类和方法都有value时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 窄化请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello SpringBoot"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>配置多url对1映射<br>  访问：<a href="http://localhost:8080/hello" target="_blank" rel="noopener">http://localhost:8080/hello</a> 或 <a href="http://localhost:8080/hi" target="_blank" rel="noopener">http://localhost:8080/hi</a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(value = &#123;<span class="string">"/hello"</span>,<span class="string">"/hi"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello SpringBoot"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="其他创建方式"><a href="#其他创建方式" class="headerlink" title="其他创建方式"></a>其他创建方式</h2><ul><li>Spring Initializr：通过IDEA或者其他工具创建Initializr项目</li><li>创建Maven项目手动添加依赖</li><li>通过<a href="https://start.spring.io/" target="_blank" rel="noopener">https://start.spring.io/</a> 生成定制项目</li></ul><h2 id="其他运行方式"><a href="#其他运行方式" class="headerlink" title="其他运行方式"></a>其他运行方式</h2><ul><li>在IDE中直接运行</li><li>发布Jar包运行</li></ul><p>在pom/xml文件引用插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>导入这个maven插件，利用idea打包，生成的jar包，可以使用<code>java -jar xxx.jar</code>启动</p><p>Spring Boot 使用嵌入式的Tomcat无需再配置Tomcat</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;再体验&quot;&gt;&lt;a href=&quot;#再体验&quot; class=&quot;headerlink&quot; title=&quot;再体验&quot;&gt;&lt;/a&gt;再体验&lt;/h1&gt;&lt;h2 id=&quot;URL其他形式&quot;&gt;&lt;a href=&quot;#URL其他形式&quot; class=&quot;headerlink&quot; title=&quot;URL其他形式
      
    
    </summary>
    
      <category term="Java" scheme="https://kepler-ecnu.github.io/categories/Java/"/>
    
      <category term="Spring" scheme="https://kepler-ecnu.github.io/categories/Java/Spring/"/>
    
      <category term="Spring Boot" scheme="https://kepler-ecnu.github.io/categories/Java/Spring/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="https://kepler-ecnu.github.io/tags/Spring-Boot/"/>
    
      <category term="Java" scheme="https://kepler-ecnu.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-01</title>
    <link href="https://kepler-ecnu.github.io/2019/08/13/SpringBoot-01/"/>
    <id>https://kepler-ecnu.github.io/2019/08/13/SpringBoot-01/</id>
    <published>2019-08-13T14:55:53.000Z</published>
    <updated>2019-08-13T15:21:40.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初体验"><a href="#初体验" class="headerlink" title="初体验"></a>初体验</h1><h2 id="使用IDEA创建一个项目"><a href="#使用IDEA创建一个项目" class="headerlink" title="使用IDEA创建一个项目"></a>使用IDEA创建一个项目</h2><ul><li>目录结构说明<br>  src/main/java: Java代码的目录<br>  src/main/resources: 资源目录<br>  src/test/java: 测试代码的目录<br>  src/test/resources: 测试资源目录</li><li>POM文件说明</li></ul><h2 id="添加Banner文件"><a href="#添加Banner文件" class="headerlink" title="添加Banner文件"></a>添加Banner文件</h2><p>在resources目录下创建banner.txt文件，添加以下内容<br>可以更换成你自己的banner</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$&#123;AnsiColor.BLUE&#125;</span><br><span class="line"></span><br><span class="line">  _              _           </span><br><span class="line"> | | _____ _ __ | | ___ _ __ </span><br><span class="line"> | |/ / _ \ &apos;_ \| |/ _ \ &apos;__|</span><br><span class="line"> |   &lt;  __/ |_) | |  __/ |   </span><br><span class="line"> |_|\_\___| .__/|_|\___|_|   </span><br><span class="line">          |_|                </span><br><span class="line"></span><br><span class="line">-----版本号-----$&#123;spring-boot.version&#125;</span><br></pre></td></tr></table></figure><h2 id="创建Controller类"><a href="#创建Controller类" class="headerlink" title="创建Controller类"></a>创建Controller类</h2><ul><li><p>文件模板修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello SpringBoot"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>注解方式还有一种，和上面的效果一样</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更多注解方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello SpringBoot"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>注解说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span>: 处理http请求:等同于<span class="meta">@Controller</span>+<span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>: value = <span class="string">"访问的路由"</span> method = 请求方法</span><br><span class="line"><span class="meta">@GetMapping</span>：以GET方式请求 相当于对<span class="meta">@RequestMapping</span>配置的缩写</span><br></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>执行main方法<br>访问:<a href="http://localhost:8080/hello" target="_blank" rel="noopener">http://localhost:8080/hello</a></p><p>主程序说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Spring应用启动起来</span></span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;初体验&quot;&gt;&lt;a href=&quot;#初体验&quot; class=&quot;headerlink&quot; title=&quot;初体验&quot;&gt;&lt;/a&gt;初体验&lt;/h1&gt;&lt;h2 id=&quot;使用IDEA创建一个项目&quot;&gt;&lt;a href=&quot;#使用IDEA创建一个项目&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="Java" scheme="https://kepler-ecnu.github.io/categories/Java/"/>
    
      <category term="Spring" scheme="https://kepler-ecnu.github.io/categories/Java/Spring/"/>
    
      <category term="Spring Boot" scheme="https://kepler-ecnu.github.io/categories/Java/Spring/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="https://kepler-ecnu.github.io/tags/Spring-Boot/"/>
    
      <category term="Java" scheme="https://kepler-ecnu.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-00</title>
    <link href="https://kepler-ecnu.github.io/2019/08/13/SpringBoot-00/"/>
    <id>https://kepler-ecnu.github.io/2019/08/13/SpringBoot-00/</id>
    <published>2019-08-13T14:00:26.000Z</published>
    <updated>2019-08-13T14:50:26.205Z</updated>
    
    <content type="html"><![CDATA[<p>这部分内容学习和摘录于B站<a href="https://www.bilibili.com/video/av39775932" target="_blank" rel="noopener">稀客大大</a></p><h2 id="Spring-Boot-简介"><a href="#Spring-Boot-简介" class="headerlink" title="Spring Boot 简介"></a>Spring Boot 简介</h2><ul><li>简化Spring应用开发的一个框架</li><li>整个Spring技术栈的一个大整合</li><li>J2EE开发的一站式解决方案</li></ul><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><ul><li>架构风格（服务微化）</li><li>一个应用应该是一组小型服务；可以通过HTTP的方法进行互通</li><li>单体应用： ALL IN ONE</li><li>每一个功能元素最终都是一个可独立替换和独立升级的软件单元</li></ul><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul><li>环境约束<br>  jdk 1.8+<br>  maven 3.3+<br>  A favorite text editor or IDE: Intellij IDEA<br>  SpringBoot </li></ul><h2 id="Maven配置"><a href="#Maven配置" class="headerlink" title="Maven配置"></a>Maven配置</h2><p>进入maven文件目录，给<code>M2_HOME\conf\settings.xml</code>配置文件添加如下内容：</p><ul><li><p>在<code>&lt;mirrors&gt;</code>和<code>&lt;/mirrors&gt;</code>之间添加如下内容</p></li><li><p>作用：国内maven仓库镜像（国内不能很好的访问maven中央仓库）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>        </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在<code>&lt;profiles&gt;</code>和<code>&lt;/profiles&gt;</code></p></li><li><p>作用：指定项目编译运行使用的JDK版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果是在学校或公司有maven私服，可以在这里配置私服 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>accp<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>accp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.1.48:8081/repository/accp/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果没有私服，这里不用配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="IDEA配置"><a href="#IDEA配置" class="headerlink" title="IDEA配置"></a>IDEA配置</h2><p>整合Maven进来</p><h2 id="修改Banner"><a href="#修改Banner" class="headerlink" title="修改Banner"></a>修改Banner</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$&#123;AnsiColor.BLUE&#125;</span><br><span class="line"></span><br><span class="line">  _              _           </span><br><span class="line"> | | _____ _ __ | | ___ _ __ </span><br><span class="line"> | |/ / _ \ &apos;_ \| |/ _ \ &apos;__|</span><br><span class="line"> |   &lt;  __/ |_) | |  __/ |   </span><br><span class="line"> |_|\_\___| .__/|_|\___|_|   </span><br><span class="line">          |_|                </span><br><span class="line"></span><br><span class="line">-----版本号-----$&#123;spring-boot.version&#125;</span><br></pre></td></tr></table></figure><p>文字Banner可以从这个网站生成(有很多种字体样式可以选择)<br><a href="http://patorjk.com/software/taag" target="_blank" rel="noopener">http://patorjk.com/software/taag</a><br>${AnsiColor.BLUE} 表示Banner文字的颜色<br>${spring-boot.version} 当前使用的SpringBoot版本</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这部分内容学习和摘录于B站&lt;a href=&quot;https://www.bilibili.com/video/av39775932&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;稀客大大&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Spring-Boot-简介&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="Java" scheme="https://kepler-ecnu.github.io/categories/Java/"/>
    
      <category term="Spring" scheme="https://kepler-ecnu.github.io/categories/Java/Spring/"/>
    
      <category term="Spring Boot" scheme="https://kepler-ecnu.github.io/categories/Java/Spring/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="https://kepler-ecnu.github.io/tags/Spring-Boot/"/>
    
      <category term="Java" scheme="https://kepler-ecnu.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java数据库篇</title>
    <link href="https://kepler-ecnu.github.io/2019/08/12/Java%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87/"/>
    <id>https://kepler-ecnu.github.io/2019/08/12/Java数据库篇/</id>
    <published>2019-08-12T04:47:03.000Z</published>
    <updated>2019-08-30T08:47:17.329Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="主键-超键-候选键-外键"><a href="#主键-超键-候选键-外键" class="headerlink" title="主键 超键 候选键 外键"></a>主键 超键 候选键 外键</h2><ul><li>主键<br>数据库表中存储数据对象允以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）</li><li>超键<br>在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</li><li>候选键<br>是最小超键，即没有冗余元素的超键</li><li>外键<br>在一个表中存在的另一个表的主键称为此表的外键</li></ul><p>假设有如下两个表：<br>学生（学号，姓名，性别，身份证号，教师编号）<br>教师（教师编号，姓名，工资）</p><p>超键：<br>由超键的定义可知，学生表中含有学号或者身份证号的任意组合都为此表的超键。如：（学号）、（学号，姓名）、（身份证号，性别）等。</p><p>候选键：<br>候选键属于超键，它是最小的超键，就是说如果再去掉候选键中的任何一个属性它就不再是超键了。学生表中的候选键为：（学号）、（身份证号）。</p><p>主键：<br>主键就是候选键里面的一个，是人为规定的，例如学生表中，我们通常会让“学号”做主键，教师表中让“教师编号”做主键。</p><p>外键：<br>外键比较简单，学生表中的外键就是“教师编号”。外键主要是用来描述两个表的关系。</p><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>百度百科中解释：指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。<br>简单的说，事务就是<strong>并发控制</strong>的单位，是用户定义的一个操作序列。</p><h2 id="什么是锁"><a href="#什么是锁" class="headerlink" title="什么是锁"></a>什么是锁</h2><p>锁（LOCKING）是最常用的并发控制机构。是防止其他事务访问指定的资源控制、实现并发控制的一种主要手段。锁是事务对某个数据库中的资源（如表和记录）存取前，先向系统提出请求，封锁该资源，事务获得锁后，即取得对数据的控制权，在事务释放它的锁之前，其他事务不能更新此数据。当事务撤消后，释放被锁定的资源。<br>当一个用户锁住数据库中的某个对象时，其他用户就不能再访问该对象</p><p>在所有的数据库管理系统（DBMS）中，锁是实现事务的关键，锁可以保证事务的完整性和并发性。与现实生活中锁一样，它可以使某些数据的拥有者，在某段时间内不能使用某些数据或数据结构。</p><h2 id="说一下-MySQL-常用的引擎"><a href="#说一下-MySQL-常用的引擎" class="headerlink" title="说一下 MySQL 常用的引擎"></a>说一下 MySQL 常用的引擎</h2><ol><li>MyISAM：默认表类型，它是基于传统的ISAM类型，ISAM是Indexed Sequential Access Method (有索引的顺序访问方法) 的缩写，它是存储记录和文件的标准方法。不是事务安全的，而且不支持外键，如果执行大量的select，insert MyISAM比较适合。<br>不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和  InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table  语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM  作为数据库引擎的首选。</li><li>InnoDB：支持事务安全的引擎，支持外键、行锁、事务是他的最大特点。如果有大量的update和insert，建议使用InnoDB，特别是针对多个并发和QPS较高的情况。<br>默认引擎，InnoDB 引擎提供了对数据库 acid  事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB  会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select  count(*) from table  指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</li></ol><h2 id="说一下-MySQL-的行锁和表锁"><a href="#说一下-MySQL-的行锁和表锁" class="headerlink" title="说一下 MySQL 的行锁和表锁"></a>说一下 MySQL 的行锁和表锁</h2><p>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。</p><ul><li>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。</li><li>行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。</li></ul><h2 id="说一下乐观锁和悲观锁"><a href="#说一下乐观锁和悲观锁" class="headerlink" title="说一下乐观锁和悲观锁"></a>说一下乐观锁和悲观锁</h2><ul><li>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。</li><li>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。</li></ul><p>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</p><h2 id="数据库事务的四个特性及含义"><a href="#数据库事务的四个特性及含义" class="headerlink" title="数据库事务的四个特性及含义"></a>数据库事务的四个特性及含义</h2><p>一个逻辑工作单元要成为事务，就必须满足ACID属性<br>A：原子性（Atomicity）<br>    事务中的操作要么都不做，要么就全做<br>C：一致性（Consistency）<br>    事务执行的结果必须是从数据库从一个一致性状态转换到另一个一致性状态。<br>I：隔离性（Isolation）<br>    一个事务的执行不能被其他事务干扰<br>D：持久性（Durability）<br>    一个事务一旦提交，它对数据库中数据的改变就应该是永久性的</p><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><ol><li>读未提交（Read Uncommitted)<br> 引发脏读（读取了未提交的数据）</li><li>读已提交（Read Committed)<br> 这是大多数数据库系统默认的隔离级别，但不是MySQL默认的<br> 只能看见已经提交事务所做的改变<br> 引发不可重复读，不可重读读意味着我们同一事务执行完全相同的select语句时可能看到不一样的结果。<br>导致这种情况的原因可能有：<pre><code>(1)有一个交叉的事务有新的commit，导致了数据的改变;(2)一个数据库被多个实例操作时,同一事务的其他实例在该实例处理其间可能会有新的commit,多个commit提交时，只读一次出现结果不一致</code></pre></li></ol><ol start="3"><li>可重复读（Repeatable Read）<br> 这是MySQL的默认事务隔离级别<br> 它确保同一事务的多个实例在并发读取数据时，看到同样的数据行<br> 此级别可能出现的问题–幻读（Phantom Read），当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行<br> InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决了该问题</li><li>可串行化（Serializable）<br> 这是最高的隔离级别<br> 它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它在每个读的数据行上加上共享锁。<br> 可能导致大量的超时现象和锁竞争<table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交</td><td>√</td><td>√</td><td>√</td></tr><tr><td>读已提交</td><td>×</td><td>√</td><td>√</td></tr><tr><td>可重复读</td><td>×</td><td>×</td><td>√</td></tr><tr><td>可串行化</td><td>×</td><td>×</td><td>×</td></tr></tbody></table></li></ol><h2 id="事务运行的三种模式"><a href="#事务运行的三种模式" class="headerlink" title="事务运行的三种模式"></a>事务运行的三种模式</h2><ol><li>自动提交事务<br> 每条单独的语句都是一个事务，每个语句都隐含一个commit</li><li>显式事务<br> 以begin transaction 开始，以commit 或 rollback 结束。</li><li>隐性事务<br> 在前一个事务完成时，新事务隐式启动，但每个事务仍以commit或rollback显示结束</li></ol><p>注意：<font color="#0099ff">隔离级别的设置只对当前链接有效</font>。对于使用MySQL命令窗口而言，一个窗口就相当于一个链接，当前窗口设置的隔离级别只对当前窗口中的事务有效；对于JDBC操作数据库来说，一个Connection对象相当于一个链接，而对于Connection对象设置的隔离级别只对该Connection对象有效，与其他链接Connection对象无关。</p><p>事务通常以begin（start） transaction 开始，以commit 或 rollback 结束。<br>commit 表示提交，将事务中所有对数据库的更新写会到磁盘的物理数据库中，事务正常结束。<br>rollback表示回滚，即在事务运行的过程中发生了某种故障，事务不能继续进行，系统将事务中对数据库的所有以完成的操作全部撤消，滚回到事务开始的状态。</p><h2 id="视图的作用，视图可以更改么"><a href="#视图的作用，视图可以更改么" class="headerlink" title="视图的作用，视图可以更改么"></a>视图的作用，视图可以更改么</h2><p>视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询；不包含任何列或数据。使用视图可以简化复杂的sql操作，隐藏具体的细节，保护数据；视图创建后，可以使用与表相同的方式利用它们。<br>视图不能被索引，也不能有关联的触发器或默认值，如果视图本身内有order by 则对视图再次order by将被覆盖。<br>create view 视图名 as 查询语句;<br>对于某些视图比如未使用联结子查询分组聚集函数Distinct Union等，是可以对其更新的，对视图的更新将对基表进行更新；但是视图主要用于简化检索，保护数据，并不用于更新，而且大部分视图都不可以更新。</p><h2 id="游标是什么"><a href="#游标是什么" class="headerlink" title="游标是什么"></a>游标是什么</h2><p>游标：是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。</p><h2 id="视图的优缺点"><a href="#视图的优缺点" class="headerlink" title="视图的优缺点"></a>视图的优缺点</h2><p>优点：<br>    1. 对数据库的访问，因为视图可以有选择性的选取数据库里的一部分。<br>    2. 用户通过简单的查询可以从复杂查询中得到结果。<br>    3. 维护数据的独立性，视图可从多个表检索数据。<br>    4. 对于相同的数据可产生不同的视图。<br>缺点：查询视图时，必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么就无法更改数据</p><h2 id="列举几种表连接方式-有什么区别"><a href="#列举几种表连接方式-有什么区别" class="headerlink" title="列举几种表连接方式,有什么区别"></a>列举几种表连接方式,有什么区别</h2><p>内连接、自连接、外连接（左、右、全）、交叉连接</p><ul><li>内连接：只有两个元素表相匹配的才能在结果集中显示。</li><li>自连接：自连接(self join)是SQL语句中经常要用的连接方式，使用自连接可以将自身表的一个镜像当作另一个表来对待，从而能够得到一些特殊的数据。</li><li>外连接：<br>  左外连接: 左边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。<br>  右外连接: 右边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。<br>  全外连接：连接的表中不匹配的数据全部会显示出来。</li><li>交叉连接：笛卡尔效应，显示的结果是链接表数的乘积。</li></ul><h2 id="drop-delete与truncate的区别"><a href="#drop-delete与truncate的区别" class="headerlink" title="drop,delete与truncate的区别"></a>drop,delete与truncate的区别</h2><p>区别一：<br>根据sql语言分类来说，delete属于DML语言，也就是数据操作语言，而truncate属于DDL语言，也就是数据定义语言。</p><p>区别二：<br>delete不仅可以删除表中的数据，还可以删除基于真实表创建的视图中的数据。truncate则只能删除表中的数据，不能作用于视图。</p><p>区别三：<br>在数据库删除数据时，delete可以根据需要进行删除，也就是delete可以结合where条件进行精确的删除某一条数据，而truncate则不能支持where子句，如果作用于表，则是直接删除表所有数据。</p><p>区别四：<br>delete删除表时，会涉及到事务处理，也就是可以支持事务提交，回滚。所谓事务就是支持数据一致性，原子性，持久性，隔离性。当使用delete删除表数据时，首先它不会真正删除，而是会将删除的数据放入一个缓存区，可以通过回滚，从而恢复数据。但是使用truncate删除表中数据时，truncate不涉及事务处理，所以被truncate删除的数据是不可恢复的。</p><p>区别五：<br>由于delete删除数据涉及到事务处理，会涉及到缓存，当数据非常大时，有可能缓存不够用，所以这时使用delete删除数据可能达不到删除到的目的，而且速度特别慢。当涉及到大批量的数据时，truncate就非常适合，因为他不涉及到缓存，所以速度特别快，效率也高。</p><p>区别六：<br>有时候对数据操作可能涉及到触发器，用delete删除数据时则有可能会激活触发器，进行一些操作。而truncate是不存在触发器的处理的。</p><p>区别七：<br>在对于一些存在关联关系的表，使用delete删除数据时，可以运用sql的业务逻辑顺序来进行达到删除数据的目的。例如表A与表B存在一对多的关系，表A中id为主键，并且id在表B中是作为表B的外键。要删除数据，这时不能直接删除表B,而应该先删除表A在进行删除表B,这样就达到目的。<br>而truncate不能删除对于由外键约束的表，它达不到删除该表的目的。</p><p>delete和truncate的应用场景</p><ol><li><p>delete适用于数据量较小，对于性能要求不是很高的情况下，可以采用delete加上where子句进行删除数据。</p></li><li><p>如果需要考虑事务提交，回滚操作的，适合适用delete进行删除数据。</p></li><li><p>当涉及到大量数据，而且是不需要回滚的情况下，并且要求速度快，效率高，则可以使用truncate来删除数据。</p></li></ol><p>delete和truncate是用来删除表数据的（但是保留表结构），而drop是用来删除整个表的，包括表结构和表内容，在sql语言分类上它是属于DDL语言。</p><p>他们执行的速度快慢关系：drop&gt;truncate&gt;delete。</p><p>最后，在企业级项目开发中，对于数据并不是真正的从物理上进行删除，而是进行逻辑上的删除，此时会对删除数据进行一个删除标识的处理，也就是说只是把数据从页面上隐藏了，用户暂时看不见了而已，其实数据是还存在的。</p><h2 id="触发器的作用"><a href="#触发器的作用" class="headerlink" title="触发器的作用"></a>触发器的作用</h2><p>触发器是一种<strong>特殊的存储过程</strong>，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。</p><h2 id="什么是存储过程？用什么来调用？"><a href="#什么是存储过程？用什么来调用？" class="headerlink" title="什么是存储过程？用什么来调用？"></a>什么是存储过程？用什么来调用？</h2><p>百度百科：存储过程（Stored Procedure）是在大型数据库系统中，一组为了完成特定功能的SQL语句集，它存储在数据库中，一次编译后永久有效，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。<br>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> order_tot_amt</span><br><span class="line">@o_id <span class="built_in">int</span>,</span><br><span class="line">@p_tot <span class="built_in">int</span> <span class="keyword">output</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> @p_tot = <span class="keyword">sum</span>(Unitprice*Quantity)</span><br><span class="line"><span class="keyword">FROM</span> orderdetails</span><br><span class="line"><span class="keyword">WHERE</span> orderid=@o_id</span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure><p>例子说明：该例子是建立一个简单的存储过程order_tot_amt,这个存储过程根据用户输入的订单ID号码(@o_id),由订单明细表 (orderdetails)中计算该订单销售总额[单价(Unitprice)*数量(Quantity)],这一金额通过@p_tot这一参数输出给调用这一存储过程的程序。<br>调用：1）可以用一个命令对象来调用存储过程。2）可以供外部程序调用，比如：java程序。</p><h2 id="存储过程的优缺点？"><a href="#存储过程的优缺点？" class="headerlink" title="存储过程的优缺点？"></a>存储过程的优缺点？</h2><p>优点：</p><ol><li>存储过程是预编译过的，执行效率高。</li><li>存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</li><li>安全性高，执行存储过程需要有一定权限的用户。</li><li>存储过程可以重复使用，可减少数据库开发人员的工作量。</li></ol><p>缺点：移植性差</p><h2 id="存储过程与函数的区别"><a href="#存储过程与函数的区别" class="headerlink" title="存储过程与函数的区别"></a>存储过程与函数的区别</h2><p>本质上没区别，执行的本质都一样。<br>只是函数有如：只能返回一个变量的限制。而存储过程可以返回多个。　　<br>函数是可以嵌入在sql中使用的,可以在select中调用，而存储过程要让sql的query可以执行，需要把 mysql_real_connect 的最后一个参数设置为CLIENT_MULTI_STATEMENTS。<br>函数限制比较多，比如不能用临时表，只能用表变量．还有一些函数都不可用等等．而存储过程的限制相对就比较少。<br>　　<br>特性区别如下： </p><ol><li>一般来说，存储过程实现的功能要复杂一点，而函数的实现的功能针对性比较强。存储过程，功能强大，可以执行包括修改表等一系列数据库操作；用户定义函数不能用于执行一组修改全局数据库状态的操作。 </li><li>对于存储过程来说可以返回参数，如记录集，而函数只能返回值或者表对象。函数只能返回一个变量；而存储过程可以返回多个。存储过程的参数可以有IN,OUT,INOUT三种类型，而函数只能有IN类~~存储过程声明时不需要返回类型，而函数声明时需要描述返回类型，且函数体中必须包含一个有效的RETURN语句。</li><li>存储过程，可以使用非确定函数，不允许在用户定义函数主体中内置非确定函数。</li><li>存储过程一般是作为一个独立的部分来执行（ EXECUTE 语句执行），而函数可以作为查询语句的一个部分来调用（SELECT调用），由于函数可以返回一个表对象，因此它可以在查询语句中位于FROM关键字的后面。 SQL语句中不可用存储过程，而可以使用函数。 </li></ol><p>当存储过程和函数被执行的时候，SQL Manager会到procedure cache中去取相应的查询语句，如果在procedure cache里没有相应的查询语句，SQL Manager就会对存储过程和函数进行编译。<br>Procedure cache中保存的是执行计划 (execution plan) ，当编译好之后就执行procedure cache中的execution plan，之后SQL SERVER会根据每个execution plan的实际情况来考虑是否要在cache中保存这个plan，评判的标准一个是这个execution plan可能被使用的频率；其次是生成这个plan的代价，也就是编译的耗时。保存在cache中的plan在下次执行时就不用再编译了。</p><p>小结：触发器与存储过程非常相似，触发器也是SQL语句集，两者唯一的区别是触发器不能用EXECUTE语句调用，而是在用户执行Transact-SQL语句时自动触发（激活）执行。触发器是在一个修改了指定表中的数据时执行的存储过程。通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。由于用户不能绕过触发器，所以可以用它来强制实施复杂的业务规则，以确保数据的完整性。触发器不同于存储过程，触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。当对某一表进行诸如UPDATE、INSERT、DELETE这些操作时，SQLSERVER就会自动执行触发器所定义的SQL语句，从而确保对数据的处理必须符合这些SQL语句所定义的规则。</p><h2 id="索引的作用及其优缺点"><a href="#索引的作用及其优缺点" class="headerlink" title="索引的作用及其优缺点"></a>索引的作用及其优缺点</h2><p>索引就一种<strong>特殊的查询表</strong>，数据库的搜索可以利用它加速对数据的检索。它很类似与现实生活中书的目录，不需要查询整本书内容就可以找到想要的数据。索引可以是唯一的，创建索引允许指定单个列或者是多个列。<br>缺点是它减慢了数据录入的速度，同时也增加了数据库的尺寸大小。</p><h2 id="索引的工作原理及其种类"><a href="#索引的工作原理及其种类" class="headerlink" title="索引的工作原理及其种类"></a>索引的工作原理及其种类</h2><p>数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</p><p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p><p>为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。<br><img src="/images/%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F.png" alt="数据库图例"><br>上图展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)的复杂度内获取到相应数据。</p><p>创建索引可以大大提高系统的性能。</p><ul><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li><li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li><li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li><li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li><li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li></ul><p>也许会有人要问：增加索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？因为，增加索引也有许多不利的方面。</p><ul><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li><li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li></ul><p>索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。一般来说，应该在这些列上创建索引：</p><ul><li>在经常需要搜索的列上，可以加快搜索的速度；</li><li>在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；</li><li>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；</li><li>在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；</li><li>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li><li>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</li></ul><p>同样，对于有些列不应该创建索引。一般来说，不应该创建索引的的这些列具有下列特点：</p><ul><li>对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</li><li>对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</li><li>对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</li><li>当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</li></ul><p>根据数据库的功能，可以在数据库设计器中创建三种索引：<strong>唯一索引</strong>、<strong>主键索引</strong>和<strong>聚集索引</strong>。</p><p><strong>唯一索引</strong><br>    唯一索引是不允许其中任何两行具有相同索引值的索引。<br>    当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。<br><strong>主键索引</strong><br>    数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。<br>    在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。<br><strong>聚集索引</strong><br>    在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。<br>    如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。</p><p>局部性原理与磁盘预读<br>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。</p><p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有<strong>局部性的程序</strong>来说，<strong>预读</strong>可以提高I/O效率。<br>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p><p>B-/+Tree索引的性能分析<br>到这里终于可以分析B-/+Tree索引的性能了。<br>上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：<br>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。<br>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p><p>而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。<br>综上所述，用B-Tree作为索引结构效率是非常高的。</p><p>有关数据库索引及B树和B+树知识点可见 <a href="https://blog.csdn.net/zjkC050818/article/details/78278483" target="_blank" rel="noopener">https://blog.csdn.net/zjkC050818/article/details/78278483</a></p><h2 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h2><ol><li>第一范式（1NF）<br>在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。<br>所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。简而言之，<font color="#0099ff">第一范式就是无重复的列</font>。</li></ol><ol start="2"><li><p>第二范式（2NF）<br>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键、主码。<br>第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，<font color="#0099ff">第二范式就是非主属性非部分依赖于主关键字</font>。</p></li><li><p>第三范式（3NF）<br>满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，<font color="#0099ff">第三范式就是属性不依赖于其它非主属性</font>。（我的理解是消除冗余）</p></li></ol><h2 id="为什么用自增列作为主键"><a href="#为什么用自增列作为主键" class="headerlink" title="为什么用自增列作为主键"></a>为什么用自增列作为主键</h2><ol><li>如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引、如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引、如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。</li><li>数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）</li><li>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页</li><li>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</li></ol><h2 id="为什么使用数据索引能提高效率"><a href="#为什么使用数据索引能提高效率" class="headerlink" title="为什么使用数据索引能提高效率"></a>为什么使用数据索引能提高效率</h2><ol><li>数据索引的存储是有序的</li><li>在有序的情况下，通过索引查询一个数据是无需遍历索引记录的</li><li>极端情况下，数据索引的查询效率为二分法查询效率，趋近于 log2(N)</li></ol><h2 id="B-树索引和哈希索引的区别"><a href="#B-树索引和哈希索引的区别" class="headerlink" title="B+树索引和哈希索引的区别"></a>B+树索引和哈希索引的区别</h2><p>B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接，是有序的<br><img src="/images/B-tree.png" alt="B-tree"><br>哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可,是无序的<br><img src="/images/hash.png" alt="hash"><br>哈希索引的优势：<br>    等值查询。哈希索引具有绝对优势（前提是：没有大量重复键值，如果大量重复键值时，哈希索引的效率很低，因为存在所谓的哈希碰撞问题。）<br>哈希索引不适用的场景：</p><ul><li>不支持范围查询</li><li>不支持索引完成排序</li><li>不支持联合索引的最左前缀匹配规则</li></ul><p>通常，B+树索引结构适用于绝大多数场景，像下面这种场景用哈希索引才更有优势：<br>在HEAP表中，如果存储的数据重复度很低（也就是说基数很大），对该列数据以等值查询为主，没有范围查询、没有排序的时候，特别适合采用哈希索引，例如这种SQL：<br>select id,name from table where name=’李明’; — 仅等值查询<br>而常用的InnoDB引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况，如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引），通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。</p><p>注意：在某些工作负载下，通过哈希索引查找带来的性能提升远大于额外的监控索引搜索情况和保持这个哈希表结构所带来的开销。但某些时候，在负载高的情况下，自适应哈希索引中添加的read/write锁也会带来竞争，比如高并发的join操作。like操作和%的通配符操作也不适用于自适应哈希索引，可能要关闭自适应哈希索引。</p><h2 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h2><p>B树，每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为nul，叶子结点不包含任何关键字信息。<br><img src="/images/Btree.png" alt="Btree"><br>B+树，所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接，所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)<br><img src="/images/B+tree.png" alt="B+tree"></p><h2 id="为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引"><a href="#为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引" class="headerlink" title="为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引"></a>为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引</h2><ul><li>B+的磁盘读写代价更低B+的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</li><li>B+-tree的查询效率更加稳定由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li></ul><h2 id="MySQL联合索引"><a href="#MySQL联合索引" class="headerlink" title="MySQL联合索引"></a>MySQL联合索引</h2><ul><li>联合索引是两个或更多个列上的索引。对于联合索引:Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。例如索引是key index (a,b,c). 可以支持a 、 a,b 、 a,b,c 3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。</li><li>利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引 不同于使用两个单独的索引。复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。如果您知 道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不姓，电话簿将没有用处。</li></ul><h2 id="什么情况下应不建或少建索引"><a href="#什么情况下应不建或少建索引" class="headerlink" title="什么情况下应不建或少建索引"></a>什么情况下应不建或少建索引</h2><ul><li>表记录太少</li><li>经常插入、删除、修改的表</li><li>数据重复且分布平均的表字段，假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。</li><li>经常和主字段一块查询但主字段索引值比较多的表字段</li></ul><h2 id="MySQL分区"><a href="#MySQL分区" class="headerlink" title="MySQL分区"></a>MySQL分区</h2><p>一. 什么是表分区？<br>表分区，是指根据一定规则，将数据库中的一张表分解成多个更小的，容易管理的部分。从逻辑上看，只有一张表，但是底层却是由多个物理分区组成。</p><p>二. 表分区与分表的区别<br>分表：指的是通过一定规则，将一张表分解成多张不同的表。比如将用户订单记录根据时间成多个表。<br>分表与分区的区别在于：分区从逻辑上来讲只有一张表，而分表则是将一张表分解成多张表。</p><p>三. 表分区有什么好处？</p><ul><li>分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备。 2. 和单个磁盘或者文件系统相比，可以存储更多数据</li><li>优化查询。在where语句中包含分区条件时，可以只扫描一个或多个分区表来提高查询效率；涉及sum和count语句时，也可以在多个分区上并行处理，最后汇总结果。</li><li>分区表更容易维护。例如：想批量删除大量数据可以清除整个分区。</li><li>可以使用分区表来避免某些特殊的瓶颈，例如InnoDB的单个索引的互斥访问，ext3问价你系统的inode锁竞争等。</li></ul><p>四. 分区表的限制因素</p><ul><li>一个表最多只能有1024个分区</li><li>MySQL5.1中，分区表达式必须是整数，或者返回整数的表达式。在MySQL5.5中提供了非整数表达式分区的支持。</li><li>如果分区字段中有主键或者唯一索引的列，那么多有主键列和唯一索引列都必须包含进来。即：分区字段要么不包含主键或者索引列，要么包含全部主键和索引列。</li><li>分区表中无法使用外键约束</li><li>MySQL的分区适用于一个表的所有数据和索引，不能只对表数据分区而不对索引分区，也不能只对索引分区而不对表分区，也不能只对表的一部分数据分区。</li></ul><p>五. 如何判断当前MySQL是否支持分区？<br>命令：show variables like ‘%partition%’ 运行结果:<br>mysql&gt; show variables like ‘%partition%’;+——————-+——-+| Variable_name | Value |+——————-+——-+| have_partitioning | YES |+——————-+——-+1 row in set (0.00 sec)have_partintioning 的值为YES，表示支持分区。</p><p>六. MySQL支持的分区类型有哪些？</p><ul><li>RANGE分区： 这种模式允许将数据划分不同范围。例如可以将一个表通过年份划分成若干个分区</li><li>LIST分区： 这种模式允许系统通过预定义的列表的值来对数据进行分割。按照List中的值分区，与R* ANGE的区别是，range分区的区间范围值是连续的。</li><li>HASH分区 ：这中模式允许通过对表的一个或多个列的Hash Key进行计算，最后通过这个Hash码不同数值对应的数据区域进行分区。例如可以建立一个对表主键进行分区的表。</li><li>KEY分区 ：上面Hash模式的一种延伸，这里的Hash Key是MySQL系统产生的。</li></ul><h2 id="行级锁定的优点"><a href="#行级锁定的优点" class="headerlink" title="行级锁定的优点"></a>行级锁定的优点</h2><ul><li>当在许多线程中访问不同的行时只存在少量锁定冲突。</li><li>回滚时只有少量的更改</li><li>可以长时间锁定单一的行。</li></ul><h2 id="行级锁定的缺点"><a href="#行级锁定的缺点" class="headerlink" title="行级锁定的缺点"></a>行级锁定的缺点</h2><ul><li>比页级或表级锁定占用更多的内存。</li><li>当在表的大部分中使用时，比页级或表级锁定速度慢，因为你必须获取更多的锁。</li><li>如果你在大部分数据上经常进行GROUP BY操作或者必须经常扫描整个表，比其它锁定明显慢很多。</li><li>用高级别锁定，通过支持不同的类型锁定，你也可以很容易地调节应用程序，因为其锁成本小于行级锁定。</li></ul><h2 id="MySQL触发器简单实例"><a href="#MySQL触发器简单实例" class="headerlink" title="MySQL触发器简单实例"></a>MySQL触发器简单实例</h2><ul><li>CREATE TRIGGER &lt;触发器名称&gt; –触发器必须有名字，最多64个字符，可能后面会附有分隔符.它和MySQL中其他对象的命名方式基本相象.</li><li>{ BEFORE | AFTER } –触发器有执行的时间设置：可以设置为事件发生前或后。</li><li>{ INSERT | UPDATE | DELETE } –同样也能设定触发的事件：它们可以在执行insert、update或delete的过程中触发。</li><li>ON &lt;表名称&gt; –触发器是属于某一个表的:当在这个表上执行插入、 更新或删除操作的时候就导致触发器的激活. 我们不能给同一张表的同一个事件安排两个触发器。</li><li>FOR EACH ROW –触发器的执行间隔：FOR EACH ROW子句通知触发器 每隔一行执行一次动作，而不是对整个表执行一次。</li><li>&lt;触发器SQL语句&gt; –触发器包含所要触发的SQL语句：这里的语句可以是任何合法的语句， 包括复合语句，但是这里的语句受的限制和函数的一样。</li></ul><h2 id="MySQL优化"><a href="#MySQL优化" class="headerlink" title="MySQL优化"></a>MySQL优化</h2><ul><li>开启查询缓存，优化查询</li><li>explain你的select查询，这可以帮你分析你的查询语句或是表结构的性能瓶颈。EXPLAIN 的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的</li><li>当只要一行数据时使用limit 1，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据</li><li>为搜索字段建索引</li><li>使用 ENUM 而不是 VARCHAR，如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用 ENUM 而不是VARCHAR。</li><li>Prepared StatementsPrepared Statements很像存储过程，是一种运行在后台的SQL语句集合，我们可以从使用 prepared statements 获得很多好处，无论是性能问题还是安全问题。Prepared Statements 可以检查一些你绑定好的变量，这样可以保护你的程序不会受到“SQL注入式”攻击</li><li>垂直分表</li><li>选择正确的存储引擎</li></ul><h2 id="key和index的区别"><a href="#key和index的区别" class="headerlink" title="key和index的区别"></a>key和index的区别</h2><ul><li>key 是数据库的物理结构，它包含两层意义和作用，一是约束（偏重于约束和规范数据库的结构完整性），二是索引（辅助查询用的）。包括primary key, unique key, foreign key 等</li><li>index是数据库的物理结构，它只是辅助查询的，它创建时会在另外的表空间（mysql中的innodb表空间）以一个类似目录的结构存储。索引要分类的话，分为前缀索引、全文本索引等；</li></ul><h2 id="数据库优化思路"><a href="#数据库优化思路" class="headerlink" title="数据库优化思路"></a>数据库优化思路</h2><ol><li>SQL语句优化<br> 1）应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。<br> 2）应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：<br> select id from t where num is null<br> 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：<br> select id from t where num=0<br> 3）很多时候用 exists 代替 in 是一个好的选择<br> 4）用Where子句替换HAVING子句 因为HAVING只会在检索出所有记录之后才对结果集进行过滤 </li><li>索引优化<br> 看上文索引 </li><li>数据库结构优化<br> 1）范式优化： 比如消除冗余（节省空间）<br> 2）反范式优化：比如适当加冗余等（减少join）<br> 3）拆分表： 分区将数据在物理上分隔开，不同分区的数据可以制定保存在处于不同磁盘上的数据文件里。这样，当对这个表进行查询时，只需要在表分区中进行扫描，而不必进行全表扫描，明显缩短了查询时间，另外处于不同磁盘的分区也将对这个表的数据传输分散在不同的磁盘I/O，一个精心设置的分区可以将数据传输对磁盘I/O竞争均匀地分散开。对数据量大的时时表可采取此方法。可按月自动建表分区。<br> 4）拆分其实又分垂直拆分和水平拆分：<br> 案例： 简单购物系统暂设涉及如下表： <pre><code>1.产品表（数据量10w，稳定） 2.订单表（数据量200w，且有增长趋势） 3.用户表 （数据量100w，且有增长趋势）以mysql为例讲述下水平拆分和垂直拆分，mysql能容忍的数量级在百万静态数据可以到千万垂直拆分： 解决问题：表与表之间的io竞争 不解决问题：单表中数据量增长出现的压力方案： 把产品表和用户表放到一个server上 订单表单独放到一个server上水平拆分： 解决问题：单表中数据量增长出现的压力 不解决问题：表与表之间的io争夺 </code></pre> 方案： 用户表通过性别拆分为男用户表和女用户表 订单表通过已完成和完成中拆分为已完成订单和未完成订单<br> 产品表 未完成订单放一个server上 已完成订单表盒男用户表放一个server上 女用户表放一个server上(女的爱购物 哈哈) </li><li>服务器硬件优化<br>这个么多花钱咯！</li></ol><h2 id="数据库表创建注意事项"><a href="#数据库表创建注意事项" class="headerlink" title="数据库表创建注意事项"></a>数据库表创建注意事项</h2><p>一、字段名及字段配制合理性</p><ul><li>剔除关系不密切的字段</li><li>字段命名要有规则及相对应的含义（不要一部分英文，一部分拼音，还有类似a.b.c这样不明含义的字段）</li><li>字段命名尽量不要使用缩写（大多数缩写都不能明确字段含义）</li><li>字段不要大小写混用（想要具有可读性，多个英文单词可使用下划线形式连接）</li><li>字段名不要使用保留字或者关键字</li><li>保持字段名和类型的一致性</li><li>慎重选择数字类型</li><li>给文本字段留足余量</li></ul><p>二、系统特殊字段处理及建成后建议</p><ul><li>添加删除标记（例如操作人、删除时间）</li><li>建立版本机制</li></ul><p>三、表结构合理性配置</p><ul><li>多型字段的处理，就是表中是否存在字段能够分解成更小独立的几部分（例如：人可以分为男人和女人）</li><li>多值字段的处理，可以将表分为三张表，这样使得检索和排序更加有调理，且保证数据的完整性！</li></ul><p>四、其它建议</p><ul><li>对于大数据字段，独立表进行存储，以便影响性能（例如：简介字段）</li><li>使用varchar类型代替char，因为varchar会动态分配长度，char指定长度是固定的。</li><li>给表创建主键，对于没有主键的表，在查询和索引定义上有一定的影响。</li><li>免表字段运行为null，建议设置默认值（例如：int类型设置默认值为0）在索引查询上，效率立显！</li><li>建立索引，最好建立在唯一和非空的字段上，建立太多的索引对后期插入、更新都存在一定的影响（考虑实际情况来创建）。</li></ul><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Redis单线程问题"><a href="#Redis单线程问题" class="headerlink" title="Redis单线程问题"></a>Redis单线程问题</h2><p>单线程指的是网络请求模块使用了一个线程（所以不需考虑并发安全性），即一个线程处理所有网络请求，其他模块仍用了多个线程。</p><h2 id="为什么说Redis能够快速执行"><a href="#为什么说Redis能够快速执行" class="headerlink" title="为什么说Redis能够快速执行"></a>为什么说Redis能够快速执行</h2><ul><li>绝大部分请求是纯粹的内存操作（非常快速）</li><li>采用单线程,避免了不必要的上下文切换和竞争条件</li><li>非阻塞IO - IO多路复用</li></ul><h2 id="Redis的内部实现"><a href="#Redis的内部实现" class="headerlink" title="Redis的内部实现"></a>Redis的内部实现</h2><p>内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，不在io上浪费一点时间 这3个条件不是相互独立的，特别是第一条，如果请求都是耗时的，采用单线程吞吐量及性能很差。redis为特殊的场景选择了合适的技术方案。</p><h2 id="Redis关于线程安全问题"><a href="#Redis关于线程安全问题" class="headerlink" title="Redis关于线程安全问题"></a>Redis关于线程安全问题</h2><p>redis实际上是采用了线程封闭的观念，把任务封闭在一个线程，自然避免了线程安全问题，不过对于需要依赖多个redis操作的复合操作来说，依然需要锁，而且有可能是分布式锁。</p><h2 id="使用Redis有哪些好处"><a href="#使用Redis有哪些好处" class="headerlink" title="使用Redis有哪些好处"></a>使用Redis有哪些好处</h2><ul><li>速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</li><li>支持丰富数据类型，支持string，list，set，sorted set，hash</li><li>支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</li><li>丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</li></ul><h2 id="redis相比memcached有哪些优势"><a href="#redis相比memcached有哪些优势" class="headerlink" title="redis相比memcached有哪些优势"></a>redis相比memcached有哪些优势</h2><ul><li>memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</li><li>redis的速度比memcached快很多</li><li>redis可以持久化其数据</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li><li>使用底层模型不同，它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li><li>value大小：redis最大可以达到1GB，而memcache只有1MB</li></ul><h2 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h2><p>过程原理：</p><ul><li>当从库和主库建立MS关系后,会向主数据库发送SYNC命令</li><li>主库接收到SYNC命令后会开始在后台保存快照(RDB持久化过程),并将期间接收到的写命令缓存起来</li><li>当快照完成后,主Redis会将快照文件和所有缓存的写命令发送给从Redis</li><li>从Redis接收到后,会载入快照文件并且执行收到的缓存的命令</li><li>之后,主Redis每当接收到写命令时就会将命令发送从Redis，从而保证数据的一致</li></ul><p>缺点：所有的slave节点数据的复制和同步都由master节点来处理,会照成master节点压力太大,使用主从从结构来解决</p><h2 id="Redis两种持久化方式的优缺点"><a href="#Redis两种持久化方式的优缺点" class="headerlink" title="Redis两种持久化方式的优缺点"></a>Redis两种持久化方式的优缺点</h2><ul><li>RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）</li><li>AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。</li><li>Redis 还可以同时使用 AOF 持久化和 RDB 持久化。当redis重启时,它会有限使用AOF文件来还原数据集,因为AOF文件保存的数据集通常比RDB文件所保存的数据集更加完整</li></ul><h2 id="RDB的优点："><a href="#RDB的优点：" class="headerlink" title="RDB的优点："></a>RDB的优点：</h2><ul><li>RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于进行备份： 比如说，你可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。</li><li>RDB 非常适用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心，或者亚马逊 S3 中。</li><li>RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。</li><li>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快</li></ul><h2 id="Redis常见的性能问题都有哪些？如何解决？"><a href="#Redis常见的性能问题都有哪些？如何解决？" class="headerlink" title="Redis常见的性能问题都有哪些？如何解决？"></a>Redis常见的性能问题都有哪些？如何解决？</h2><ul><li>Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。</li><li>Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化,如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。</li><li>Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。</li><li>Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内</li></ul><h2 id="Redis提供6种数据淘汰策略"><a href="#Redis提供6种数据淘汰策略" class="headerlink" title="Redis提供6种数据淘汰策略"></a>Redis提供6种数据淘汰策略</h2><ul><li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li>no-enviction（驱逐）：禁止驱逐数据</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL&quot;&gt;&lt;a href=&quot;#MySQL&quot; class=&quot;headerlink&quot; title=&quot;MySQL&quot;&gt;&lt;/a&gt;MySQL&lt;/h1&gt;&lt;h2 id=&quot;主键-超键-候选键-外键&quot;&gt;&lt;a href=&quot;#主键-超键-候选键-外键&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="java知识点整理" scheme="https://kepler-ecnu.github.io/categories/java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    
    
      <category term="java数据库篇" scheme="https://kepler-ecnu.github.io/tags/java%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Java网络篇</title>
    <link href="https://kepler-ecnu.github.io/2019/08/12/Java%E7%BD%91%E7%BB%9C/"/>
    <id>https://kepler-ecnu.github.io/2019/08/12/Java网络/</id>
    <published>2019-08-12T01:29:25.000Z</published>
    <updated>2019-09-24T13:28:35.012Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><table><thead><tr><th>具体7层</th><th>数据格式</th><th>功能与连接方式</th><th>典型设备</th><th>协议</th></tr></thead><tbody><tr><td>应用层</td><td>数据</td><td>网络服务与使用者应用程序间的一个接口</td><td>终端设备（PC、手机、平板等）</td><td>FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</td></tr><tr><td>表示层</td><td>数据</td><td>数据表示、数据安全、数据压缩</td><td>终端设备</td><td>JPEG、MPEG、ASII</td></tr><tr><td>会话层</td><td>数据</td><td>会话层连接到传输层的映射；会话连接的流量控制；数据传输；会话连接恢复与释放；会话连接管理、差错控制</td><td>终端设备</td><td>SQL、NETBIOS、RPC</td></tr><tr><td>传输层</td><td>数据组织成数据段</td><td>用一个寻址机制来标识一个特定的应用程序（端口号）</td><td>终端设备</td><td>TCP、UDP、SPX</td></tr><tr><td>网络层</td><td>分割和重新组合数据包</td><td>基于网络层地址（IP地址）进行不同网络系统间的路径选择</td><td>网关、路由器</td><td>IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP</td></tr><tr><td>数据链路层</td><td>将比特信息封装成数据帧</td><td>在物理层上建立、撤销、标识逻辑链接和链路复用以及差错校验等功能。通过使用接收系统的硬件地址或物理地址来寻址</td><td>中继器、集线器</td><td>PPP、HDLC、VLAN、MAC</td></tr><tr><td>物理层</td><td>传输比特流</td><td>建立、维护和取消物理连接</td><td>光纤、同轴电缆</td><td>RJ45、CLOCK、IEEE802.3</td></tr></tbody></table><p>总结：</p><ol><li>应用层按协议打包数据</li><li>由传输层加上双方的端口号</li><li>由网络层加上双方的IP地址</li><li>由链路层加上双方的MAC地址，并将数据拆分成数据帧</li><li>数模信号转换并由物理层传输到另一端</li></ol><h2 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h2><ol><li>应用层，对应OSI参考模型应用层、表示层、会话层</li><li>传输层，对应OSI的传输层</li><li>网络层（网际层），对应OSI的网络层</li><li>网络接入层，对应OSI的数据链路层和物理层</li></ol><p>OSI模型的网络层同时支持<strong>面向连接</strong>和<strong>面向无连接</strong>的通信，但是传输层只支持<strong>面向连接</strong>的通信；<br>TCP/IP模型的网络层只提供<strong>无连接的服务</strong>，但是传输层上同时提供可靠和不可靠两种通信模式。</p><h2 id="说一下TTL"><a href="#说一下TTL" class="headerlink" title="说一下TTL"></a>说一下TTL</h2><p>Time To Live<br>数据包在传输过程中每经过一个路由器，TTL值就会减1，直到TTL=0时，数据包被丢弃，并发送ICMP报文通知源主机防止重复发送。</p><h2 id="ping和tracert命令用的什么协议"><a href="#ping和tracert命令用的什么协议" class="headerlink" title="ping和tracert命令用的什么协议"></a>ping和tracert命令用的什么协议</h2><p>ICMP</p><h2 id="MTU是什么"><a href="#MTU是什么" class="headerlink" title="MTU是什么"></a>MTU是什么</h2><p>最大传输单元<br>由于不同硬件的物理特性不同，对数据帧的最大长度都有不同的限制，这个最大长度称为MTU。（然后通过路由对IP报文进行分片完成传输）</p><h2 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h2><p>TCP报文时TCP层传输的数据单元，也叫报文段。</p><p><img src="/images/tcp%E9%A6%96%E9%83%A8.png" alt="tcp首部"></p><ul><li>序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。</li><li>确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。</li><li>确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效</li><li>同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。</li><li>终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接</li><li>PS：ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。</li></ul><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>URG</td><td>紧急指针是否有效。为1，表示某一位需要被优先处理</td></tr><tr><td>ACK</td><td>确认号是否有效，一般置为1。</td></tr><tr><td>PSH</td><td>提示接收端应用程序立即从TCP缓冲区把数据读走。</td></tr><tr><td>RST</td><td>对方要求重新建立连接，复位。</td></tr><tr><td>SYN</td><td>请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1</td></tr><tr><td>FIN</td><td>希望断开连接。</td></tr></tbody></table><p>通过对 TCP 头的解析，我们知道要掌握 TCP 协议，还应该重点关注以下问题：</p><ul><li>连接维护</li><li>顺序问题</li><li>丢包问题</li><li>流量控制</li><li>拥塞控制</li></ul><h3 id="三次握手过程"><a href="#三次握手过程" class="headerlink" title="三次握手过程"></a>三次握手过程</h3><p>所有问题，首先都要建立连接，故最开始时连接维护的问题<br><img src="/images/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="三次握手"></p><ul><li>握手过程<br>第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。<br>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；<br>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li></ul><h3 id="四次挥手过程"><a href="#四次挥手过程" class="headerlink" title="四次挥手过程"></a>四次挥手过程</h3><p><img src="/images/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="四次挥手"></p><ul><li>挥手过程<br>1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。<br>2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。<br>3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。<br>4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。<br>5）客户端收到服务器的连接释放报文</li></ul><h3 id="累计确认（TCP如何实现可靠传输）"><a href="#累计确认（TCP如何实现可靠传输）" class="headerlink" title="累计确认（TCP如何实现可靠传输）"></a>累计确认（TCP如何实现可靠传输）</h3><p>首先为了保证顺序性，每个包都有一个 ID。在建立连接的时候会商定起始 ID 是什么，然后按照 ID 一个个发送，为了保证不丢包，需要对发送的包都要进行应答，当然，这个应答不是一个一个来的，而是会应答某个之前的 ID，表示都收到了，这种模式成为<strong>累计应答</strong>或<strong>累计确认</strong>。</p><p>为了记录所有发送的包和接收的包，TCP 需要发送端和接收端分别来缓存这些记录，发送端的缓存里是按照包的 ID 一个个排列，根据处理的情况分成四个部分</p><ul><li>发送并且确认的</li><li>发送尚未确认的</li><li>没有发送等待发送的</li><li>没有发送并且暂时不会发送的</li></ul><p>这里的第三部分和第四部分就属于流量控制的内容</p><p>在 TCP 里，接收端会给发送端报一个窗口大小，叫 Advertised window。这个窗口应该等于上面的第二部分加上第三部分，超过这个窗口，接收端做不过来，就不能发送了</p><p>于是，发送端要保持下面的数据结构<br><img src="/images/advertised_window.jpg" alt="发送端窗口"></p><p>对于接收端来讲，它的缓存里面的内容要简单一些</p><ul><li>接收并且确认过的</li><li>还没接收，但是马上就能接收的</li><li>还没接收，但也无法接收的</li></ul><p>对应的数据结构如下<br><img src="/images/%E6%8E%A5%E6%94%B6%E7%AB%AF%E7%AA%97%E5%8F%A3.jpg" alt="接收端窗口"></p><h3 id="顺序问题和丢包问题"><a href="#顺序问题和丢包问题" class="headerlink" title="顺序问题和丢包问题"></a>顺序问题和丢包问题</h3><p>结合上面的图看，在发送端，1、2、3 已发送并确认；4、5、6、7、8、9 都是发送了还没确认；10、11、12 是还没发出的；13、14、15 是接收方没有空间，不准备发的。</p><p>在接收端来看，1、2、3、4、5 是已经完成 ACK 但是还没读取的；6、7 是等待接收的；8、9 是已经接收还没有 ACK 的。</p><p>发送端和接收端当前的状态如下：</p><ul><li>1、2、3 没有问题，双方达成了一致</li><li>4、5 接收方说 ACK 了，但是发送方还没收到</li><li>6、7、8、9 肯定都发了，但是 8、9 已经到了，6、7 没到，出现了乱序，缓存着但是没办法 ACK。</li></ul><p>根据这个例子可以知道顺序问题和丢包问题都有可能存在，所以我们先来看<strong>确认与重传机制</strong>。</p><p>假设 4 确认收到了，5 的 ACK 丢了，6、7 的数据包丢了，该怎么办？</p><p>一种方法是<strong>超时重试或超时重传</strong>，即对每一个发送了但是没有 ACK 的包设定一个定时器，超过了一定的事件就重新尝试。这个时间必须大于往返时间，但也不宜过长，否则超时时间变长，访问就变慢了。</p><p>如果过一段时间，5、6、7 都超时了就会重新发送。接收方发现 5 原来接收过，于是丢弃 5；6 收到了，发送 ACK，要求下一个是 7，7 不幸又丢了。当 7 再次超时的时候，TCP 的策略是超时间隔加倍。每当遇到一次超时重传的时候，都会讲下一次超时时间间隔设为先前值的两倍。</p><p>超时重传的机制是超时周期可能相对较长，是否有更快的方式呢？</p><p>有一个<strong>快速重传</strong>的机制，即当接收方接收到一个序号大于期望的报文段时，就检测到了数据流之间的间隔，于是发送三个冗余的 ACK，客户端接收到之后，知道数据报丢失，于是重传丢失的报文段。</p><p>例如，接收方发现 6、8、9 都接收了，但是 7 没来，所以肯定丢了，于是发送三个 6 的 ACK，要求下一个是 7。客户端接收到 3 个，就会发现 7 的确又丢了，不等超时，马上重发。</p><h3 id="流量控制的问题（滑动窗口机制）"><a href="#流量控制的问题（滑动窗口机制）" class="headerlink" title="流量控制的问题（滑动窗口机制）"></a>流量控制的问题（滑动窗口机制）</h3><p>在流量控制的机制里面，在对于包的确认中，会携带一个窗口的大小</p><p>简单的说一下就是接收端在发送 ACK 的时候会带上缓冲区的窗口大小，但是一般在窗口达到一定大小才会更新窗口，因为每次都更新的话，刚空下来就又被填满了</p><h3 id="拥塞控制的问题（滑动窗口机制）"><a href="#拥塞控制的问题（滑动窗口机制）" class="headerlink" title="拥塞控制的问题（滑动窗口机制）"></a>拥塞控制的问题（滑动窗口机制）</h3><p>也是通过窗口的大小来控制的，但是检测网络满不满是个挺难的事情，所以 TCP 发送包经常被比喻成往谁管理灌水，所以拥塞控制就是在不堵塞，不丢包的情况下尽可能的发挥带宽。</p><p>水管有粗细，网络有带宽，即每秒钟能发送多少数据；水管有长度，端到端有时延。理想状态下，水管里面的水 = 水管粗细 * 水管长度。对于网络上，通道的容量 = 带宽 * 往返时延。</p><p>如果我们设置发送窗口，使得发送但未确认的包为通道的容量，就能撑满整个管道。<br><img src="/images/%E7%AA%97%E5%8F%A3.jpg" alt><br>如图所示，假设往返时间为 8 秒，去 4 秒，回 4 秒，每秒发送一个包，已经过去了 8 秒，则 8 个包都发出去了，其中前四个已经到达接收端，但是 ACK 还没返回，不能算发送成功，5-8 后四个包还在路上，还没被接收，这个时候，管道正好撑满，在发送端，已发送未确认的 8 个包，正好等于带宽，也即每秒发送一个包，也即每秒发送一个包，乘以来回时间 8 秒。</p><p>如果在这个基础上调大窗口，使得单位时间可以发送更多的包，那么会出现接收端处理不过来，多出来的包会被丢弃，这个时候，我们可以增加一个缓存，但是缓存里面的包 4 秒内肯定达不到接收端课，它的缺点会增加时延，如果时延达到一定程度就会超时重传</p><p>TCP 拥塞控制主要来避免两种现象，包丢失和超时重传，一旦出现了这些现象说明发送的太快了，要慢一点。</p><p>具体的方法就是发送端<strong>慢启动</strong>，比如倒水，刚开始倒的很慢，渐渐变快。然后设置一个阈值，当超过这个值的时候就要慢下来</p><p>慢下来还是在增长，这时候就可能水满则溢，出现拥塞，需要降低倒水的速度，等水慢慢渗下去。</p><p>拥塞的一种表现是丢包，需要<strong>超时重传</strong>，这个时候，采用快速重传算法，将当前速度变为一半。所以速度还是在比较高的值，也没有一夜回到解放前。</p><h3 id="为什么连接的时候是三次握手，关闭的时候却是四次握手"><a href="#为什么连接的时候是三次握手，关闭的时候却是四次握手" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候却是四次握手"></a>为什么连接的时候是三次握手，关闭的时候却是四次握手</h3><p>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p><h3 id="为什么不直接关闭而是进入TIME-WAIT"><a href="#为什么不直接关闭而是进入TIME-WAIT" class="headerlink" title="为什么不直接关闭而是进入TIME_WAIT"></a>为什么不直接关闭而是进入TIME_WAIT</h3><p>客户端要确认服务器能收到ACK信号。(如果不确认这一点，服务器会认为客户端没有收到自己的FIN+ACK报文，所以会重发)<br>防止失效请求。(为了防止已失效的连接的请求数据包和正常的混淆)</p><h3 id="为什么TIME-WAIT状态需要经过2MSL-最大报文段生存时间-才能返回到CLOSE状态？"><a href="#为什么TIME-WAIT状态需要经过2MSL-最大报文段生存时间-才能返回到CLOSE状态？" class="headerlink" title="为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？"></a>为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</h3><p>虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p><h3 id="为什么不能用两次握手进行连接"><a href="#为什么不能用两次握手进行连接" class="headerlink" title="为什么不能用两次握手进行连接"></a>为什么不能用两次握手进行连接</h3><p>3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。<br>现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p><h3 id="如果已经建立了连接，但是客户端突然出现故障了怎么办"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办</h3><p>TCP还设有一个<strong>保活计时器</strong>，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h3 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h3><ul><li>TCP面向连接，UDP面向非连接</li><li>TCP提供可靠的服务（数据传输无差错、不丢失、不重复、按序到达），UDP不可靠</li><li>TCP面向字节流，UDP面向报文</li><li>TCP数据传输慢，UDP数据传输快</li><li>TCP首部开销20字节，UDP8字节</li></ul><h3 id="TCP-为什么是可靠连接"><a href="#TCP-为什么是可靠连接" class="headerlink" title="TCP 为什么是可靠连接"></a>TCP 为什么是可靠连接</h3><ul><li>通过 TCP 连接传输的数据无差错，不丢失，不重复，且按顺序到达。</li><li>TCP 报文头里面的序号能使 TCP 的数据按序到达</li><li>报文头里面的确认序号能保证不丢包，累计确认及超时重传机制</li><li>TCP 拥有流量控制及拥塞控制的机制<br>TCP 的顺序问题，丢包问题，流量控制都是通过滑动窗口来解决的<br>拥塞控制时通过拥塞窗口来解决的</li></ul><h2 id="http-响应码-301-和-302-代表的是什么？有什么区别？"><a href="#http-响应码-301-和-302-代表的是什么？有什么区别？" class="headerlink" title="http 响应码 301 和 302 代表的是什么？有什么区别？"></a>http 响应码 301 和 302 代表的是什么？有什么区别？</h2><ul><li>301：永久重定向。</li><li>302：暂时重定向。<br>它们的区别是，301 对搜索引擎优化（SEO）更加有利；302 有被提示为网络拦截的风险</li></ul><h2 id="forward-和-redirect-的区别"><a href="#forward-和-redirect-的区别" class="headerlink" title="forward 和 redirect 的区别"></a>forward 和 redirect 的区别</h2><p>forward 是转发 和 redirect 是重定向：</p><ul><li>地址栏 url 显示：foward url 不会发生改变，redirect url 会发生改变；</li><li>数据共享：forward 可以共享 request 里的数据，redirect 不能共享；</li><li>效率：forward 比 redirect 效率高。</li></ul><h2 id="说一下-tcp-粘包是怎么产生的"><a href="#说一下-tcp-粘包是怎么产生的" class="headerlink" title="说一下 tcp 粘包是怎么产生的"></a>说一下 tcp 粘包是怎么产生的</h2><p>tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因：</p><ul><li>发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包；</li><li>接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收</li></ul><h2 id="get-和-post-请求有哪些区别"><a href="#get-和-post-请求有哪些区别" class="headerlink" title="get 和 post 请求有哪些区别"></a>get 和 post 请求有哪些区别</h2><ul><li>get 请求会被浏览器主动缓存，而 post 不会。</li><li>get 传递参数有大小限制，而 post 没有。</li><li>post 参数传输更安全，get 的参数会明文限制在 url 上，post 不会。</li></ul><h2 id="如何实现跨域"><a href="#如何实现跨域" class="headerlink" title="如何实现跨域"></a>如何实现跨域</h2><p>实现跨域有以下几种方案：</p><ul><li>服务器端运行跨域 设置 CORS 等于 *；</li><li>在单个接口使用注解 @CrossOrigin 运行跨域；</li><li>使用 jsonp 跨域；</li></ul><h2 id="常用端口及其对应服务"><a href="#常用端口及其对应服务" class="headerlink" title="常用端口及其对应服务"></a>常用端口及其对应服务</h2><table><thead><tr><th>常见服务</th><th>端口</th></tr></thead><tbody><tr><td>HTTP</td><td>80</td></tr><tr><td>FTP</td><td>21</td></tr><tr><td>DNS</td><td>53</td></tr><tr><td>POP3</td><td>110</td></tr><tr><td>SMTP</td><td>25</td></tr><tr><td>SSH</td><td>22</td></tr><tr><td>nginx</td><td>80</td></tr><tr><td>MEMCACHED</td><td>11211</td></tr><tr><td>MYSQL</td><td>3306</td></tr><tr><td>TOMCAT</td><td>8080</td></tr><tr><td>NFS</td><td>2049</td></tr><tr><td>TLENET</td><td>23</td></tr><tr><td>HTTPS</td><td>443</td></tr><tr><td>SAMBA</td><td>UDP139 TCP139</td></tr><tr><td>POSTFIX</td><td>25</td></tr><tr><td>IMAP</td><td>143</td></tr><tr><td>ZABBIX</td><td>10051</td></tr><tr><td>DHCP</td><td>56</td></tr></tbody></table><h2 id="在浏览器中输入网址之后执行会发生什么"><a href="#在浏览器中输入网址之后执行会发生什么" class="headerlink" title="在浏览器中输入网址之后执行会发生什么"></a>在浏览器中输入网址之后执行会发生什么</h2><ul><li>DNS解析，找到对应ip地址</li><li>客户端发起http/https请求,然后交给传输层</li><li>传输层将请求分成报文段，添加目标源和端口，并随机用一个本地接口封装进报头，然后交给网络层。</li><li>网络层加上双方的ip地址信息，并负责路由分发。</li><li>链路层中，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包进行传输了，然后发送IP数据包到达服务器的地址。</li></ul><h2 id="为什么需要DNS解析为IP地址"><a href="#为什么需要DNS解析为IP地址" class="headerlink" title="为什么需要DNS解析为IP地址"></a>为什么需要DNS解析为IP地址</h2><p>网络通讯大部分是基于TCP/IP的，而TCP/IP是基于IP地址的，所以计算机在网络上进行通讯时只能识别如“202.96.134.133”之类的IP地址，而不能认识域名。我们无法记住10个以上IP地址的网站，所以我们访问网站时，更多的是在浏览器地址栏中输入域名，就能看到所需要的页面，这是因为有一个叫“DNS服务器”的计算机自动把我们的域名“翻译”成了相应的IP地址，然后调出IP地址所对应的网页。</p><h2 id="DNS查询过程"><a href="#DNS查询过程" class="headerlink" title="DNS查询过程"></a>DNS查询过程</h2><p><img src="/images/DNS.jpg" alt><br>1、在浏览器中输入 <a href="http://www.qq.com" target="_blank" rel="noopener">www.qq.com</a> 域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。</p><p>2、如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。</p><p>3、如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。</p><p>4、如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。</p><p>5、如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至(13台)根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址 (<a href="http://qq.com" target="_blank" rel="noopener">http://qq.com</a>) 给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找 <a href="http://qq.com" target="_blank" rel="noopener">http://qq.com</a> 域服务器，重复上面的动作，进行查询，直至找到 <a href="http://www.qq.com" target="_blank" rel="noopener">www.qq.com</a> 主机。</p><p>6、如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。</p><p>从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。</p><h2 id="Http-和-Https"><a href="#Http-和-Https" class="headerlink" title="Http 和 Https"></a>Http 和 Https</h2><h3 id="Http和Https的基本概念"><a href="#Http和Https的基本概念" class="headerlink" title="Http和Https的基本概念"></a>Http和Https的基本概念</h3><ul><li>Http：超文本传输协议（Http，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。设计Http最初的目的是为了提供一种发布和接收HTML页面的方法。它可以使浏览器更加高效。Http协议是以<strong>明文方式</strong>发送信息的，如果黑客截取了Web浏览器和服务器之间的传输报文，就可以直接获得其中的信息。</li><li>Https：是以安全为目标的Http通道，是Http的安全版。Https的安全基础是SSL。SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层：SSL记录协议（SSL Record Protocol），它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。SSL握手协议（SSL Handshake Protocol），它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</li></ul><h3 id="Http-和-Https-的区别"><a href="#Http-和-Https-的区别" class="headerlink" title="Http 和 Https 的区别"></a>Http 和 Https 的区别</h3><p>1、Https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。(原来网易官网是Http，而网易邮箱是Https。)</p><p>2、Http是超文本传输协议，信息是明文传输，Https则是具有安全性的SSL加密传输协议。</p><p>3、Http和Https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><p>4、Http的连接很简单，是<strong>无状态的</strong>。Https协议是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议，比Http协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)</p><h3 id="Https的优点"><a href="#Https的优点" class="headerlink" title="Https的优点"></a>Https的优点</h3><p>1、使用Https协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。</p><p>2、Https协议是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、修改，确保数据的完整性。</p><p>3、Https是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p><h3 id="Https的缺点（对比优点）"><a href="#Https的缺点（对比优点）" class="headerlink" title="Https的缺点（对比优点）"></a>Https的缺点（对比优点）</h3><p>1、Https协议握手阶段比较费时，会使页面的加载时间延长近。</p><p>2、Https连接缓存不如Http高效，会增加数据开销，甚至已有的安全措施也会因此而受到影响；</p><p>3、SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</p><p>4、Https协议的加密范围也比较有限。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</p><h3 id="HTTP1-0-1-1-2-0区别"><a href="#HTTP1-0-1-1-2-0区别" class="headerlink" title="HTTP1.0/1.1/2.0区别"></a>HTTP1.0/1.1/2.0区别</h3><ul><li>HTTP1.1默认使用长连接，可有效减少TCP的三次握手开销。</li><li>HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。另外HTTP还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础。</li><li>HTTP1.0是没有host域的，HTTP1.1才支持这个参数。</li><li>HTTP2.0使用多路复用技术(Multiplexing),多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。<br>“HTTP1.1在同一时间对于同一个域名的请求数量有限制，超过限制就会阻塞请求”。多路复用底层采用 “增加二进制分帧层” 的方法，使得不改变原来的语义、首部字段的情况下提高传输性能，降低延迟。<br>二进制分帧将所有传输信息分割为更小的帧，用二进制进行编码，多个请求都在同一个TCP连接上完成，可以承载任意数量的双向数据流。HTTP/2更有效的使用TCP连接，得到性能上的提升。</li><li>HTTP/2新增首部压缩（Header Compression）:采用HPACK算法</li><li>HTTP/2新增服务端推送（Header Compression）</li></ul><p>简言之：</p><ul><li>HTTP1.0与HTTP 1.1的主要区别<br>  长连接<br>  节约带宽<br>  HOST域</li><li>HTTP1.1与HTTP 2.0的主要区别<br>  多路复用<br>  二进制分帧<br>  首部压缩<br>  服务器推送<br><img src="/images/http.png" alt></li></ul><h2 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h2><p>A类地址：以0开头，第一个字节范围：0 ~ 127（1.0.0.0 - 126.255.255.255)；<br>B类地址：以10开头，第一个字节范围：128 ~ 191（128.0.0.0 - 191.255.255.255);<br>C类地址：以110开头，第一个字节范围：192 ~ 223（192.0.0.0 - 223.255.255.255);<br>内部(私有)地址：10.0.0.0 — 10.255.255.255， 172.16.0.0 — 172.31.255.255， 192.168.0.0—192.168.255.255。</p><h2 id="ARP是什么协议，简单语言解释一下工作原理"><a href="#ARP是什么协议，简单语言解释一下工作原理" class="headerlink" title="ARP是什么协议，简单语言解释一下工作原理"></a>ARP是什么协议，简单语言解释一下工作原理</h2><ol><li>每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。</li><li>当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP地址。</li><li>当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。</li><li>源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</li></ol><p>广播发送ARP请求，单播发送ARP响应。</p><h2 id="DHCP协议有什么作用"><a href="#DHCP协议有什么作用" class="headerlink" title="DHCP协议有什么作用"></a>DHCP协议有什么作用</h2><p>一个局域网的网络协议，使用UDP协议工作<br>用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p><h2 id="子网掩码的作用"><a href="#子网掩码的作用" class="headerlink" title="子网掩码的作用"></a>子网掩码的作用</h2><p>子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。</p><h2 id="通过IP和子网掩码计算网络号-笔试题"><a href="#通过IP和子网掩码计算网络号-笔试题" class="headerlink" title="通过IP和子网掩码计算网络号(笔试题)"></a>通过IP和子网掩码计算网络号(笔试题)</h2><p>计算出IP二进制和子网掩码的二进制，然后取与</p><h2 id="通过IP和子网掩码计算主机号-笔试题"><a href="#通过IP和子网掩码计算主机号-笔试题" class="headerlink" title="通过IP和子网掩码计算主机号(笔试题)"></a>通过IP和子网掩码计算主机号(笔试题)</h2><p>将子网掩码的二进制取反，然后与IP的二进制取与。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;OSI七层模型&quot;&gt;&lt;a href=&quot;#OSI七层模型&quot; class=&quot;headerlink&quot; title=&quot;OSI七层模型&quot;&gt;&lt;/a&gt;OSI七层模型&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;具体7层&lt;/th&gt;
&lt;th&gt;数据格式&lt;/th&gt;
&lt;th&gt;
      
    
    </summary>
    
      <category term="java知识点整理" scheme="https://kepler-ecnu.github.io/categories/java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    
    
      <category term="java网络篇" scheme="https://kepler-ecnu.github.io/tags/java%E7%BD%91%E7%BB%9C%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Java知识点整理(不间断更新)</title>
    <link href="https://kepler-ecnu.github.io/2019/08/06/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <id>https://kepler-ecnu.github.io/2019/08/06/Java知识点整理/</id>
    <published>2019-08-06T05:20:21.000Z</published>
    <updated>2019-08-30T06:52:43.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java基础知识点"><a href="#Java基础知识点" class="headerlink" title="Java基础知识点"></a>Java基础知识点</h2><h3 id="简述什么是跨平台"><a href="#简述什么是跨平台" class="headerlink" title="简述什么是跨平台"></a>简述什么是跨平台</h3><p>由于各种操作系统所支持的指令集不是完全一致的，所以在操作系统上加个虚拟机来提供统一接口，屏蔽系统之间的差异。</p><h3 id="Java有几种基本数据类型"><a href="#Java有几种基本数据类型" class="headerlink" title="Java有几种基本数据类型"></a>Java有几种基本数据类型</h3><p>有八种基本数据类型:</p><table><thead><tr><th>数据类型</th><th>字节</th><th>默认值</th></tr></thead><tbody><tr><td>byte</td><td>1</td><td>0</td></tr><tr><td>char</td><td>4</td><td>‘\u0000’</td></tr><tr><td>boolean</td><td>1</td><td>false</td></tr><tr><td>float</td><td>4</td><td>0.0f</td></tr><tr><td>double</td><td>8</td><td>0.0d</td></tr><tr><td>int</td><td>4</td><td>0</td></tr><tr><td>short</td><td>2</td><td>0</td></tr><tr><td>long</td><td>8</td><td>0</td></tr></tbody></table><h3 id="面向对象特征"><a href="#面向对象特征" class="headerlink" title="面向对象特征"></a>面向对象特征</h3><p>面向对象的编程语言有<strong>封装、继承、多态、抽象</strong>四个主要特征。</p><ul><li>封装：把描述一个对象的属性和行为封装在一个模块中，即一个类中，属性用变量定义，行为用方法定义，方法可以直接访问同一个对象中的属性。</li><li>抽象：把现实生活中的对象抽象为类。分为过程抽象和数据抽象<ul><li>过程抽象：类的方法（鸟会啼鸣等）</li><li>数据抽象：类的属性（鸟有翅膀等）</li></ul></li><li>继承：子类继承父类的特征和行为。子类可以有父类非私有的方法，也可以对父类进行扩展，也可以重写父类的方法。缺点就是提高了代码间的耦合性。</li><li>多态：<ul><li>编译时多态：方法的重载</li><li>运行时多态：向上转型、方法重写–基于继承</li></ul></li></ul><h3 id="面向对象六大原则"><a href="#面向对象六大原则" class="headerlink" title="面向对象六大原则"></a>面向对象六大原则</h3><ol><li><strong>单一职责</strong>原则—-SRP<ul><li>让每个类只专心处理自己的方法</li></ul></li><li><strong>开闭</strong>原则—-OCP<ul><li>软件中的对象（类、模块、函数等）应该<strong>对于扩展开放</strong>，<strong>对于修改是关闭</strong>的</li></ul></li><li><strong>里氏替换</strong>原则—-LSP<ul><li>子类可以去扩展父类，但是不能改变父类原有的功能</li></ul></li><li><strong>依赖倒置</strong>原则—-DIP<ul><li>应该通过调用接口或抽象类，而不是调用实现类</li></ul></li><li><strong>接口隔离</strong>原则—-ISP<ul><li>把接口分为满足依赖关系的最小接口，实现类中不能有不需要的方法</li></ul></li><li><strong>迪米特</strong>原则—-LOP<ul><li>高内聚、低耦合</li></ul></li></ol><h3 id="String属于基础的数据类型吗"><a href="#String属于基础的数据类型吗" class="headerlink" title="String属于基础的数据类型吗"></a>String属于基础的数据类型吗</h3><p>String不属于基础类型，基础类型有type、boolean、int、char、short、long、float、double，而String属于包装器类型</p><h3 id="为什么要有包装类型"><a href="#为什么要有包装类型" class="headerlink" title="为什么要有包装类型"></a>为什么要有包装类型</h3><p>为了让基本数据类型也具有对象的特征，就出现了包装类型（如在使用集合类型Collection时就一定要使用包装类型而不是基本数据类型）。因为容器都是装object的，这时就需要这些基本数据类型的包装类型了。</p><table><thead><tr><th>基本类型</th><th>包装器类型</th></tr></thead><tbody><tr><td>boolean</td><td>Boolean</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr></tbody></table><h3 id="自动装箱和自动拆箱"><a href="#自动装箱和自动拆箱" class="headerlink" title="自动装箱和自动拆箱"></a>自动装箱和自动拆箱</h3><p>自动装箱：<code>new Integer(6)</code>，底层调用：<code>Integer.valueOf(6)</code>；<br>自动拆箱：<code>int i = new Integer(6)</code>，底层调用：<code>i.intValue();</code><br>二者的区别：</p><ul><li>声明方式不同：基本数据类型不使用new关键字，而包装类型需要使用new关键字在<strong>堆中分配存储空间</strong>；</li><li>存储方式及位置不同：基本数据类型是直接将变量值存储在<strong>栈</strong>中，而包装类型是将对象放在<strong>堆</strong>中，然后通过<strong>引用</strong>来使用；</li><li>初始值不同：基本数据类型的初始值如int为0，boolean为false，而包装类型的初始值为null；</li><li>使用方式不同：基本数据类型赋值直接使用就好，而包装类型在集合如Collection、Map时会使用到。</li></ul><h3 id="String-str-“i”-与-String-str-new-String-“i”-一样么"><a href="#String-str-“i”-与-String-str-new-String-“i”-一样么" class="headerlink" title="String str = “i” 与 String str = new String(“i”)一样么"></a>String str = “i” 与 String str = new String(“i”)一样么</h3><p>不一样，因为内存的分配方式不一样。<code>String str = "i"</code>的方式，Java虚拟机会将其分配到常量池中；<code>String str = new String("i")</code>则会被分到堆内存中。</p><h3 id="如何将字符串反转"><a href="#如何将字符串反转" class="headerlink" title="如何将字符串反转"></a>如何将字符串反转</h3><p>使用StringBuilder或者StringBuffer的reverse()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// StringBuffer reverse</span><br><span class="line">StringBuffer stringBuffer = new StringBuffer();</span><br><span class="line">stringBuffer. append(&quot;abcdefg&quot;);</span><br><span class="line">System. out. println(stringBuffer. reverse()); // gfedcba</span><br><span class="line">// StringBuilder reverse</span><br><span class="line">StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">stringBuilder. append(&quot;abcdefg&quot;);</span><br><span class="line">System. out. println(stringBuilder. reverse()); // gfedcba</span><br></pre></td></tr></table></figure><h3 id="String-类常用方法"><a href="#String-类常用方法" class="headerlink" title="String 类常用方法"></a>String 类常用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">indexOf()：返回指定字符的索引。</span><br><span class="line">charAt()：返回指定索引处的字符。</span><br><span class="line">replace()：字符串替换。</span><br><span class="line">trim()：去除字符串两端空白。</span><br><span class="line">split()：分割字符串，返回一个分割后的字符串数组。</span><br><span class="line">getBytes()：返回字符串的 byte 类型数组。</span><br><span class="line">length()：返回字符串长度。</span><br><span class="line">toLowerCase()：将字符串转成小写字母。</span><br><span class="line">toUpperCase()：将字符串转成大写字符。</span><br><span class="line">substring()：截取字符串。</span><br><span class="line">equals()：字符串比较。</span><br></pre></td></tr></table></figure><h3 id="和-equals-区别"><a href="#和-equals-区别" class="headerlink" title="== 和 equals 区别"></a>== 和 equals 区别</h3><ul><li><p>== 比较的是<strong>两个引用</strong>在内存中指向的是不是同一对象（即同一内存空间），也就是说在内存中的存储位置是否一致。如果两个对象的引用相同时（指向同一对象时），== 操作符返回true,否则返回false。</p><ul><li><p>对于基本类型和引用类型 == 的作用效果是不同的：<br>基本类型：比较的是值是否相同；<br>引用类型：比较的是引用是否相同；<br>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String x = &quot;string&quot;;</span><br><span class="line">String y = &quot;string&quot;;</span><br><span class="line">String z = new String(&quot;string&quot;);</span><br><span class="line">System.out.println(x==y); // true</span><br><span class="line">System.out.println(x==z); // false</span><br><span class="line">System.out.println(x.equals(y)); // true</span><br><span class="line">System.out.println(x.equals(z)); // true</span><br></pre></td></tr></table></figure><p>代码解读：因为 x 和 y 指向的是同一个引用，所以 == 是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true</p></li></ul></li><li><p>equals 用来比较<strong>某些特征</strong>是否一样，本质上就是 == ，只不过String和Integer等重写了equals方法，把它变成了值比较。<br>首先看默认情况下equals比较一个有相同值的对象，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Cat &#123;</span><br><span class="line">    public Cat(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private String name;</span><br><span class="line"> </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Cat c1 = new Cat(&quot;王磊&quot;);</span><br><span class="line">Cat c2 = new Cat(&quot;王磊&quot;);</span><br><span class="line">System.out.println(c1.equals(c2)); // false</span><br></pre></td></tr></table></figure></li></ul><p>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">        return (this == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来 equals 本质上就是 ==。<br>那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = new String(&quot;老王&quot;);</span><br><span class="line">String s2 = new String(&quot;老王&quot;);</span><br><span class="line">System.out.println(s1.equals(s2)); // true</span><br></pre></td></tr></table></figure><p>同样的，当我们进入 String 的 equals方法，找到了答案，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">        if (this == anObject) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (anObject instanceof String) &#123;</span><br><span class="line">            String anotherString = (String)anObject;</span><br><span class="line">            int n = value.length;</span><br><span class="line">            if (n == anotherString.value.length) &#123;</span><br><span class="line">                char v1[] = value;</span><br><span class="line">                char v2[] = anotherString.value;</span><br><span class="line">                int i = 0;</span><br><span class="line">                while (n-- != 0) &#123;</span><br><span class="line">                    if (v1[i] != v2[i])</span><br><span class="line">                        return false;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。<br><strong>总结：</strong> == 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重写了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p><h3 id="String、StringBuffer和StringBuilder区别"><a href="#String、StringBuffer和StringBuilder区别" class="headerlink" title="String、StringBuffer和StringBuilder区别"></a>String、StringBuffer和StringBuilder区别</h3><ul><li><p>数据可变和不可变</p><ul><li>String底层使用一个不可变的字符数组<code>private final char value[]</code>，所以它的内容不可变</li><li>StringBuffer和StringBuilder都继承了AbstractStringBuilder底层使用的是可变字符数组：<code>char[] value;</code></li></ul></li><li><p>线程安全性</p><ul><li>StringBulider是线程不安全的，效率较高；而StringBuffer是线程安全的，效率较低；<br>通过他们的append()方法来看，SpringBuffer是有同步锁，而StringBuilder没有：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public synchronized StringBuffer append(Object obj) &#123;</span><br><span class="line">    toStringCache = null;</span><br><span class="line">    super.append(String.valueOf(obj));</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public StringBuilder append(String str) &#123;</span><br><span class="line">    super.append(str);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>相同点<br>StringBuilder与StringBuffer有公共父类AbstractBuilder；<br>最后，操作可变字符串速度：<strong>StringBuilder &gt; StringBuffer &gt; String</strong>。</p></li></ul><h3 id="两个对象的-hashCode-相同，则equals-也一定为true，对吗？"><a href="#两个对象的-hashCode-相同，则equals-也一定为true，对吗？" class="headerlink" title="两个对象的 hashCode()相同，则equals()也一定为true，对吗？"></a>两个对象的 hashCode()相同，则equals()也一定为true，对吗？</h3><p>不对，两个对象的HashCode()相同，equals()不一定true。<br>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;通话&quot;;</span><br><span class="line">String str2 = &quot;重地&quot;;</span><br><span class="line">System. out. println(String. format(&quot;str1：%d | str2：%d&quot;,  str1. hashCode(),str2. hashCode()));</span><br><span class="line">System. out. println(str1. equals(str2));</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1：1179395 | str2：1179395</span><br><span class="line"> </span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p><h3 id="两个对象值相同-x-equals-y-true-，Hashcode是否一定相同"><a href="#两个对象值相同-x-equals-y-true-，Hashcode是否一定相同" class="headerlink" title="两个对象值相同(x.equals(y)==true)，Hashcode是否一定相同"></a>两个对象值相同(x.equals(y)==true)，Hashcode是否一定相同</h3><p>第一种情况：假如这个类没有重写equals方法，如果两个对象值相同，那么他们的hashCode值一定相同；<br>第二种情况：如果重写了equals方法，但没有重写hashCode方法，就会出现不相等的情况。<br><strong>Java对于equals方法和hashCode方法的规定</strong></p><ol><li>如果两个对象相同，那么他们的hashCode值一定要相同；</li><li>如果两个对象的hashCode相同，他们并不一定相同（这里说的对象相同指的是用equals方法比较）；</li><li>equals()相等的两个对象，hashCode()一定相等；equals()不相等的两个对象，却并不能证明他们的hashCode()不相等。<br>换句话说，equals()方法不相等的两个对象，hashCode()有可能相等（我的理解是由于哈希码在生成的时候产生冲突造成的）。反过来，hashCode()不等，一定能推出equals()也不等；hashCode()相等，equals()可能相等，也可能不等。</li></ol><h3 id="什么时候需要重写equals方法和hashCode方法"><a href="#什么时候需要重写equals方法和hashCode方法" class="headerlink" title="什么时候需要重写equals方法和hashCode方法"></a>什么时候需要重写equals方法和hashCode方法</h3><p>如果想完整的使用HashSet类(或TreeSet等)，最少需要重写equals()和hashCode()方法</p><ol><li>重写hashCode()用于获得元素的存储位置；</li><li>重写equals()用于在两个元素的位置相同的时候，比较两个元素是否相等。<br>分析原因如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hashCode </span><br><span class="line">        public int hashCode()返回该对象的哈希码值。支持此方法是为了提高哈希表（例如 Java.util.Hashtable 提供的哈希表）的性能。</span><br><span class="line">        hashCode 的常规协定是： </span><br><span class="line">        在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。 </span><br><span class="line">        如果根据 equals(Object) 方法，两个对象是相等的，那么对这两个对象中的每个对象调用 hashCode 方法都必须生成相同的整数结果。 </span><br><span class="line">        如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么对这两个对象中的任一对象上调用 hashCode 方法不 要求一定生成不同的整数结果。但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能。 </span><br><span class="line">        实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。）</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">equals </span><br><span class="line">public boolean equals(Object obj)指示其他某个对象是否与此对象“相等”。 </span><br><span class="line">equals 方法在非空对象引用上实现相等关系： </span><br><span class="line"></span><br><span class="line">自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true。 </span><br><span class="line">对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。 </span><br><span class="line">传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。 </span><br><span class="line">一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。 </span><br><span class="line">对于任何非空引用值 x，x.equals(null) 都应返回 false。 </span><br><span class="line">Object 类的 equals 方法实现对象上差别可能性最大的相等关系；即，对于任何非空引用值 x 和 y，当且仅当 x 和 y 引用同一个对象时，此方法才返回 true（x == y 具有值 true）。</span><br></pre></td></tr></table></figure><h3 id="final在Java中有什么作用"><a href="#final在Java中有什么作用" class="headerlink" title="final在Java中有什么作用"></a>final在Java中有什么作用</h3><ol><li>修饰类，则该类不能被继承；</li><li>修饰方法，则该方法不能被重写；</li><li>修饰变量，修饰的变量叫常量，必须初始化，且初始化后值不能被修改。</li></ol><h3 id="static和final区别"><a href="#static和final区别" class="headerlink" title="static和final区别"></a>static和final区别</h3><table>  <tr>    <th>关键词</th>    <th>修饰对象</th>    <th>影响</th>  </tr>  <tr>    <td rowspan="3">final</td>    <td>变量</td>    <td>分配到常量池中，程序不可改变其值</td>  </tr>  <tr>    <td>方法</td>    <td>子类中将不能被重写</td>  </tr>  <tr>    <td>类</td>    <td>不能被继承</td>  </tr>  <tr>    <td rowspan="3">static</td>    <td>变量</td>    <td>分配在<span style="color:rgb(253, 104, 100)">内存堆</span>上，引用都会指向这一地址而不会重新分配内存</td>  </tr>  <tr>    <td>方法块</td>    <td>虚拟机优先加载</td>  </tr>  <tr>    <td>类</td>    <td>可以直接通过类来调用而不需要new</td>  </tr></table><h3 id="引用类型占用几个字节"><a href="#引用类型占用几个字节" class="headerlink" title="引用类型占用几个字节"></a>引用类型占用几个字节</h3><p>hotspot VM在64位平台上占8个字节，在32平台上占4个字节</p><h3 id="1-lt-3-quot-a-quot-quot-b-quot-3-4和-1-lt-3-quot-a-quot-quot-b-quot-3-4-区别"><a href="#1-lt-3-quot-a-quot-quot-b-quot-3-4和-1-lt-3-quot-a-quot-quot-b-quot-3-4-区别" class="headerlink" title="(1&lt;3)?&quot;a&quot;:&quot;b&quot;)+3+4和(1&lt;3)?&quot;a&quot;:&quot;b&quot;)+(3+4)区别"></a><code>(1&lt;3)?&quot;a&quot;:&quot;b&quot;)+3+4</code>和<code>(1&lt;3)?&quot;a&quot;:&quot;b&quot;)+(3+4)</code>区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(((1&lt;3)?&quot;a&quot;:&quot;b&quot;)+3+4);</span><br><span class="line">System.out.println(((1&lt;3)?&quot;a&quot;:&quot;b&quot;)+(3+4));</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a34</span><br><span class="line">a7</span><br></pre></td></tr></table></figure><h3 id="4-amp-5-4-5-4-amp-10-gt-gt-1各等于多少"><a href="#4-amp-5-4-5-4-amp-10-gt-gt-1各等于多少" class="headerlink" title="4&amp;5 4^5 4&amp;10&gt;&gt;1各等于多少"></a><code>4&amp;5</code> <code>4^5</code> <code>4&amp;10&gt;&gt;1</code>各等于多少</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 0100 &amp; 0101 = 0100 = 4</span><br><span class="line">System.out.println(4&amp;5);</span><br><span class="line">// 0100 ^ 0101 = 0001 = 1</span><br><span class="line">System.out.println(4^5);</span><br><span class="line">System.out.println(10&gt;&gt;1);</span><br><span class="line"> // 有疑问参考下面的运算符优先级</span><br><span class="line">System.out.println(4&amp;10&gt;&gt;1);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">5</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>同问 <code>4|5</code>等于多少呢<br>答案为5<br>Tip：<br>与运算符用符号“&amp;”表示，其使用规律如下：<br>两个操作数中位都为1，结果才为1，否则结果为0<br>或运算符用符号“|”表示，其运算规律如下：<br>两个位只要有一个为1，那么结果就是1，否则就为0<br>3&amp;4相当于0011&amp;0100，结果是0000，也就是0<br>4|5相当于0100|0101，结果是0101，也就是5<br>java的位运算符还有两个：<br>非运算符用符号“~”表示，其运算规律如下：<br>如果位为0，结果是1，如果位为1，结果是0<br>异或运算符是用符号“^”表示的，其运算规律是：<br>两个操作数的位中，相同则结果为0，不同则结果为1</p><p>运算符优先级</p><table><thead><tr><th>运算符</th><th>结合性</th></tr></thead><tbody><tr><td>[ ] . ( ) (方法调用)</td><td>从左向右</td></tr><tr><td>! ~ ++ – +(一元运算) -(一元运算)</td><td>从右向左</td></tr><tr><td>* / %</td><td>从左向右</td></tr><tr><td>+ -</td><td>从左向右</td></tr><tr><td>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</td><td>从左向右</td></tr><tr><td>&lt; &lt;= &gt; &gt;= instanceof</td><td>从左向右</td></tr><tr><td>== !=</td><td>从左向右</td></tr><tr><td>&amp;</td><td>从左向右</td></tr><tr><td>^</td><td>从左向右</td></tr><tr><td>|</td><td>从左向右</td></tr><tr><td>&amp;&amp;</td><td>从左向右</td></tr><tr><td>||</td><td>从左向右</td></tr><tr><td>?:</td><td>从右向左</td></tr><tr><td>=</td><td>从右向左</td></tr></tbody></table><h3 id="Java中-Math-round-1-5-等于多少？Math-round-2-5-等于多少？"><a href="#Java中-Math-round-1-5-等于多少？Math-round-2-5-等于多少？" class="headerlink" title="Java中 Math.round(-1.5)等于多少？Math.round(-2.5)等于多少？"></a>Java中 Math.round(-1.5)等于多少？Math.round(-2.5)等于多少？</h3><p>答案：-1，-2<br>注意：不要认为它是四舍五入<br>计算口诀：+0.5后向下取整即可<br>同理Math.round(-2.6)结果和Math.round(2.6)结果分别为-3，3</p><h3 id="抽象类必须要有抽象方法吗？"><a href="#抽象类必须要有抽象方法吗？" class="headerlink" title="抽象类必须要有抽象方法吗？"></a>抽象类必须要有抽象方法吗？</h3><p>不需要，抽象类不一定非要抽象方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abstract class Cat &#123;</span><br><span class="line">        public static void sayHi() &#123;</span><br><span class="line">            System. out. println(&quot;hi~&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="普通类和抽象类有哪些区别"><a href="#普通类和抽象类有哪些区别" class="headerlink" title="普通类和抽象类有哪些区别"></a>普通类和抽象类有哪些区别</h3><p>普通类不能包含抽象方法，抽象类可以包含抽象方法<br>抽象类不能直接实例化，普通类可以直接实例化</p><h3 id="抽象类能使用final修饰吗"><a href="#抽象类能使用final修饰吗" class="headerlink" title="抽象类能使用final修饰吗"></a>抽象类能使用final修饰吗</h3><p>不能，定义抽象类就是让其他类继承的，如果定义为final该类就不能被继承，这样彼此就会产生矛盾，所以final不能修饰抽象类。</p><h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><ul><li>实现：抽象类的子类使用extends来继承；接口必须使用implements来实现接口；</li><li>构造函数：抽象类有构造函数；接口不能有；</li><li>实现数量：类可以实现多个接口，但是只能继承一个抽象类；</li><li>访问修饰符：抽象类中的抽象方法(其前有abstract修饰)不能用private、static、synchronized、native访问修饰符修饰；接口中的方法默认使用 public 修饰，接口是一种特殊的抽象类，接口中的方法全部是抽象方法（但其前的abstract可以省略），所以抽象类中的抽象方法不能用的访问修饰符这里也不能用，而且protected访问修饰符也不能使用。</li></ul><h3 id="Java中IO流分为几种"><a href="#Java中IO流分为几种" class="headerlink" title="Java中IO流分为几种"></a>Java中IO流分为几种</h3><ul><li>按功能分：输入流（input）、输出流（output）</li><li>按类型分：字节流和字符流<br>  字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</li></ul><h3 id="BIO、NIO和AIO区别"><a href="#BIO、NIO和AIO区别" class="headerlink" title="BIO、NIO和AIO区别"></a>BIO、NIO和AIO区别</h3><ul><li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li><li>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li><li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li></ul><h3 id="Files常用方法有哪些"><a href="#Files常用方法有哪些" class="headerlink" title="Files常用方法有哪些"></a>Files常用方法有哪些</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Files. exists()：检测文件路径是否存在。</span><br><span class="line">Files. createFile()：创建文件。</span><br><span class="line">Files. createDirectory()：创建文件夹。</span><br><span class="line">Files. delete()：删除一个文件或目录。</span><br><span class="line">Files. copy()：复制文件。</span><br><span class="line">Files. move()：移动文件。</span><br><span class="line">Files. size()：查看文件个数。</span><br><span class="line">Files. read()：读取文件。</span><br><span class="line">Files. write()：写入文件。</span><br></pre></td></tr></table></figure><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="Java容器都有哪些"><a href="#Java容器都有哪些" class="headerlink" title="Java容器都有哪些"></a>Java容器都有哪些</h3><p>Java容器分为Collection和Map两大类，其下又有很多子类，如下所示：</p><ul><li>Collection<ul><li>List<ul><li>ArrayList</li><li>LinkedList</li><li>Vector</li><li>Stack</li></ul></li><li>Set<ul><li>HashSet</li><li>LinkedHashSet</li><li>TreeSet</li></ul></li></ul></li><li>Map<ul><li>HashMap<ul><li>LinkedHashMap</li></ul></li><li>TreeMap</li><li>ConcurrentHashMap</li><li>Hashtable</li></ul></li></ul><h3 id="简述Java中的集合"><a href="#简述Java中的集合" class="headerlink" title="简述Java中的集合"></a>简述Java中的集合</h3><ul><li>Collection下：List系（有序、元素允许重复）和Set系（无序、元素不重复）<br>  set根据equals和hashCode判断，一个对象要存储在Set中，必须重写equals和hashCode方法。</li><li>Map下：HashMap线程不同步；TreeMap线程同步；</li><li>Collection系列和Map系列：Map是对Colleciton的补充，两者没什么关系。</li></ul><h3 id="List、Set、Map之间的区别"><a href="#List、Set、Map之间的区别" class="headerlink" title="List、Set、Map之间的区别"></a>List、Set、Map之间的区别</h3><p>List、Set、Map之间的区别主要体现在两个方面：元素是否有序、是否允许元素重复<br>三者间的区别，如表所示：</p><table>  <tr>    <th></th>    <th></th>    <th>元素有序</th>    <th>允许元素重复</th>  </tr>  <tr>    <td colspan="2">List</td>    <td>是</td>    <td>是</td>  </tr>  <tr>    <td rowspan="3">Set</td>    <td>AbstractSet</td>    <td rowspan="2">否</td>    <td rowspan="3">否</td>  </tr>  <tr>    <td>HashSet</td>  </tr>  <tr>    <td>TreeSet</td>    <td>是（用二叉树排序）</td>  </tr>  <tr>    <td rowspan="3">Map</td>    <td>AbstractMap</td>    <td rowspan="2">否</td>    <td rowspan="3">key值必须唯一<br>value值可重复</td>  </tr>  <tr>    <td>HashMap</td>  </tr>  <tr>    <td>TreeMap</td>    <td>是（用二叉树排序）</td>  </tr></table><h3 id="HashMap、HashTable和ConcurrentHashMap区别"><a href="#HashMap、HashTable和ConcurrentHashMap区别" class="headerlink" title="HashMap、HashTable和ConcurrentHashMap区别"></a>HashMap、HashTable和ConcurrentHashMap区别</h3><p>相同点：<br>    1. HashMap和HashTable都实现了Map接口<br>    2. 都可以存储key-value数据<br>不同点：<br>    1. HashMap可以把null作为key或者value,HashTable不可以<br>    2. HashMap线程不安全，效率高，HashTable线程安全，效率低<br>    3. HashMap迭代器(Iterator)是fail-fast迭代器，而HashTable的enumerator迭代器不是fail-fast的<br>    什么是fail-fast?<br>      就是最快的时间能把错误抛出而不是让程序执行<br>    4. Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</p><h4 id="如何保证线程安全又效率高"><a href="#如何保证线程安全又效率高" class="headerlink" title="如何保证线程安全又效率高"></a>如何保证线程安全又效率高</h4><p>Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。ConcurrentHashMap将整个Map分为N个segment(类似HashTable)，可以提供相同的线程安全，但是效率提升N倍，默认N为16。</p><h4 id="我们能否让HashMap同步"><a href="#我们能否让HashMap同步" class="headerlink" title="我们能否让HashMap同步"></a>我们能否让HashMap同步</h4><p>HashMap可以通过下面语句进行同步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map m = Collections.synchronizeMap(hashMap);</span><br></pre></td></tr></table></figure><h3 id="如何决定使用HashMap还是TreeMap"><a href="#如何决定使用HashMap还是TreeMap" class="headerlink" title="如何决定使用HashMap还是TreeMap"></a>如何决定使用HashMap还是TreeMap</h3><p>对于在 Map 中插入、删除、定位一个元素这类操作，HashMap是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。</p><h3 id="说一下-HashMap-的实现原理"><a href="#说一下-HashMap-的实现原理" class="headerlink" title="说一下 HashMap 的实现原理"></a>说一下 HashMap 的实现原理</h3><p>HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。</p><p>关于HashMap的一些更多总结可见博客 <a href="https://www.cnblogs.com/heqiyoujing/p/11143298.html" target="_blank" rel="noopener">https://www.cnblogs.com/heqiyoujing/p/11143298.html</a><br>红黑树相关知识点可以看这一篇 <a href="https://www.cnblogs.com/xuxinstyle/p/9556998.html" target="_blank" rel="noopener">https://www.cnblogs.com/xuxinstyle/p/9556998.html</a></p><h3 id="说一下-HashSet-的实现原理"><a href="#说一下-HashSet-的实现原理" class="headerlink" title="说一下 HashSet 的实现原理"></a>说一下 HashSet 的实现原理</h3><p>HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，<strong>HashSet 不允许重复的值</strong>。</p><h3 id="ArrayList-和-LinkdList-区别"><a href="#ArrayList-和-LinkdList-区别" class="headerlink" title="ArrayList 和 LinkdList 区别"></a>ArrayList 和 LinkdList 区别</h3><ol><li>ArrayList的实现基于<strong>动态数组</strong>的数据结构，LinkedList基于<strong>链表</strong>的数据结构；</li><li>对于随机访问get和set，ArrayList优于LinkedList，因为LinkedList需要移动指针；</li><li>对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。<br>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</li></ol><h3 id="如何实现数组和-List-之间的转换"><a href="#如何实现数组和-List-之间的转换" class="headerlink" title="如何实现数组和 List 之间的转换"></a>如何实现数组和 List 之间的转换</h3><p>数组转 List：使用 Arrays. asList(array) 进行转换；<br>List 转数组：使用 List 自带的 toArray() 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// list to array</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">list. add(&quot;王磊&quot;);</span><br><span class="line">list. add(&quot;的博客&quot;);</span><br><span class="line">list. toArray();</span><br><span class="line">// array to list</span><br><span class="line">String[] array = new String[]&#123;&quot;王磊&quot;,&quot;的博客&quot;&#125;;</span><br><span class="line">Arrays. asList(array);</span><br></pre></td></tr></table></figure><h3 id="ArrayList-和-Vector-的区别"><a href="#ArrayList-和-Vector-的区别" class="headerlink" title="ArrayList 和 Vector 的区别"></a>ArrayList 和 Vector 的区别</h3><p>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的<br>性能：ArrayList 在性能方面要优于 Vector<br>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%</p><h3 id="Array-和-ArrayList-有何区别"><a href="#Array-和-ArrayList-有何区别" class="headerlink" title="Array 和 ArrayList 有何区别"></a>Array 和 ArrayList 有何区别</h3><p>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象;<br>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的;<br>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</p><h3 id="在-Queue-中-poll-和-remove-有什么区别"><a href="#在-Queue-中-poll-和-remove-有什么区别" class="headerlink" title="在 Queue 中 poll()和 remove()有什么区别"></a>在 Queue 中 poll()和 remove()有什么区别</h3><p>相同点：都是返回第一个元素，并在队列中删除返回的对象<br>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常<br>tip:</p><ol><li>queue的增加元素方法add和offer的区别在于，add方法在队列满的情况下将选择抛异常的方法来表示队列已经满了，而offer方法通过返回false表示队列已经满了；在有限队列的情况，使用offer方法优于add方法；</li><li>remove方法和poll方法都是删除队列的头元素，remove方法在队列为空的情况下将抛异常，而poll方法将返回null；</li><li>element和peek方法都是返回队列的头元素，但是不删除头元素，区别在与element方法在队列为空的情况下，将抛异常，而peek方法将返回null.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();</span><br><span class="line">queue. offer(&quot;string&quot;); // add</span><br><span class="line">System. out. println(queue. poll());</span><br><span class="line">System. out. println(queue. remove());</span><br><span class="line">System. out. println(queue. size());</span><br></pre></td></tr></table></figure></li></ol><h3 id="哪些集合类是线程安全的"><a href="#哪些集合类是线程安全的" class="headerlink" title="哪些集合类是线程安全的"></a>哪些集合类是线程安全的</h3><p>Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK 1.5 之后随着 Java. util. concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。</p><h3 id="迭代器-Iterator-是什么"><a href="#迭代器-Iterator-是什么" class="headerlink" title="迭代器 Iterator 是什么"></a>迭代器 Iterator 是什么</h3><p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p><h3 id="Iterator-怎么使用？有什么特点？"><a href="#Iterator-怎么使用？有什么特点？" class="headerlink" title="Iterator 怎么使用？有什么特点？"></a>Iterator 怎么使用？有什么特点？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; it = list. iterator();</span><br><span class="line">while(it. hasNext())&#123;</span><br><span class="line">  String obj = it. next();</span><br><span class="line">  System. out. println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p><h3 id="ConcurrentModificationException异常出现的原因"><a href="#ConcurrentModificationException异常出现的原因" class="headerlink" title="ConcurrentModificationException异常出现的原因"></a>ConcurrentModificationException异常出现的原因</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        list.add(2);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">        while(iterator.hasNext())&#123;</span><br><span class="line">            Integer integer = iterator.next();</span><br><span class="line">            if(integer==2)</span><br><span class="line">                list.remove(integer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上段代码是有问题的，会抛出ConcurrentModificationException异常。<br>原因：调用list.remove()方法导致modCount和expectedModCount的值不一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final void checkForComodification() &#123;</span><br><span class="line">    if (modCount != expectedModCount)</span><br><span class="line">    throw new ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决办法：在迭代器中如果要删除元素的话，需要调用Iterator类的remove方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        list.add(2);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">        while(iterator.hasNext())&#123;</span><br><span class="line">            Integer integer = iterator.next();</span><br><span class="line">            if(integer==2)</span><br><span class="line">                iterator.remove();   //注意这个地方</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="怎么确保一个集合不能被修改"><a href="#怎么确保一个集合不能被修改" class="headerlink" title="怎么确保一个集合不能被修改"></a>怎么确保一个集合不能被修改</h3><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来<strong>创建一个只读集合</strong>，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list. add(&quot;x&quot;);</span><br><span class="line">Collection&lt;String&gt; clist = Collections. unmodifiableCollection(list);</span><br><span class="line">clist. add(&quot;y&quot;); // 运行时此行报错</span><br><span class="line">System. out. println(list. size());</span><br></pre></td></tr></table></figure><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="并行和并发有什么区别"><a href="#并行和并发有什么区别" class="headerlink" title="并行和并发有什么区别"></a>并行和并发有什么区别</h3><ul><li>并行：多个处理器或多核处理器同时处理多个任务。</li><li>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。</li></ul><h3 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h3><p>一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</p><h3 id="守护线程是什么"><a href="#守护线程是什么" class="headerlink" title="守护线程是什么"></a>守护线程是什么</h3><p>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。</p><h3 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h3><p>常见回答</p><ul><li>继承 Thread 重写 run 方法；</li><li>实现 Runnable 接口；</li><li>实现 Callable 接口。</li></ul><p>下面做个较为全面的总结：</p><ol><li>继承Trhead类，作为线程对象存在（继承Thread对象）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class CreatThreadDemo1 extends Thread&#123;</span><br><span class="line">    /**</span><br><span class="line">     * 构造方法： 继承父类方法的Thread(String name)；方法</span><br><span class="line">     * @param name</span><br><span class="line">     */</span><br><span class="line">    public CreatThreadDemo1(String name)&#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (!interrupted())&#123;</span><br><span class="line">            System.out.println(getName()+&quot;线程执行了...&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(200);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CreatThreadDemo1 d1 = new CreatThreadDemo1(&quot;first&quot;);</span><br><span class="line">        CreatThreadDemo1 d2 = new CreatThreadDemo1(&quot;second&quot;);</span><br><span class="line"></span><br><span class="line">        d1.start();</span><br><span class="line">        d2.start();</span><br><span class="line"></span><br><span class="line">        d1.interrupt();  //中断第一个线程</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>常规方法，不多做介绍了，interrupted方法，是来判断该线程是否被中断。（终止线程不允许用stop方法，该方法不会施放占用的资源。所以我们在设计程序的时候，要按照中断线程的思维去设计，就像上面的代码一样）。</p><pre><code>* 让线程等待的方法Thread.sleep(200);//线程休息2msObject.wait();//让线程进入等待，直到调用Object的notify或者notifyAll，线程停止休眠</code></pre><ol start="2"><li>实现runnable接口，作为线程任务存在<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class CreatThreadDemo2 implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            System.out.println(&quot;线程执行了...&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //将线程任务传给线程对象</span><br><span class="line">        Thread thread = new Thread(new CreatThreadDemo2());</span><br><span class="line">        //启动线程</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>Runnable 只是来修饰线程所执行的任务，它不是一个线程对象。想要启动Runnable对象，必须将它放到一个线程对象里。</p><ol start="3"><li>匿名内部类创建线程对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class CreatThreadDemo3 extends Thread&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建无参线程对象</span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;线程执行了...&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">       //创建带线程任务的线程对象</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;线程执行了...&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        //创建带线程任务并且重写run方法的线程对象</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;runnable run 线程执行了...&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;override run 线程执行了...&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>创建带线程任务并且重写run方法的线程对象中，为什么只运行了Thread的run方法。通过查看Thread类的源码，我们可以看到Thread实现了Runnable接口，而Runnable接口里有一个run方法。所以，我们最终调用的重写的方法应该是Thread类的run方法。而不是Runnable接口的run方法。</p><ol start="4"><li>创建带返回值的线程（实现Callable接口）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class CreatThreadDemo4 implements Callable &#123;</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        CreatThreadDemo4 demo4 = new CreatThreadDemo4();</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;Integer&gt; task = new FutureTask&lt;Integer&gt;(demo4); //FutureTask最终实现的是runnable接口</span><br><span class="line"></span><br><span class="line">        Thread thread = new Thread(task);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;我可以在这里做点别的业务逻辑...因为FutureTask是提前完成任务&quot;);</span><br><span class="line">        //拿出线程执行的返回值</span><br><span class="line">        Integer result = task.get();</span><br><span class="line">        System.out.println(&quot;线程中运算的结果为:&quot;+result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //重写Callable接口的call方法</span><br><span class="line">    @Override</span><br><span class="line">    public Object call() throws Exception &#123;</span><br><span class="line">        int result = 1;</span><br><span class="line">        System.out.println(&quot;业务逻辑计算中...&quot;);</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>Callable接口介绍：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Computes a result, or throws an exception if unable to do so.</span><br><span class="line">     *</span><br><span class="line">     * @return computed result</span><br><span class="line">     * @throws Exception if unable to compute a result</span><br><span class="line">     */</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回指定泛型的call方法。然后调用FutureTask对象的get方法得到call方法的返回值。</p><ol start="5"><li><p>定时器Timer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class CreatThreadDemo5 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Timer timer = new Timer();</span><br><span class="line"></span><br><span class="line">        timer.schedule(new TimerTask() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;定时器线程执行了...&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,0,1000);   //延迟0，周期1s</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>线程池创建线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class CreatThreadDemo6 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建一个具有10个线程的线程池</span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(10);</span><br><span class="line">        long threadpoolUseTime = System.currentTimeMillis();</span><br><span class="line">        for (int i = 0;i&lt;10;i++)&#123;</span><br><span class="line">            threadPool.execute(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot;线程执行了...&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        long threadpoolUseTime1 = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;多线程用时&quot;+(threadpoolUseTime1-threadpoolUseTime));</span><br><span class="line">        //销毁线程池</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        threadpoolUseTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用java8新特性stream实现并发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class CreatThreadDemo7 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Integer&gt; values = Arrays.asList(10,20,30,40);</span><br><span class="line">        //parallel 平行的，并行的</span><br><span class="line">        int result = values.parallelStream().mapToInt(p -&gt; p*2).sum();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        //怎么证明它是并发处理呢</span><br><span class="line">        values.parallelStream().forEach(p-&gt; System.out.println(p));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">200</span><br><span class="line">40</span><br><span class="line">10</span><br><span class="line">20</span><br><span class="line">30</span><br></pre></td></tr></table></figure><h3 id="说一下runnable和callable区别"><a href="#说一下runnable和callable区别" class="headerlink" title="说一下runnable和callable区别"></a>说一下runnable和callable区别</h3><p>runnable 没有返回值，callable 可以拿到有返回值，callable 可以看作是 runnable 的补充。</p><h3 id="线程有哪些状态"><a href="#线程有哪些状态" class="headerlink" title="线程有哪些状态"></a>线程有哪些状态</h3><p>线程的状态：</p><ul><li>NEW 尚未启动</li><li>RUNNABLE 正在执行中</li><li>BLOCKED 阻塞的（被同步锁或者IO锁阻塞）</li><li>WAITING 永久等待状态</li><li>TIMED_WAITING 等待指定的时间重新被唤醒的状态</li><li>TERMINATED 执行完成</li></ul><h3 id="sleep-和-wait-有什么区别"><a href="#sleep-和-wait-有什么区别" class="headerlink" title="sleep() 和 wait() 有什么区别"></a>sleep() 和 wait() 有什么区别</h3><ul><li>类的不同：sleep() 来自 Thread，wait() 来自 Object。</li><li>释放锁：sleep() 不释放锁；wait() 释放锁。</li><li>用法不同：sleep() 时间到会自动恢复；wait() 可以使用notify()/notifyAll()直接唤醒。</li></ul><h3 id="notify-和-notifyAll-有什么区别"><a href="#notify-和-notifyAll-有什么区别" class="headerlink" title="notify()和 notifyAll()有什么区别"></a>notify()和 notifyAll()有什么区别</h3><p>notifyAll()会唤醒所有的线程，notify()只唤醒一个线程。notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</p><h3 id="线程的-run-和-start-有什么区别"><a href="#线程的-run-和-start-有什么区别" class="headerlink" title="线程的 run() 和 start() 有什么区别"></a>线程的 run() 和 start() 有什么区别</h3><p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</p><h3 id="创建线程池有哪几种方式？"><a href="#创建线程池有哪几种方式？" class="headerlink" title="创建线程池有哪几种方式？"></a>创建线程池有哪几种方式？</h3><p>线程池创建有七种方式，最核心的是最后一种：</p><ul><li>newSingleThreadExecutor()：它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；</li><li>newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过  60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；</li><li>newFixedThreadPool(int  nThreads)：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads  个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目  nThreads；</li><li>newSingleThreadScheduledExecutor()：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；</li><li>newScheduledThreadPool(int  corePoolSize)：和newSingleThreadScheduledExecutor()类似，创建的是个  ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；</li><li>newWorkStealingPool(int parallelism)：这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；</li><li>ThreadPoolExecutor()：是最原始的线程池创建，上面1-3创建方式都是对ThreadPoolExecutor的封装。</li></ul><p>常用为Executors提供的四种方法来创建线程池：</p><ol><li><p>newFixedThreadPool() :创建固定大小的线程池。</p></li><li><p>newCachedThreadPool(): 创建无限大小的线程池，线程池中线程数量不固定，可根据需求自动更改。</p></li><li><p>newSingleThreadPool() : 创建单个线程池，线程池中只有一个线程。</p></li><li><p>newScheduledThreadPool(): 创建固定大小的线程池，可以延迟或定时的执行任务。<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ExecutorService threadPool = Executors.newCachedThreadPool();</span><br><span class="line">    threadPool.execute(() -&gt; &#123;</span><br><span class="line">        for (int i = 0; i&lt; 20;i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    threadPool.shutdown();</span><br></pre></td></tr></table></figure><p> 线程池作用<br> 限制线程个数，避免线程过多导致系统运行缓慢或崩溃。<br> 不需要频繁的创建和销毁，节约资源、响应更快。</p></li></ol><h3 id="线程池都有哪些状态？"><a href="#线程池都有哪些状态？" class="headerlink" title="线程池都有哪些状态？"></a>线程池都有哪些状态？</h3><ul><li>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。</li><li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。</li><li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</li><li>TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。</li><li>TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</li></ul><h3 id="线程池中-submit-和-execute-方法有什么区别？"><a href="#线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="线程池中 submit() 和 execute() 方法有什么区别？"></a>线程池中 submit() 和 execute() 方法有什么区别？</h3><ul><li>execute()：只能执行 Runnable 类型的任务。</li><li>submit()：可以执行 Runnable 和 Callable 类型的任务。</li></ul><p>Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。</p><h3 id="在-Java-程序中怎么保证多线程的运行安全"><a href="#在-Java-程序中怎么保证多线程的运行安全" class="headerlink" title="在 Java 程序中怎么保证多线程的运行安全"></a>在 Java 程序中怎么保证多线程的运行安全</h3><ul><li>方法一：使用安全类，比如 Java. util. concurrent 下的类。</li><li>方法二：使用自动锁 synchronized。</li><li>方法三：使用手动锁 Lock。</li></ul><p>手动锁 Java 示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line">lock. lock();</span><br><span class="line">try &#123;</span><br><span class="line">    System. out. println(&quot;获得锁&quot;);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    // TODO: handle exception</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    System. out. println(&quot;释放锁&quot;);</span><br><span class="line">    lock. unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程中-synchronized-锁升级的原理是什么"><a href="#多线程中-synchronized-锁升级的原理是什么" class="headerlink" title="多线程中 synchronized 锁升级的原理是什么"></a>多线程中 synchronized 锁升级的原理是什么</h3><p>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p><p>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p><h3 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h3><p>当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p><h3 id="怎么防止死锁？"><a href="#怎么防止死锁？" class="headerlink" title="怎么防止死锁？"></a>怎么防止死锁？</h3><ul><li>尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。</li><li>尽量使用 Java. util. concurrent 并发类代替自己手写锁。</li><li>尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。</li><li>尽量减少同步的代码块</li></ul><h3 id="ThreadLocal-是什么？有哪些使用场景？"><a href="#ThreadLocal-是什么？有哪些使用场景？" class="headerlink" title="ThreadLocal 是什么？有哪些使用场景？"></a>ThreadLocal 是什么？有哪些使用场景？</h3><p>ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。<br>ThreadLocal 的经典使用场景是数据库连接和 session 管理等。</p><h3 id="说一下-synchronized-底层实现原理？"><a href="#说一下-synchronized-底层实现原理？" class="headerlink" title="说一下 synchronized 底层实现原理？"></a>说一下 synchronized 底层实现原理？</h3><p>synchronized 是由一对 monitorenter/monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在 Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能</p><h3 id="synchronized-和-volatile-的区别是什么？"><a href="#synchronized-和-volatile-的区别是什么？" class="headerlink" title="synchronized 和 volatile 的区别是什么？"></a>synchronized 和 volatile 的区别是什么？</h3><ul><li>volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。</li><li>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。</li><li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li></ul><h3 id="synchronized-和-Lock-有什么区别？"><a href="#synchronized-和-Lock-有什么区别？" class="headerlink" title="synchronized 和 Lock 有什么区别？"></a>synchronized 和 Lock 有什么区别？</h3><ul><li>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</li><li>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</li><li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li></ul><h3 id="synchronized-和-ReentrantLock-区别是什么？"><a href="#synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="synchronized 和 ReentrantLock 区别是什么？"></a>synchronized 和 ReentrantLock 区别是什么？</h3><p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进</p><p>主要区别如下：</p><ul><li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</li><li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li><li>ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。</li><li>volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。</li></ul><h3 id="说一下-atomic-的原理？"><a href="#说一下-atomic-的原理？" class="headerlink" title="说一下 atomic 的原理？"></a>说一下 atomic 的原理？</h3><p>atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><p>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p><h3 id="什么是-Java-序列化？什么情况下需要序列化？"><a href="#什么是-Java-序列化？什么情况下需要序列化？" class="headerlink" title="什么是 Java 序列化？什么情况下需要序列化？"></a>什么是 Java 序列化？什么情况下需要序列化？</h3><p>Java 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。<br>以下情况需要使用 Java 序列化：</p><ul><li>想把的内存中的对象状态保存到一个文件中或者数据库中时候；</li><li>想用套接字在网络上传送对象的时候；</li><li>想通过RMI（远程方法调用）传输对象的时候。</li></ul><h3 id="某些java类为什么要实现Serializable接口"><a href="#某些java类为什么要实现Serializable接口" class="headerlink" title="某些java类为什么要实现Serializable接口"></a>某些java类为什么要实现Serializable接口</h3><p>为了网络进行传输或者持久化</p><ul><li>除了实现Serializable接口还有什么序列化方式<ul><li>Json序列化</li><li>FastJson序列化</li><li>ProtoBuff序列化</li></ul></li></ul><h3 id="动态代理是什么？有哪些应用？"><a href="#动态代理是什么？有哪些应用？" class="headerlink" title="动态代理是什么？有哪些应用？"></a>动态代理是什么？有哪些应用？</h3><p>动态代理是运行时动态生成代理类。<br>动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端 mock、rpc，Java注解对象获取等。</p><h3 id="怎么实现动态代理？"><a href="#怎么实现动态代理？" class="headerlink" title="怎么实现动态代理？"></a>怎么实现动态代理？</h3><p>JDK 原生动态代理和 cglib 动态代理。JDK 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的。</p><h2 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h2><h3 id="为什么要使用克隆"><a href="#为什么要使用克隆" class="headerlink" title="为什么要使用克隆"></a>为什么要使用克隆</h3><p>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠克隆方法了。</p><h3 id="如何实现对象克隆"><a href="#如何实现对象克隆" class="headerlink" title="如何实现对象克隆"></a>如何实现对象克隆</h3><ul><li>实现 Cloneable 接口并重写 Object 类中的 clone() 方法。</li><li>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</li></ul><h3 id="深拷贝和浅拷贝区别是什么"><a href="#深拷贝和浅拷贝区别是什么" class="headerlink" title="深拷贝和浅拷贝区别是什么"></a>深拷贝和浅拷贝区别是什么</h3><ul><li>浅克隆：当对象被复制时只复制它本身和其中包含的值类型的成员变量，而<strong>引用类型</strong>的成员对象并没有复制。</li><li>深克隆：除了对象本身被复制外，对象所包含的所有成员变量也将复制</li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="throw-和-throws-的区别"><a href="#throw-和-throws-的区别" class="headerlink" title="throw 和 throws 的区别"></a>throw 和 throws 的区别</h3><ul><li>throw：是真实抛出一个异常。</li><li>throws：是声明可能会抛出一个异常。</li></ul><h3 id="final、finally、finalize-有什么区别？"><a href="#final、finally、finalize-有什么区别？" class="headerlink" title="final、finally、finalize 有什么区别？"></a>final、finally、finalize 有什么区别？</h3><ul><li>final：是修饰符，如果修饰类，此类不能被继承；如果修饰方法和变量，则表示此方法和此变量不能再被改变，只能使用。</li><li>finally：是 try{} catch{} finally{} 最后一部分，表示不论发生任何情况都会执行，finally 部分可以省略，但如果 finally 部分存在，则一定会执行 finally 里面的代码。</li><li>finalize： 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法。</li></ul><h3 id="try-catch-finally-中哪个部分可以省略"><a href="#try-catch-finally-中哪个部分可以省略" class="headerlink" title="try-catch-finally 中哪个部分可以省略"></a>try-catch-finally 中哪个部分可以省略</h3><p>try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。</p><h3 id="try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？"><a href="#try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？" class="headerlink" title="try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？"></a>try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h3><p>finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。</p><h3 id="常见的异常类有哪些？"><a href="#常见的异常类有哪些？" class="headerlink" title="常见的异常类有哪些？"></a>常见的异常类有哪些？</h3><ul><li>NullPointerException 空指针异常</li><li>ClassNotFoundException 指定类不存在</li><li>NumberFormatException 字符串转换为数字异常</li><li>IndexOutOfBoundsException 数组下标越界异常</li><li>ClassCastException 数据类型转换异常</li><li>FileNotFoundException 文件未找到异常</li><li>NoSuchMethodException 方法不存在异常</li><li>IOException IO 异常</li><li>SocketException Socket 异常</li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="说一下你熟悉的设计模式"><a href="#说一下你熟悉的设计模式" class="headerlink" title="说一下你熟悉的设计模式"></a>说一下你熟悉的设计模式</h3><ul><li>单例模式：保证被创建一次，节省系统开销。</li><li>工厂模式（简单工厂、抽象工厂）：解耦代码。</li><li>观察者模式：定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新。</li><li>外观模式：提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。</li><li>模版方法模式：定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。</li><li>状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</li></ul><h3 id="简单工厂、工程方法和抽象工厂有什么区别？"><a href="#简单工厂、工程方法和抽象工厂有什么区别？" class="headerlink" title="简单工厂、工程方法和抽象工厂有什么区别？"></a>简单工厂、工程方法和抽象工厂有什么区别？</h3><ul><li>简单工厂：用来生产同一等级结构中的任意产品，对于增加新的产品，无能为力。</li><li>工厂方法：用来生产同一等级结构中的固定产品，支持增加任意产品。</li><li>抽象工厂：用来生产不同产品族的全部产品，对于增加新的产品，无能为力；支持增加产品族。</li></ul><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="说一下-JVM-的主要组成部分？及其作用？"><a href="#说一下-JVM-的主要组成部分？及其作用？" class="headerlink" title="说一下 JVM 的主要组成部分？及其作用？"></a>说一下 JVM 的主要组成部分？及其作用？</h3><ul><li>类加载器（ClassLoader）</li><li>运行时数据区（Runtime Data Area）</li><li>执行引擎（Execution Engine）</li><li>本地库接口（Native Interface）</li></ul><p><strong>组件的作用：</strong> 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p><h3 id="说一下-JVM-运行时数据区？"><a href="#说一下-JVM-运行时数据区？" class="headerlink" title="说一下 JVM 运行时数据区？"></a>说一下 JVM 运行时数据区？</h3><p>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：</p><ul><li>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；</li><li>Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；</li><li>本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；</li><li>Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；</li><li>方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</li></ul><h3 id="说一下堆栈的区别？"><a href="#说一下堆栈的区别？" class="headerlink" title="说一下堆栈的区别？"></a>说一下堆栈的区别？</h3><ul><li>功能方面：堆是用来存放对象的，栈是用来执行程序的。</li><li>共享性：堆是线程共享的，栈是线程私有的。</li><li>空间大小：堆大小远远大于栈。</li></ul><h3 id="队列和栈是什么？有什么区别？"><a href="#队列和栈是什么？有什么区别？" class="headerlink" title="队列和栈是什么？有什么区别？"></a>队列和栈是什么？有什么区别？</h3><p>队列和栈都是被用来预存储数据的。</p><p>队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。</p><p>栈和队列很相似，但它运行对元素进行后进先出进行检索。</p><h3 id="说一下类装载的执行过程？"><a href="#说一下类装载的执行过程？" class="headerlink" title="说一下类装载的执行过程？"></a>说一下类装载的执行过程？</h3><p>类装载分为以下 5 个步骤：</p><ul><li>加载：根据查找路径找到相应的 class 文件然后导入；</li><li>检查：检查加载的 class 文件的正确性；</li><li>准备：给类中的静态变量分配内存空间；</li><li>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li><li>初始化：对静态变量和静态代码块执行初始化工作。</li></ul><h3 id="怎么判断对象是否可以被回收？"><a href="#怎么判断对象是否可以被回收？" class="headerlink" title="怎么判断对象是否可以被回收？"></a>怎么判断对象是否可以被回收？</h3><p>一般有两种方法来判断：</p><ul><li>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</li><li>可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</li></ul><h3 id="Java-中都有哪些引用类型？"><a href="#Java-中都有哪些引用类型？" class="headerlink" title="Java 中都有哪些引用类型？"></a>Java 中都有哪些引用类型？</h3><ul><li>强引用：发生 gc 的时候不会被回收。</li><li>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。</li><li>弱引用：有用但不是必须的对象，在下一次GC时会被回收。</li><li>虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。</li></ul><h3 id="JVM垃圾处理方法"><a href="#JVM垃圾处理方法" class="headerlink" title="JVM垃圾处理方法"></a>JVM垃圾处理方法</h3><ol><li>标记-清除算法（老年代）<br>该算法分为“标记”和“清除”两个阶段: 首先标记出所有需要回收的对象(可达性分析), 在标记完成后统一清理掉所有被标记的对象。<br><img src="/images/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.webp" alt="标记清除算法"><br>该算法会有两个问题：<ol><li>效率问题，标记和清除效率不高。</li><li>空间问题: 标记清除后会产生大量不连续的内存碎片, 空间碎片太多可能会导致在运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集。<br>所以它一般用于”垃圾不太多的区域，比如老年代”。</li></ol></li><li>复制算法（新生代）<br>该算法的核心是将可用内存按容量划分为大小相等的两块, 每次只用其中一块, 当这一块的内存用完, 就将还存活的对象（非垃圾）复制到另外一块上面, 然后把已使用过的内存空间一次清理掉。<br>优点：不用考虑碎片问题，方法简单高效。<br>缺点：内存浪费严重。</li></ol><p>现代商用VM的新生代均采用复制算法，但由于新生代中的98%的对象都是生存周期极短的，因此并不需完全按照1∶1的比例划分新生代空间，而是将新生代划分为一块较大的Eden区和两块较小的Survivor区(HotSpot默认Eden和Survivor的大小比例为8∶1), 每次只用Eden和其中一块Survivor。<br>当发生MinorGC时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor上， 最后清理掉Eden和刚才用过的Survivor的空间。当Survivor空间不够用(不足以保存尚存活的对象)时，需要依赖老年代进行空间分配担保机制，这部分内存直接进入老年代。<br><img src="/images/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.webp" alt="复制算法"><br><strong>复制算法的空间分配担保：</strong><br>在执行Minor GC前, VM会首先检查老年代是否有足够的空间存放新生代尚存活对象, 由于新生代使用复制收集算法, 为了提升内存利用率, 只使用了其中一个Survivor作为轮换备份, 因此当出现大量对象在Minor GC后仍然存活的情况时, 就需要老年代进行分配担保, 让Survivor无法容纳的对象直接进入老年代, 但前提是老年代需要有足够的空间容纳这些存活对象.<br>但存活对象的大小在实际完成GC前是无法明确知道的, 因此Minor GC前, VM会先首先检查老年代连续空间是否大于新生代对象总大小或历次晋升的平均大小, 如果条件成立, 则进行Minor GC, 否则进行Full GC(让老年代腾出更多空间).<br>然而取历次晋升的对象的平均大小也是有一定风险的, 如果某次Minor GC存活后的对象突增,远远高于平均值的话,依然可能导致担保失败(Handle Promotion Failure, 老年代也无法存放这些对象了), 此时就只好在失败后重新发起一次Full GC(让老年代腾出更多空间).</p><ol start="3"><li>标记-整理算法（老年代）<br>标记清除算法会产生内存碎片问题, 而复制算法需要有额外的内存担保空间, 于是针对老年代的特点, 又有了标记整理算法. 标记整理算法的标记过程与标记清除算法相同, 但后续步骤不再对可回收对象直接清理, 而是让所有存活的对象都向一端移动,然后清理掉端边界以外的内存。<br><img src="/images/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.webp" alt="标记整理算法"><br>简记：</li></ol><ul><li>标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。</li><li>标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</li><li>复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。</li><li>分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</li></ul><h3 id="说一下-JVM-有哪些垃圾回收器？"><a href="#说一下-JVM-有哪些垃圾回收器？" class="headerlink" title="说一下 JVM 有哪些垃圾回收器？"></a>说一下 JVM 有哪些垃圾回收器？</h3><ul><li>Serial：最早的单线程串行垃圾回收器。</li><li>Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。</li><li>ParNew：是 Serial 的多线程版本。</li><li>Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。</li><li>Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。</li><li>CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。</li><li>G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。</li></ul><h3 id="详细介绍一下-CMS-垃圾回收器？"><a href="#详细介绍一下-CMS-垃圾回收器？" class="headerlink" title="详细介绍一下 CMS 垃圾回收器？"></a>详细介绍一下 CMS 垃圾回收器？</h3><p>CMS 是英文 Concurrent Mark-Sweep  的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM  的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。</p><p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现  Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p><h3 id="新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"><a href="#新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？" class="headerlink" title="新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"></a>新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</h3><ul><li>新生代回收器：Serial、ParNew、Parallel Scavenge</li><li>老年代回收器：Serial Old、Parallel Old、CMS</li><li>整堆回收器：G1<br>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</li></ul><h3 id="新生代、老年代、持久代都存储哪些东西"><a href="#新生代、老年代、持久代都存储哪些东西" class="headerlink" title="新生代、老年代、持久代都存储哪些东西"></a>新生代、老年代、持久代都存储哪些东西</h3><ul><li>新生代：<br>方法中new一个对象，就会先进入新生代。</li><li>老年代：<br>新生代中经历了N次垃圾回收仍然存活的对象就会被放到老年代中。<br>大对象一般直接放入老年代。<br>当Survivor空间不足。需要老年代担保一些空间，也会将对象放入老年代。</li><li>永久代：<br>指的就是方法区。</li></ul><h3 id="可达性算法中，哪些对象可作为GC-Roots对象"><a href="#可达性算法中，哪些对象可作为GC-Roots对象" class="headerlink" title="可达性算法中，哪些对象可作为GC Roots对象"></a>可达性算法中，哪些对象可作为GC Roots对象</h3><ul><li>虚拟机栈中引用的对象</li><li>方法区静态成员引用的对象</li><li>方法区常量引用对象</li><li>本地方法栈JNI引用的对象</li></ul><h3 id="什么时候进行MinGC和FullGC"><a href="#什么时候进行MinGC和FullGC" class="headerlink" title="什么时候进行MinGC和FullGC"></a>什么时候进行MinGC和FullGC</h3><ul><li>MinGC:<br>当Eden区满时,触发Minor GC.</li><li>FullGC:<br>调用System.gc时，系统建议执行Full GC，但是不必然执行<br>老年代空间不足<br>方法区空间不足<br>通过Minor GC后进入老年代的平均大小大于老年代的剩余空间<br>堆中分配很大的对象，而老年代没有足够的空间</li></ul><h3 id="如何判定对象为垃圾对象"><a href="#如何判定对象为垃圾对象" class="headerlink" title="如何判定对象为垃圾对象"></a>如何判定对象为垃圾对象</h3><p>在堆里面存放着Java世界中几乎所有的对象实例, 垃圾收集器在对堆进行回收前, 第一件事就是判断哪些对象已死(可回收).</p><ul><li><strong>引用计数法</strong><br>在JDK1.2之前，使用的是引用计数器算法。<br>在对象中添加一个引用计数器，当有地方引用这个对象的时候，引用计数器的值就+1，当引用失效的时候，计数器的值就-1，当引用计数器被减为零的时候，标志着这个对象已经没有引用了，可以回收了！<br><img src="/images/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95.webp" alt="引用计数法"></li></ul><p><strong>问题：</strong>如果在A类中调用B类的方法，B类中调用A类的方法，这样当其他所有的引用都消失了之后，A和B还有一个相互的引用，也就是说两个对象的引用计数器各为1，而实际上这两个对象都已经没有额外的引用，已经是垃圾了。但是该算法并不会计算出该类型的垃圾。</p><ul><li><strong>可达性分析法</strong><br>在主流商用语言(如Java、C#)的主流实现中, 都是通过可达性分析算法来判定对象是否存活的: 通过一系列的称为 GC Roots 的对象作为起点, 然后向下搜索; 搜索所走过的路径称为引用链/Reference Chain, 当一个对象到 GC Roots 没有任何引用链相连时, 即该对象不可达, 也就说明此对象是不可用的, 如下图:虽然E和F相互关联， 但它们到GC Roots是不可达的, 因此也会被判定为可回收的对象。<br><img src="/images/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E6%B3%95.webp" alt="可达性分析法"></li></ul><p><strong>注:</strong>即使在可达性分析算法中不可达的对象, VM也并不是马上对其回收, 因为要真正宣告一个对象死亡, 至少要经历两次标记过程: 第一次是在可达性分析后发现没有与GC Roots相连接的引用链, 第二次是GC对在F-Queue执行队列中的对象进行的小规模标记(对象需要覆盖finalize()方法且没被调用过).</p><h3 id="你能说出来几个垃圾收集器"><a href="#你能说出来几个垃圾收集器" class="headerlink" title="你能说出来几个垃圾收集器"></a>你能说出来几个垃圾收集器</h3><ul><li><p><strong>Serial</strong><br>Serial收集器是Hotspot运行在Client模式下的<strong>默认新生代收集器</strong>, 它在进行垃圾收集时，会暂停所有的工作进程，用一个线程去完成GC工作<br><img src="/images/serial.webp" alt="serial"><br>特点：简单高效，适合jvm管理内存不大的情况（十兆到百兆）。</p></li><li><p>Parnew<br>ParNew收集器其实是Serial的多线程版本，回收策略完全一样，但是他们又有着不同。<br><img src="/images/parnew.webp" alt="parnew"><br>我们说了Parnew是多线程gc收集，所以它配合多核心的cpu效果更好，如果是一个cpu，他俩效果就差不多。（可用-XX:ParallelGCThreads参数控制GC线程数）</p></li><li><p>CMS<br>CMS(Concurrent Mark Sweep)收集器是一款具有划时代意义的收集器, 一款<strong>真正意义上的并发收集器</strong>, 虽然现在已经有了理论意义上表现更好的G1收集器, 但现在主流互联网企业线上选用的仍是CMS(如Taobao),又称多并发低暂停的收集器。<br><img src="/images/cms.webp" alt="cms"><br>由他的英文组成可以看出，它是基于标记-清除算法实现的。整个过程分4个步骤：</p><ol><li>初始标记(CMS initial mark):仅只标记一下GC Roots能直接关联到的对象, 速度很快</li><li>并发标记(CMS concurrent mark: GC Roots Tracing过程)</li><li>重新标记(CMS remark):修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录</li><li>并发清除(CMS concurrent sweep: 已死对象将会就地释放)<br>可以看到，初始标记、重新标记需要STW(stop the world 即：挂起用户线程)操作。因为最耗时的操作是并发标记和并发清除。所以总体上我们认为CMS的GC与用户线程是并发运行的。</li></ol></li></ul><p><strong>优点：</strong>并发收集、低停顿<br><strong>缺点：</strong></p><ol><li>CMS默认启动的回收线程数=(CPU数目+3)*4<br>当CPU数&gt;4时, GC线程最多占用不超过25%的CPU资源, 但是当CPU数&lt;=4时, GC线程可能就会过多的占用用户CPU资源, 从而导致应用程序变慢, 总吞吐量降低.</li><li>无法清除浮动垃圾（GC运行到并发清除阶段时用户线程产生的垃圾），因为用户线程是需要内存的，如果浮动垃圾施放不及时，很可能就造成内存溢出，所以CMS不能像别的垃圾收集器那样等老年代几乎满了才触发，CMS提供了参数-XX:CMSInitiatingOccupancyFraction来设置GC触发百分比(1.6后默认92%),当然我们还得设置启用该策略-XX:+UseCMSInitiatingOccupancyOnly</li><li>因为CMS采用标记-清除算法，所以可能会带来很多的碎片，如果碎片太多没有清理，jvm会因为无法分配大对象内存而触发GC，因此CMS提供了-XX:+UseCMSCompactAtFullCollection参数，它会在GC执行完后接着进行碎片整理，但是又会有个问题，碎片整理不能并发，所以必须单线程去处理，所以如果每次GC完都整理用户线程stop的时间累积会很长，所以XX:CMSFullGCsBeforeCompaction参数设置隔几次GC进行一次碎片整理（默认为0）。</li></ol><ul><li>G1<br>同优秀的CMS垃圾回收器一样，G1也是关注最小时延的垃圾回收器，也同样适合大尺寸堆内存的垃圾收集，官方也推荐使用G1来代替选择CMS。G1最大的特点是<strong>引入分区</strong>的思路，<strong>弱化分代</strong>的概念，合理利用垃圾收集各个周期的资源，解决了其他收集器甚至CMS的众多缺陷。<br><img src="/images/g1.webp" alt="g1"><br>因为每个区都有E、S、O代，所以在G1中，不需要对整个Eden等代进行回收，而是寻找可回收对象比较多的区，然后进行回收（虽然也需要STW操作，但是花费的时间是很少的），保证高效率。<br>新生代收集<br>G1的新生代收集跟ParNew类似，如果存活时间超过某个阈值，就会被转移到S/O区。<br>年轻代内存由一组不连续的heap区组成, 这种方法使得可以动态调整各代区域的大小<br>老年代收集<br>分为以下几个阶段：<ol><li>初始标记 (Initial Mark: Stop the World Event)<br>在G1中, 该操作附着一次年轻代GC, 以标记Survivor中有可能引用到老年代对象的Regions.</li><li>扫描根区域 (Root Region Scanning: 与应用程序并发执行)<br>扫描Survivor中能够引用到老年代的references. 但必须在Minor GC触发前执行完</li><li>并发标记 (Concurrent Marking : 与应用程序并发执行)<br>在整个堆中查找存活对象, 但该阶段可能会被Minor GC中断</li><li>重新标记 (Remark : Stop the World Event)<br>完成堆内存中存活对象的标记. 使用snapshot-at-the-beginning(SATB, 起始快照)算法, 比CMS所用算法要快得多(空Region直接被移除并回收, 并计算所有区域的活跃度).</li><li>清理 (Cleanup : Stop the World Event and Concurrent)<br>在含有存活对象和完全空闲的区域上进行统计(STW)、擦除Remembered Sets(使用Remembered Set来避免扫描全堆，每个区都有对应一个Set用来记录引用信息、读写操作记录)(STW)、重置空regions并将他们返还给空闲列表(free list)(Concurrent)</li></ol></li></ul><h3 id="JVM中对象的创建过程"><a href="#JVM中对象的创建过程" class="headerlink" title="JVM中对象的创建过程"></a>JVM中对象的创建过程</h3><ol><li>拿到内存创建指令<br>当虚拟机遇到内存创建的指令的时候（new 类名），来到了方法区，根据new的参数在常量池中定位一个类的符号引用。</li><li>检查符号引用<br>检查该符号引用有没有被加载、解析和初始化过，如果没有则执行类加载过程，否则直接准备为新的对象分配内存</li><li>分配内存<br>虚拟机为对象分配内存（堆）分配内存分为指针碰撞和空闲列表两种方式；分配内存还要要保证并发安全，有两种方式。<ul><li>指针碰撞<br>所有的存储空间分为两部分，一部分是空闲，一部分是占用，需要分配空间的时候，只需要计算指针移动的长度即可。</li><li>空闲列表<br>虚拟机维护了一个空闲列表，需要分配空间的时候去查该空闲列表进行分配并对空闲列表做更新。<br>可以看出，内存分配方式是由java堆是否规整决定的，java堆的规整是由垃圾回收机制来决定的<br>安全性问题的思考<br>假如分配内存策略是指针碰撞，如果在高并发情况下，多个对象需要分配内存，如果不做处理，肯定会出现线程安全问题，导致一些对象分配不到空间等。<br>下面是解决方案：</li><li>线程同步策略<br>也就是每个线程都进行同步，防止出现线程安全。</li><li>本地线程分配缓冲<br>也称TLAB（Thread Local Allocation Buffer），在堆中为每一个线程分配一小块独立的内存，这样以来就不存并发问题了，Java 层面与之对应的是 ThreadLocal 类的实现</li></ul></li><li>初始化<br>分配完内存后要对对象的头（Object Header）进行初始化，这新信息包括：该对象对应类的元数据、该对象的GC代、对象的哈希码。<br>抽象数据类型默认初始化为null，基本数据类型为0，布尔为false….</li><li>调用对象的初始化方法<br>也就是执行构造方法。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java基础知识点&quot;&gt;&lt;a href=&quot;#Java基础知识点&quot; class=&quot;headerlink&quot; title=&quot;Java基础知识点&quot;&gt;&lt;/a&gt;Java基础知识点&lt;/h2&gt;&lt;h3 id=&quot;简述什么是跨平台&quot;&gt;&lt;a href=&quot;#简述什么是跨平台&quot; class=&quot;
      
    
    </summary>
    
      <category term="java知识点整理" scheme="https://kepler-ecnu.github.io/categories/java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    
    
      <category term="java知识点" scheme="https://kepler-ecnu.github.io/tags/java%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Markdown入门教程</title>
    <link href="https://kepler-ecnu.github.io/2019/08/01/Markdown%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://kepler-ecnu.github.io/2019/08/01/Markdown入门教程/</id>
    <published>2019-08-01T09:29:41.128Z</published>
    <updated>2019-08-06T09:08:07.565Z</updated>
    
    <content type="html"><![CDATA[<p>&lt; !–more–&gt;</p><h2 id="斜体和粗体"><a href="#斜体和粗体" class="headerlink" title="斜体和粗体"></a>斜体和粗体</h2><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*斜体*或_斜体_  </span><br><span class="line">**粗体**</span><br><span class="line">***加粗斜体***</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><p>显示效果：<br><em>这是一段斜体</em><br><strong>这是一段粗体</strong><br><strong><em>这是一段加粗斜体</em></strong><br><del>这是一段删除线</del></p><h2 id="分级标题"><a href="#分级标题" class="headerlink" title="分级标题"></a>分级标题</h2><p>第一种写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这是一个一级标题</span><br><span class="line">==================</span><br><span class="line">这是一个二级标题</span><br><span class="line">------------------</span><br></pre></td></tr></table></figure><p>就是在文字的下一行增加不同的横线，不建议使用。<br>第二种写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><p>推荐使用这种方式，简单易记，不同级别的标题后面<code>#</code>不一样多，在<code>#</code>后需要空一格。</p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>Markdown 支持两种形式的链接语法：行内式和参考式两种形式，行内式一般用的较多。</p><h3 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h3><p><strong>语法说明：</strong><br><code>[]</code>里写链接文字，<code>()</code>里写链接地址，<code>()</code>中的<code>" "</code>可以为链接指定title属性，title属性可加可不加。title属性效果是鼠标悬停在链接上会出现指定的title文字。<code><a href="链接地址" title="链接标题">链接文字</a></code>这样的形式。注：链接地址与链接标题间有一个空格。<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">欢迎访问[我的博客](https://kepler-ecnu.github.io/)</span><br><span class="line">欢迎访问[我的博客](https://kepler-ecnu.github.io/ &quot;kepler&apos;s blog&quot;)</span><br></pre></td></tr></table></figure><p>显示效果：<br>欢迎访问<a href="https://kepler-ecnu.github.io/">我的博客</a><br>欢迎访问<a href="https://kepler-ecnu.github.io/" title="kepler&#39;s blog">我的博客</a> 这个设置了标题，在鼠标指在超链接上时显示标题。</p><h3 id="参考式"><a href="#参考式" class="headerlink" title="参考式"></a>参考式</h3><p>参考式超链接一般用在学术论文上，或者若某一个链接在文章中多出使用，则使用引用的方式创建链接，这样可以对链接进行同意的管理。<br><strong>语法说明：</strong><br>参考式链接分为两部分，文中的写法<code>[链接文字][链接标记]</code>，在文本的任意位置添加[链接文字]:链接地址 “链接标记”，链接地址与链接标记间一个空格。<br>如果链接文字本身可以作为链接标记，也可以写成<code>[链接文字][]</code><br>[链接文字]：链接地址的形式，见代码的最后一行。<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我经常访问的网站[baidu][1]、[bilibili][2]等</span><br><span class="line">[B站][2]有我整理的[音乐合集][]。</span><br><span class="line">[1]:https://www.baidu.com/ &quot;baidu&quot;</span><br><span class="line">[2]:https://space.bilibili.com/12737596 &quot;bilibili&quot;</span><br><span class="line">[音乐合集]:https://space.bilibili.com/12737596</span><br></pre></td></tr></table></figure><h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><p><strong>语法说明</strong><br>Markdown支持较简短的自动链接形式来处理网址和电子邮箱，只要是用<code><></code>包起来，Markdown就会自动把它转成链接。一般网址的链接文字和链接地址一样，如：<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;https://space.bilibili.com/12737596&gt;</span><br><span class="line">&lt;address@example.com&gt;</span><br></pre></td></tr></table></figure><p>显示效果：<br><a href="https://space.bilibili.com/12737596" target="_blank" rel="noopener">https://space.bilibili.com/12737596</a><br><a href="mailto:&#97;&#100;&#x64;&#x72;&#101;&#x73;&#115;&#64;&#101;&#x78;&#97;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#99;&#111;&#109;" target="_blank" rel="noopener">&#97;&#100;&#x64;&#x72;&#101;&#x73;&#115;&#64;&#101;&#x78;&#97;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#99;&#111;&#109;</a></p><h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><p>网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中<br>的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。<br>在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。<br><strong>语法描述：</strong><br>在你准备跳转到的指定标题后插入锚点,然后在文档的其它地方写上链接到锚点的链接。（这里不展开）</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>使用<code>*，+，-</code>表示无序列表<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 无序列表项一</span><br><span class="line">+ 无序列表项二</span><br><span class="line">- 无序列表项三</span><br></pre></td></tr></table></figure><p>显示效果：</p><ul><li>无序列表项一</li></ul><ul><li>无序列表项二</li></ul><ul><li>无序列表项三</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>有序列表则使用数字接着一个英文句点，接着空一个格写列表项。<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 有序列表项一</span><br><span class="line">2. 有序列表项二</span><br><span class="line">3. 有序列表项三</span><br></pre></td></tr></table></figure><p>显示效果：</p><ol><li>有序列表项一</li><li>有序列表项二</li><li>有序列表项三  </li></ol><h3 id="定义型列表"><a href="#定义型列表" class="headerlink" title="定义型列表"></a>定义型列表</h3><p><strong>语法说明：</strong><br>定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法<code>:</code>紧跟一个缩进（Tab）</p><h3 id="列表缩进"><a href="#列表缩进" class="headerlink" title="列表缩进"></a>列表缩进</h3><p><strong>语法说明</strong><br>列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3个空格，项目标记后面则一定要接着至少一个空格或制表符。<br>要让列表看起来更漂亮，你可以把内容用固定的缩进整理好（显示效果与代码一致）：<br>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。<br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！<br>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。<br>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。<br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！<br>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。<br>但是如果你懒，那也行：<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。</span><br><span class="line">那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。</span><br><span class="line">软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！</span><br><span class="line">* 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。</span><br><span class="line">寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。</span><br><span class="line">但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！</span><br><span class="line">悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</span><br></pre></td></tr></table></figure><p>显示效果：</p><ul><li>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。<br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！</li><li>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。<br>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。<br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！<br>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。<h3 id="包含段落的列表"><a href="#包含段落的列表" class="headerlink" title="包含段落的列表"></a>包含段落的列表</h3>列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符（显示效果与代码一致）：<br>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。<br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！<br>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。<br>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。<br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！<br>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。<br>但是如果你懒，那也行：<br>代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。</span><br><span class="line">那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。</span><br><span class="line">软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！</span><br><span class="line">*那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。</span><br><span class="line">寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。</span><br><span class="line">但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！</span><br><span class="line">悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</span><br></pre></td></tr></table></figure>显示效果：</li><li>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。<br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！</li><li>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。<br>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。<br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！<br>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</li></ul><h3 id="包含引用的列表"><a href="#包含引用的列表" class="headerlink" title="包含引用的列表"></a>包含引用的列表</h3><p><strong>语法说明：</strong><br>如果要在列表项目内放进引用，那 &gt; 就需要缩进：<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*阅读的方法：</span><br><span class="line">&gt; 拿出书本</span><br><span class="line">&gt; 放下手机</span><br><span class="line">&gt; 开始看吧</span><br></pre></td></tr></table></figure><p>显示效果：</p><ul><li>阅读的方法：<blockquote><p>拿出书本<br>放下手机<br>开始看吧</p></blockquote></li></ul><h3 id="包含代码区块的引用"><a href="#包含代码区块的引用" class="headerlink" title="包含代码区块的引用"></a>包含代码区块的引用</h3><p><strong>语法说明：</strong><br>如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：<br>一列表项包含一个列表区块：<br>        写代码块的地方</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><strong>语法说明：</strong><br>引用需要在被引用的文本前加上 &gt; 符号。<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这是一个有两段文字的引用</span><br><span class="line">&gt; text1</span><br><span class="line">&gt; text2</span><br><span class="line">&gt;</span><br><span class="line">&gt; text3</span><br><span class="line">&gt; text4</span><br></pre></td></tr></table></figure><p>显示效果：</p><blockquote><p>这是一个有两段文字的引用<br>text1<br>text2</p><p>text3<br>text4</p></blockquote><h3 id="引用的多层嵌套"><a href="#引用的多层嵌套" class="headerlink" title="引用的多层嵌套"></a>引用的多层嵌套</h3><p>区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ：<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这是一个有两段文字的引用</span><br><span class="line">&gt;&gt; text1</span><br><span class="line">&gt;&gt;&gt; text2</span><br><span class="line">&gt;</span><br><span class="line">&gt; text3</span><br><span class="line">&gt; text4</span><br></pre></td></tr></table></figure><p>显示效果：</p><blockquote><p>这是一个有两段文字的引用</p><blockquote><p>text1</p><blockquote><p>text2</p></blockquote></blockquote><p>text3<br>text4</p></blockquote><h3 id="引用的其它要素"><a href="#引用的其它要素" class="headerlink" title="引用的其它要素"></a>引用的其它要素</h3><p>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; 1. 第一列表项</span><br><span class="line">&gt; 2. 第二列表项</span><br><span class="line">&gt;&gt; text1</span><br><span class="line">&gt;&gt;&gt; text2</span><br><span class="line">&gt;</span><br><span class="line">&gt; return shell_exec(&quot;echo $input | $markdown_script&quot;);</span><br><span class="line">&gt; `return shell_exec(&quot;echo $input | $markdown_script&quot;);`</span><br></pre></td></tr></table></figure><p>显示效果：</p><blockquote><ol><li><p>第一列表项</p></li><li><p>第二列表项</p><blockquote><p>text1</p><blockquote><p>text2</p></blockquote></blockquote><pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);</code></pre><p><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);</code></p></li></ol></blockquote><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。<br>语法中图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。</p><h3 id="行内式-1"><a href="#行内式-1" class="headerlink" title="行内式"></a>行内式</h3><p><strong>语法说明：</strong><code>![图片Alt](图片地址 "图片Title")</code><br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![图片示例](http://img.redocn.com/sheji/20141219/zhongguofengdaodeliyizhanbanzhijing_3744115.jpg &quot;图片示例&quot;)</span><br></pre></td></tr></table></figure><p>显示效果：<br><img src="http://img.redocn.com/sheji/20141219/zhongguofengdaodeliyizhanbanzhijing_3744115.jpg" alt="图片示例" title="图片示例"></p><h3 id="参考式-1"><a href="#参考式-1" class="headerlink" title="参考式"></a>参考式</h3><p><strong>语法说明：（这里不作介绍）</strong><br>在文档要插入图片的地方写<code>![图片Alt][标记]</code><br>在文档的最后写上写<code>[标记]:图片地址 “Title”</code></p><h2 id="内容目录"><a href="#内容目录" class="headerlink" title="内容目录"></a>内容目录</h2><p>在段落中填写 [TOC] 以显示全文内容的目录结构。<br>Hexo博客对目录的解析似乎也有限，请在Markdown编辑器中自行尝试。Next主题的话是也可以自动生成目录的，所以不需要额外增加目录。</p><h2 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h2><p><strong>语法说明：</strong><br>在需要添加注脚的文字后加上<code>脚注名字[^脚注名字]</code>，称为加注。然后在文本的任意位置（一般在最后）添加脚注，脚注前必须有对应的脚注名字。<br>注意：经测试注脚和脚注之间必须空一行，不然会失效。成功后会发现，即使没有把注脚卸载文末，经Markdown转换后，也会自动归类到文章的最后。<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。</span><br><span class="line">[^1]: Markdown是一种纯文本标记语言</span><br><span class="line">[^2]: HyperText Markup Language 超文本标记语言</span><br><span class="line">[^Le]: 开源笔记平台，支持Markdown和笔记直接发为博文</span><br></pre></td></tr></table></figure><p>显示效果：<br>使用 Markdown<a href="Markdown是一种纯文本标记语言">^1</a>可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。</p><p>[^2]: HyperText Markup Language 超文本标记语言<br>[^Le]: 开源笔记平台，支持Markdown和笔记直接发为博文</p><h2 id="LaTex公式"><a href="#LaTex公式" class="headerlink" title="LaTex公式"></a>LaTex公式</h2><h3 id="表示行内公式"><a href="#表示行内公式" class="headerlink" title="$表示行内公式"></a>$表示行内公式</h3><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。</span><br></pre></td></tr></table></figure><p>显示效果：<br>质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。<br>注意：我的博客没有开启公式显示，所以可能公式显示不准确，请自己用Markdown编辑器查看效果</p><h3 id="表示整行公式"><a href="#表示整行公式" class="headerlink" title="$表示整行公式"></a>$表示整行公式</h3><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$\sum_&#123;i=1&#125;^n a_i=0$$</span><br><span class="line">$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$</span><br><span class="line">$$\sum^&#123;j-1&#125;_&#123;k=0&#125;&#123;\widehat&#123;\gamma&#125;_&#123;kj&#125; z_k&#125;$$</span><br></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p><strong>语法说明：</strong><br>不管是哪种方式，第一行为表头，第二行分割表头和主体部分，第三行开始每一行为一个表格行。<br>列与列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。<br>第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">简单方式写表格：</span><br><span class="line"></span><br><span class="line">学号|姓名|分数</span><br><span class="line">-|-|-</span><br><span class="line">小明|男|75</span><br><span class="line">小红|女|79</span><br><span class="line">小陆|男|92</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原生方式写表格：</span><br><span class="line"></span><br><span class="line">| 学号 | 姓名 | 分数 |</span><br><span class="line">| ---- | ---- | ---- |</span><br><span class="line">| 小明 | 男   | 75   |</span><br><span class="line">| 小红 | 女   | 79   |</span><br><span class="line">| 小陆 | 男   | 92   |</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">为表格第二列指定方向：</span><br><span class="line"></span><br><span class="line">| 产品             |     价格 |</span><br><span class="line">| ---------------- | -------: |</span><br><span class="line">| Leanote 高级账号 |  60元/年 |</span><br><span class="line">| Leanote 超级账号 | 120元/年 |</span><br></pre></td></tr></table></figure><p>显示效果：<br>简单方式写表格：</p><table><thead><tr><th>学号</th><th>姓名</th><th>分数</th></tr></thead><tbody><tr><td>小明</td><td>男</td><td>75</td></tr><tr><td>小红</td><td>女</td><td>79</td></tr><tr><td>小陆</td><td>男</td><td>92</td></tr></tbody></table><p>原生方式写表格：</p><table><thead><tr><th>学号</th><th>姓名</th><th>分数</th></tr></thead><tbody><tr><td>小明</td><td>男</td><td>75</td></tr><tr><td>小红</td><td>女</td><td>79</td></tr><tr><td>小陆</td><td>男</td><td>92</td></tr></tbody></table><p>为表格第二列指定方向：</p><table><thead><tr><th>产品</th><th align="right">价格</th></tr></thead><tbody><tr><td>Leanote 高级账号</td><td align="right">60元/年</td></tr><tr><td>Leanote 超级账号</td><td align="right">120元/年</td></tr></tbody></table><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分割线，行内不能有其他东西。也可以在星号或是减号中间插入空格。下面每种写法都可以建立分割线：<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* * *</span><br><span class="line">***</span><br><span class="line">*****</span><br><span class="line">- - -</span><br><span class="line">---------------------------------------</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(Tab), 另一种是利用”`”符号（一般在ESC键下方）包裹代码。<br><strong>语法说明：</strong><br>插入行内代码，即插入一个单词或者一句代码的情况，使用&lt;code&gt;这样的形式插入。<br>插入多行代码，可以使用缩进或者“code “,具体看示例。<br>注意： 缩进式插入前方必须有空行</p><h3 id="行内式-2"><a href="#行内式-2" class="headerlink" title="行内式"></a>行内式</h3><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C语言里的函数 `scanf()` 怎么使用？</span><br></pre></td></tr></table></figure><p>显示效果：<br>C语言里的函数 <code>scanf()</code> 怎么使用？</p><h3 id="缩进式多行代码"><a href="#缩进式多行代码" class="headerlink" title="缩进式多行代码"></a>缩进式多行代码</h3><p>缩进4个空格或是一个制表符（Tab）<br>一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Hello world\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示效果：</p><p>#include &lt;stdio.h&gt;<br>int main(void)<br>{<br>    printf(“Hello world\n”);<br>}</p><h3 id="用三个”-”包裹多行代码"><a href="#用三个”-”包裹多行代码" class="headerlink" title="用三个” `”包裹多行代码"></a>用三个” `”包裹多行代码</h3><p>输入三个<code>后空一行写代码，结束后另起一行输入三个</code>表示代码块的结束</p><h2 id="HTML-原始码"><a href="#HTML-原始码" class="headerlink" title="HTML 原始码"></a>HTML 原始码</h2><p>Markdown支持很多HTML代码，具体不展开。</p>]]></content>
    
    <summary type="html">
    
      Markdown入门使用
    
    </summary>
    
      <category term="博客搭建" scheme="https://kepler-ecnu.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Markdown" scheme="https://kepler-ecnu.github.io/tags/Markdown/"/>
    
  </entry>
  
</feed>
