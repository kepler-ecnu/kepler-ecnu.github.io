<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>The real world</title>
  
  <subtitle>You can do something</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kepler-ecnu.github.io/"/>
  <updated>2019-08-07T08:03:22.533Z</updated>
  <id>https://kepler-ecnu.github.io/</id>
  
  <author>
    <name>kepler</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java知识点整理(不间断更新)</title>
    <link href="https://kepler-ecnu.github.io/2019/08/06/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <id>https://kepler-ecnu.github.io/2019/08/06/Java知识点整理/</id>
    <published>2019-08-06T05:20:21.000Z</published>
    <updated>2019-08-07T08:03:22.533Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java基础知识点"><a href="#Java基础知识点" class="headerlink" title="Java基础知识点"></a>Java基础知识点</h2><h3 id="简述什么是跨平台"><a href="#简述什么是跨平台" class="headerlink" title="简述什么是跨平台"></a>简述什么是跨平台</h3><p>由于各种操作系统所支持的指令集不是完全一致的，所以在操作系统上加个虚拟机来提供统一接口，屏蔽系统之间的差异。</p><h3 id="Java有几种基本数据类型"><a href="#Java有几种基本数据类型" class="headerlink" title="Java有几种基本数据类型"></a>Java有几种基本数据类型</h3><p>有八种基本数据类型:</p><table><thead><tr><th>数据类型</th><th>字节</th><th>默认值</th></tr></thead><tbody><tr><td>byte</td><td>1</td><td>0</td></tr><tr><td>char</td><td>4</td><td>‘\u0000’</td></tr><tr><td>boolean</td><td>1</td><td>false</td></tr><tr><td>float</td><td>4</td><td>0.0f</td></tr><tr><td>double</td><td>8</td><td>0.0d</td></tr><tr><td>int</td><td>4</td><td>0</td></tr><tr><td>short</td><td>2</td><td>0</td></tr><tr><td>long</td><td>8</td><td>0</td></tr></tbody></table><h3 id="面向对象特征"><a href="#面向对象特征" class="headerlink" title="面向对象特征"></a>面向对象特征</h3><p>面向对象的编程语言有<strong>封装、继承、多态、抽象</strong>四个主要特征。</p><ul><li>封装：把描述一个对象的属性和行为封装在一个模块中，即一个类中，属性用变量定义，行为用方法定义，方法可以直接访问同一个对象中的属性。</li><li>抽象：把现实生活中的对象抽象为类。分为过程抽象和数据抽象<ul><li>过程抽象：类的方法（鸟会啼鸣等）</li><li>数据抽象：类的属性（鸟有翅膀等）</li></ul></li><li>继承：子类继承父类的特征和行为。子类可以有父类非私有的方法，也可以对父类进行扩展，也可以重写父类的方法。缺点就是提高了代码间的耦合性。</li><li>多态：<ul><li>编译时多态：方法的重载</li><li>运行时多态：向上转型、方法重写–基于继承</li></ul></li></ul><h3 id="面向对象六大原则"><a href="#面向对象六大原则" class="headerlink" title="面向对象六大原则"></a>面向对象六大原则</h3><ol><li><strong>单一职责</strong>原则—-SRP<ul><li>让每个类只专心处理自己的方法</li></ul></li><li><strong>开闭</strong>原则—-OCP<ul><li>软件中的对象（类、模块、函数等）应该<strong>对于扩展开放</strong>，<strong>对于修改是关闭</strong>的</li></ul></li><li><strong>里氏替换</strong>原则—-LSP<ul><li>子类可以去扩展父类，但是不能改变父类原有的功能</li></ul></li><li><strong>依赖倒置</strong>原则—-DIP<ul><li>应该通过调用接口或抽象类，而不是调用实现类</li></ul></li><li><strong>接口隔离</strong>原则—-ISP<ul><li>把接口分为满足依赖关系的最小接口，实现类中不能有不需要的方法</li></ul></li><li><strong>迪米特</strong>原则—-LOP<ul><li>高内聚、低耦合</li></ul></li></ol><h3 id="String属于基础的数据类型吗"><a href="#String属于基础的数据类型吗" class="headerlink" title="String属于基础的数据类型吗"></a>String属于基础的数据类型吗</h3><p>String不属于基础类型，基础类型有type、boolean、int、char、short、long、float、double，而String属于包装器类型</p><h3 id="为什么要有包装类型"><a href="#为什么要有包装类型" class="headerlink" title="为什么要有包装类型"></a>为什么要有包装类型</h3><p>为了让基本数据类型也具有对象的特征，就出现了包装类型（如在使用集合类型Collection时就一定要使用包装类型而不是基本数据类型）。因为容器都是装object的，这时就需要这些基本数据类型的包装类型了。</p><table><thead><tr><th>基本类型</th><th>包装器类型</th></tr></thead><tbody><tr><td>boolean</td><td>Boolean</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr></tbody></table><h3 id="自动装箱和自动拆箱"><a href="#自动装箱和自动拆箱" class="headerlink" title="自动装箱和自动拆箱"></a>自动装箱和自动拆箱</h3><p>自动装箱：<code>new Integer(6)</code>，底层调用：<code>Integer.valueOf(6)</code>；<br>自动拆箱：<code>int i = new Integer(6)</code>，底层调用：<code>i.intValue();</code><br>二者的区别：</p><ul><li>声明方式不同：基本数据类型不使用new关键字，而包装类型需要使用new关键字在<strong>堆中分配存储空间</strong>；</li><li>存储方式及位置不同：基本数据类型是直接将变量值存储在<strong>栈</strong>中，而包装类型是将对象放在<strong>堆</strong>中，然后通过<strong>引用</strong>来使用；</li><li>初始值不同：基本数据类型的初始值如int为0，boolean为false，而包装类型的初始值为null；</li><li>使用方式不同：基本数据类型赋值直接使用就好，而包装类型在集合如Collection、Map时会使用到。</li></ul><h3 id="String-str-“i”-与-String-str-new-String-“i”-一样么"><a href="#String-str-“i”-与-String-str-new-String-“i”-一样么" class="headerlink" title="String str = “i” 与 String str = new String(“i”)一样么"></a>String str = “i” 与 String str = new String(“i”)一样么</h3><p>不一样，因为内存的分配方式不一样。<code>String str = "i"</code>的方式，Java虚拟机会将其分配到常量池中；<code>String str = new String("i")</code>则会被分到堆内存中。</p><h3 id="如何将字符串反转"><a href="#如何将字符串反转" class="headerlink" title="如何将字符串反转"></a>如何将字符串反转</h3><p>使用StringBuilder或者StringBuffer的reverse()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// StringBuffer reverse</span><br><span class="line">StringBuffer stringBuffer = new StringBuffer();</span><br><span class="line">stringBuffer. append(&quot;abcdefg&quot;);</span><br><span class="line">System. out. println(stringBuffer. reverse()); // gfedcba</span><br><span class="line">// StringBuilder reverse</span><br><span class="line">StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">stringBuilder. append(&quot;abcdefg&quot;);</span><br><span class="line">System. out. println(stringBuilder. reverse()); // gfedcba</span><br></pre></td></tr></table></figure><h3 id="String-类常用方法"><a href="#String-类常用方法" class="headerlink" title="String 类常用方法"></a>String 类常用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">indexOf()：返回指定字符的索引。</span><br><span class="line">charAt()：返回指定索引处的字符。</span><br><span class="line">replace()：字符串替换。</span><br><span class="line">trim()：去除字符串两端空白。</span><br><span class="line">split()：分割字符串，返回一个分割后的字符串数组。</span><br><span class="line">getBytes()：返回字符串的 byte 类型数组。</span><br><span class="line">length()：返回字符串长度。</span><br><span class="line">toLowerCase()：将字符串转成小写字母。</span><br><span class="line">toUpperCase()：将字符串转成大写字符。</span><br><span class="line">substring()：截取字符串。</span><br><span class="line">equals()：字符串比较。</span><br></pre></td></tr></table></figure><h3 id="和-equals-区别"><a href="#和-equals-区别" class="headerlink" title="== 和 equals 区别"></a>== 和 equals 区别</h3><ul><li><p>== 比较的是<strong>两个引用</strong>在内存中指向的是不是同一对象（即同一内存空间），也就是说在内存中的存储位置是否一致。如果两个对象的引用相同时（指向同一对象时），== 操作符返回true,否则返回false。</p><ul><li><p>对于基本类型和引用类型 == 的作用效果是不同的：<br>基本类型：比较的是值是否相同；<br>引用类型：比较的是引用是否相同；<br>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String x = &quot;string&quot;;</span><br><span class="line">String y = &quot;string&quot;;</span><br><span class="line">String z = new String(&quot;string&quot;);</span><br><span class="line">System.out.println(x==y); // true</span><br><span class="line">System.out.println(x==z); // false</span><br><span class="line">System.out.println(x.equals(y)); // true</span><br><span class="line">System.out.println(x.equals(z)); // true</span><br></pre></td></tr></table></figure><p>代码解读：因为 x 和 y 指向的是同一个引用，所以 == 是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true</p></li></ul></li><li><p>equals 用来比较<strong>某些特征</strong>是否一样，本质上就是 == ，只不过String和Integer等重写了equals方法，把它变成了值比较。<br>首先看默认情况下equals比较一个有相同值的对象，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Cat &#123;</span><br><span class="line">    public Cat(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private String name;</span><br><span class="line"> </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Cat c1 = new Cat(&quot;王磊&quot;);</span><br><span class="line">Cat c2 = new Cat(&quot;王磊&quot;);</span><br><span class="line">System.out.println(c1.equals(c2)); // false</span><br></pre></td></tr></table></figure></li></ul><p>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">        return (this == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来 equals 本质上就是 ==。<br>那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = new String(&quot;老王&quot;);</span><br><span class="line">String s2 = new String(&quot;老王&quot;);</span><br><span class="line">System.out.println(s1.equals(s2)); // true</span><br></pre></td></tr></table></figure><p>同样的，当我们进入 String 的 equals方法，找到了答案，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">        if (this == anObject) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (anObject instanceof String) &#123;</span><br><span class="line">            String anotherString = (String)anObject;</span><br><span class="line">            int n = value.length;</span><br><span class="line">            if (n == anotherString.value.length) &#123;</span><br><span class="line">                char v1[] = value;</span><br><span class="line">                char v2[] = anotherString.value;</span><br><span class="line">                int i = 0;</span><br><span class="line">                while (n-- != 0) &#123;</span><br><span class="line">                    if (v1[i] != v2[i])</span><br><span class="line">                        return false;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。<br><strong>总结：</strong> == 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重写了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p><h3 id="String、StringBuffer和StringBuilder区别"><a href="#String、StringBuffer和StringBuilder区别" class="headerlink" title="String、StringBuffer和StringBuilder区别"></a>String、StringBuffer和StringBuilder区别</h3><ul><li><p>数据可变和不可变</p><ul><li>String底层使用一个不可变的字符数组<code>private final char value[]</code>，所以它的内容不可变</li><li>StringBuffer和StringBuilder都继承了AbstractStringBuilder底层使用的是可变字符数组：<code>char[] value;</code></li></ul></li><li><p>线程安全性</p><ul><li>StringBulider是线程不安全的，效率较高；而StringBuffer是线程安全的，效率较低；<br>通过他们的append()方法来看，SpringBuffer是有同步锁，而StringBuilder没有：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public synchronized StringBuffer append(Object obj) &#123;</span><br><span class="line">    toStringCache = null;</span><br><span class="line">    super.append(String.valueOf(obj));</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public StringBuilder append(String str) &#123;</span><br><span class="line">    super.append(str);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>相同点<br>StringBuilder与StringBuffer有公共父类AbstractBuilder；<br>最后，操作可变字符串速度：<strong>StringBuilder &gt; StringBuffer &gt; String</strong>。</p></li></ul><h3 id="两个对象的-hashCode-相同，则equals-也一定为true，对吗？"><a href="#两个对象的-hashCode-相同，则equals-也一定为true，对吗？" class="headerlink" title="两个对象的 hashCode()相同，则equals()也一定为true，对吗？"></a>两个对象的 hashCode()相同，则equals()也一定为true，对吗？</h3><p>不对，两个对象的HashCode()相同，equals()不一定true。<br>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;通话&quot;;</span><br><span class="line">String str2 = &quot;重地&quot;;</span><br><span class="line">System. out. println(String. format(&quot;str1：%d | str2：%d&quot;,  str1. hashCode(),str2. hashCode()));</span><br><span class="line">System. out. println(str1. equals(str2));</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1：1179395 | str2：1179395</span><br><span class="line"> </span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p><h3 id="两个对象值相同-x-equals-y-true-，Hashcode是否一定相同"><a href="#两个对象值相同-x-equals-y-true-，Hashcode是否一定相同" class="headerlink" title="两个对象值相同(x.equals(y)==true)，Hashcode是否一定相同"></a>两个对象值相同(x.equals(y)==true)，Hashcode是否一定相同</h3><p>第一种情况：假如这个类没有重写equals方法，如果两个对象值相同，那么他们的hashCode值一定相同；<br>第二种情况：如果重写了equals方法，但没有重写hashCode方法，就会出现不相等的情况。<br><strong>Java对于equals方法和hashCode方法的规定</strong></p><ol><li>如果两个对象相同，那么他们的hashCode值一定要相同；</li><li>如果两个对象的hashCode相同，他们并不一定相同（这里说的对象相同指的是用equals方法比较）；</li><li>equals()相等的两个对象，hashCode()一定相等；equals()不相等的两个对象，却并不能证明他们的hashCode()不相等。<br>换句话说，equals()方法不相等的两个对象，hashCode()有可能相等（我的理解是由于哈希码在生成的时候产生冲突造成的）。反过来，hashCode()不等，一定能推出equals()也不等；hashCode()相等，equals()可能相等，也可能不等。</li></ol><h3 id="什么时候需要重写equals方法和hashCode方法"><a href="#什么时候需要重写equals方法和hashCode方法" class="headerlink" title="什么时候需要重写equals方法和hashCode方法"></a>什么时候需要重写equals方法和hashCode方法</h3><p>如果想完整的使用HashSet类(或TreeSet等)，最少需要重写equals()和hashCode()方法</p><ol><li>重写hashCode()用于获得元素的存储位置；</li><li>重写equals()用于在两个元素的位置相同的时候，比较两个元素是否相等。<br>分析原因如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hashCode </span><br><span class="line">        public int hashCode()返回该对象的哈希码值。支持此方法是为了提高哈希表（例如 Java.util.Hashtable 提供的哈希表）的性能。</span><br><span class="line">        hashCode 的常规协定是： </span><br><span class="line">        在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。 </span><br><span class="line">        如果根据 equals(Object) 方法，两个对象是相等的，那么对这两个对象中的每个对象调用 hashCode 方法都必须生成相同的整数结果。 </span><br><span class="line">        如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么对这两个对象中的任一对象上调用 hashCode 方法不 要求一定生成不同的整数结果。但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能。 </span><br><span class="line">        实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。）</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">equals </span><br><span class="line">public boolean equals(Object obj)指示其他某个对象是否与此对象“相等”。 </span><br><span class="line">equals 方法在非空对象引用上实现相等关系： </span><br><span class="line"></span><br><span class="line">自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true。 </span><br><span class="line">对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。 </span><br><span class="line">传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。 </span><br><span class="line">一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。 </span><br><span class="line">对于任何非空引用值 x，x.equals(null) 都应返回 false。 </span><br><span class="line">Object 类的 equals 方法实现对象上差别可能性最大的相等关系；即，对于任何非空引用值 x 和 y，当且仅当 x 和 y 引用同一个对象时，此方法才返回 true（x == y 具有值 true）。</span><br></pre></td></tr></table></figure><h3 id="final在Java中有什么作用"><a href="#final在Java中有什么作用" class="headerlink" title="final在Java中有什么作用"></a>final在Java中有什么作用</h3><ol><li>修饰类，则该类不能被继承；</li><li>修饰方法，则该方法不能被重写；</li><li>修饰变量，修饰的变量叫常量，必须初始化，且初始化后值不能被修改。</li></ol><h3 id="static和final区别"><a href="#static和final区别" class="headerlink" title="static和final区别"></a>static和final区别</h3><table>  <tr>    <th>关键词</th>    <th>修饰对象</th>    <th>影响</th>  </tr>  <tr>    <td rowspan="3">final</td>    <td>变量</td>    <td>分配到常量池中，程序不可改变其值</td>  </tr>  <tr>    <td>方法</td>    <td>子类中将不能被重写</td>  </tr>  <tr>    <td>类</td>    <td>不能被继承</td>  </tr>  <tr>    <td rowspan="3">static</td>    <td>变量</td>    <td>分配在<span style="color:rgb(253, 104, 100)">内存堆</span>上，引用都会指向这一地址而不会重新分配内存</td>  </tr>  <tr>    <td>方法块</td>    <td>虚拟机优先加载</td>  </tr>  <tr>    <td>类</td>    <td>可以直接通过类来调用而不需要new</td>  </tr></table><h3 id="引用类型占用几个字节"><a href="#引用类型占用几个字节" class="headerlink" title="引用类型占用几个字节"></a>引用类型占用几个字节</h3><p>hotspot VM在64位平台上占8个字节，在32平台上占4个字节</p><h3 id="1-lt-3-quot-a-quot-quot-b-quot-3-4和-1-lt-3-quot-a-quot-quot-b-quot-3-4-区别"><a href="#1-lt-3-quot-a-quot-quot-b-quot-3-4和-1-lt-3-quot-a-quot-quot-b-quot-3-4-区别" class="headerlink" title="(1&lt;3)?&quot;a&quot;:&quot;b&quot;)+3+4和(1&lt;3)?&quot;a&quot;:&quot;b&quot;)+(3+4)区别"></a><code>(1&lt;3)?&quot;a&quot;:&quot;b&quot;)+3+4</code>和<code>(1&lt;3)?&quot;a&quot;:&quot;b&quot;)+(3+4)</code>区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(((1&lt;3)?&quot;a&quot;:&quot;b&quot;)+3+4);</span><br><span class="line">System.out.println(((1&lt;3)?&quot;a&quot;:&quot;b&quot;)+(3+4));</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a34</span><br><span class="line">a7</span><br></pre></td></tr></table></figure><h3 id="4-amp-5-4-5-4-amp-10-gt-gt-1各等于多少"><a href="#4-amp-5-4-5-4-amp-10-gt-gt-1各等于多少" class="headerlink" title="4&amp;5 4^5 4&amp;10&gt;&gt;1各等于多少"></a><code>4&amp;5</code> <code>4^5</code> <code>4&amp;10&gt;&gt;1</code>各等于多少</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 0100 &amp; 0101 = 0100 = 4</span><br><span class="line">System.out.println(4&amp;5);</span><br><span class="line">// 0100 ^ 0101 = 0001 = 1</span><br><span class="line">System.out.println(4^5);</span><br><span class="line">System.out.println(10&gt;&gt;1);</span><br><span class="line"> // 有疑问参考下面的运算符优先级</span><br><span class="line">System.out.println(4&amp;10&gt;&gt;1);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">5</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>同问 <code>4|5</code>等于多少呢<br>答案为5<br>Tip：<br>与运算符用符号“&amp;”表示，其使用规律如下：<br>两个操作数中位都为1，结果才为1，否则结果为0<br>或运算符用符号“|”表示，其运算规律如下：<br>两个位只要有一个为1，那么结果就是1，否则就为0<br>3&amp;4相当于0011&amp;0100，结果是0000，也就是0<br>4|5相当于0100|0101，结果是0101，也就是5<br>java的位运算符还有两个：<br>非运算符用符号“~”表示，其运算规律如下：<br>如果位为0，结果是1，如果位为1，结果是0<br>异或运算符是用符号“^”表示的，其运算规律是：<br>两个操作数的位中，相同则结果为0，不同则结果为1</p><p>运算符优先级</p><table><thead><tr><th>运算符</th><th>结合性</th></tr></thead><tbody><tr><td>[ ] . ( ) (方法调用)</td><td>从左向右</td></tr><tr><td>! ~ ++ – +(一元运算) -(一元运算)</td><td>从右向左</td></tr><tr><td>* / %</td><td>从左向右</td></tr><tr><td>+ -</td><td>从左向右</td></tr><tr><td>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</td><td>从左向右</td></tr><tr><td>&lt; &lt;= &gt; &gt;= instanceof</td><td>从左向右</td></tr><tr><td>== !=</td><td>从左向右</td></tr><tr><td>&amp;</td><td>从左向右</td></tr><tr><td>^</td><td>从左向右</td></tr><tr><td>|</td><td>从左向右</td></tr><tr><td>&amp;&amp;</td><td>从左向右</td></tr><tr><td>||</td><td>从左向右</td></tr><tr><td>?:</td><td>从右向左</td></tr><tr><td>=</td><td>从右向左</td></tr></tbody></table><h3 id="Java中-Math-round-1-5-等于多少？Math-round-2-5-等于多少？"><a href="#Java中-Math-round-1-5-等于多少？Math-round-2-5-等于多少？" class="headerlink" title="Java中 Math.round(-1.5)等于多少？Math.round(-2.5)等于多少？"></a>Java中 Math.round(-1.5)等于多少？Math.round(-2.5)等于多少？</h3><p>答案：-1，-2<br>注意：不要认为它是四舍五入<br>计算口诀：+0.5后向下取整即可<br>同理Math.round(-2.6)结果和Math.round(2.6)结果分别为-3，3</p><h3 id="抽象类必须要有抽象方法吗？"><a href="#抽象类必须要有抽象方法吗？" class="headerlink" title="抽象类必须要有抽象方法吗？"></a>抽象类必须要有抽象方法吗？</h3><p>不需要，抽象类不一定非要抽象方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abstract class Cat &#123;</span><br><span class="line">        public static void sayHi() &#123;</span><br><span class="line">            System. out. println(&quot;hi~&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="普通类和抽象类有哪些区别"><a href="#普通类和抽象类有哪些区别" class="headerlink" title="普通类和抽象类有哪些区别"></a>普通类和抽象类有哪些区别</h3><p>普通类不能包含抽象方法，抽象类可以包含抽象方法<br>抽象类不能直接实例化，普通类可以直接实例化</p><h3 id="抽象类能使用final修饰吗"><a href="#抽象类能使用final修饰吗" class="headerlink" title="抽象类能使用final修饰吗"></a>抽象类能使用final修饰吗</h3><p>不能，定义抽象类就是让其他类继承的，如果定义为final该类就不能被继承，这样彼此就会产生矛盾，所以final不能修饰抽象类。</p><h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><ul><li>实现：抽象类的子类使用extends来继承；接口必须使用implements来实现接口；</li><li>构造函数：抽象类有构造函数；接口不能有；</li><li>实现数量：类可以实现多个接口，但是只能继承一个抽象类；</li><li>访问修饰符：抽象类中的抽象方法(其前有abstract修饰)不能用private、static、synchronized、native访问修饰符修饰；接口中的方法默认使用 public 修饰，接口是一种特殊的抽象类，接口中的方法全部是抽象方法（但其前的abstract可以省略），所以抽象类中的抽象方法不能用的访问修饰符这里也不能用，而且protected访问修饰符也不能使用。</li></ul><h3 id="Java中IO流分为几种"><a href="#Java中IO流分为几种" class="headerlink" title="Java中IO流分为几种"></a>Java中IO流分为几种</h3><ul><li>按功能分：输入流（input）、输出流（output）</li><li>按类型分：字节流和字符流<br>  字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</li></ul><h3 id="BIO、NIO和AIO区别"><a href="#BIO、NIO和AIO区别" class="headerlink" title="BIO、NIO和AIO区别"></a>BIO、NIO和AIO区别</h3><ul><li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li><li>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li><li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li></ul><h3 id="Files常用方法有哪些"><a href="#Files常用方法有哪些" class="headerlink" title="Files常用方法有哪些"></a>Files常用方法有哪些</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Files. exists()：检测文件路径是否存在。</span><br><span class="line">Files. createFile()：创建文件。</span><br><span class="line">Files. createDirectory()：创建文件夹。</span><br><span class="line">Files. delete()：删除一个文件或目录。</span><br><span class="line">Files. copy()：复制文件。</span><br><span class="line">Files. move()：移动文件。</span><br><span class="line">Files. size()：查看文件个数。</span><br><span class="line">Files. read()：读取文件。</span><br><span class="line">Files. write()：写入文件。</span><br></pre></td></tr></table></figure><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="Java容器都有哪些"><a href="#Java容器都有哪些" class="headerlink" title="Java容器都有哪些"></a>Java容器都有哪些</h3><p>Java容器分为Collection和Map两大类，其下又有很多子类，如下所示：</p><ul><li>Collection<ul><li>List<ul><li>ArrayList</li><li>LinkedList</li><li>Vector</li><li>Stack</li></ul></li><li>Set<ul><li>HashSet</li><li>LinkedHashSet</li><li>TreeSet</li></ul></li></ul></li><li>Map<ul><li>HashMap<ul><li>LinkedHashMap</li></ul></li><li>TreeMap</li><li>ConcurrentHashMap</li><li>Hashtable</li></ul></li></ul><h3 id="简述Java中的集合"><a href="#简述Java中的集合" class="headerlink" title="简述Java中的集合"></a>简述Java中的集合</h3><ul><li>Collection下：List系（有序、元素允许重复）和Set系（无序、元素不重复）<br>  set根据equals和hashCode判断，一个对象要存储在Set中，必须重写equals和hashCode方法。</li><li>Map下：HashMap线程不同步；TreeMap线程同步；</li><li>Collection系列和Map系列：Map是对Colleciton的补充，两者没什么关系。</li></ul><h3 id="List、Set、Map之间的区别"><a href="#List、Set、Map之间的区别" class="headerlink" title="List、Set、Map之间的区别"></a>List、Set、Map之间的区别</h3><p>List、Set、Map之间的区别主要体现在两个方面：元素是否有序、是否允许元素重复<br>三者间的区别，如表所示：</p><table>  <tr>    <th></th>    <th></th>    <th>元素有序</th>    <th>允许元素重复</th>  </tr>  <tr>    <td colspan="2">List</td>    <td>是</td>    <td>是</td>  </tr>  <tr>    <td rowspan="3">Set</td>    <td>AbstractSet</td>    <td rowspan="2">否</td>    <td rowspan="3">否</td>  </tr>  <tr>    <td>HashSet</td>  </tr>  <tr>    <td>TreeSet</td>    <td>是（用二叉树排序）</td>  </tr>  <tr>    <td rowspan="3">Map</td>    <td>AbstractMap</td>    <td rowspan="2">否</td>    <td rowspan="3">key值必须唯一<br>value值可重复</td>  </tr>  <tr>    <td>HashMap</td>  </tr>  <tr>    <td>TreeMap</td>    <td>是（用二叉树排序）</td>  </tr></table><h3 id="HashMap、HashTable和ConcurrentHashMap区别"><a href="#HashMap、HashTable和ConcurrentHashMap区别" class="headerlink" title="HashMap、HashTable和ConcurrentHashMap区别"></a>HashMap、HashTable和ConcurrentHashMap区别</h3><p>相同点：<br>    1. HashMap和HashTable都实现了Map接口<br>    2. 都可以存储key-value数据<br>不同点：<br>    1. HashMap可以把null作为key或者value,HashTable不可以<br>    2. HashMap线程不安全，效率高，HashTable线程安全，效率低<br>    3. HashMap迭代器(Iterator)是fail-fast迭代器，而HashTable的enumerator迭代器不是fail-fast的<br>    什么是fail-fast?<br>      就是最快的时间能把错误抛出而不是让程序执行<br>    4. Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</p><h4 id="如何保证线程安全又效率高"><a href="#如何保证线程安全又效率高" class="headerlink" title="如何保证线程安全又效率高"></a>如何保证线程安全又效率高</h4><p>Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。ConcurrentHashMap将整个Map分为N个segment(类似HashTable)，可以提供相同的线程安全，但是效率提升N倍，默认N为16。</p><h4 id="我们能否让HashMap同步"><a href="#我们能否让HashMap同步" class="headerlink" title="我们能否让HashMap同步"></a>我们能否让HashMap同步</h4><p>HashMap可以通过下面语句进行同步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map m = Collections.synchronizeMap(hashMap);</span><br></pre></td></tr></table></figure><h3 id="如何决定使用HashMap还是TreeMap"><a href="#如何决定使用HashMap还是TreeMap" class="headerlink" title="如何决定使用HashMap还是TreeMap"></a>如何决定使用HashMap还是TreeMap</h3><p>对于在 Map 中插入、删除、定位一个元素这类操作，HashMap是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。</p><h3 id="说一下-HashMap-的实现原理"><a href="#说一下-HashMap-的实现原理" class="headerlink" title="说一下 HashMap 的实现原理"></a>说一下 HashMap 的实现原理</h3><p>HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。</p><h3 id="说一下-HashSet-的实现原理"><a href="#说一下-HashSet-的实现原理" class="headerlink" title="说一下 HashSet 的实现原理"></a>说一下 HashSet 的实现原理</h3><p>HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，<strong>HashSet 不允许重复的值</strong>。</p><h3 id="ArrayList-和-LinkdList-区别"><a href="#ArrayList-和-LinkdList-区别" class="headerlink" title="ArrayList 和 LinkdList 区别"></a>ArrayList 和 LinkdList 区别</h3><ol><li>ArrayList的实现基于<strong>动态数组</strong>的数据结构，LinkedList基于<strong>链表</strong>的数据结构；</li><li>对于随机访问get和set，ArrayList优于LinkedList，因为LinkedList需要移动指针；</li><li>对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。<br>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</li></ol><h3 id="如何实现数组和-List-之间的转换"><a href="#如何实现数组和-List-之间的转换" class="headerlink" title="如何实现数组和 List 之间的转换"></a>如何实现数组和 List 之间的转换</h3><p>数组转 List：使用 Arrays. asList(array) 进行转换；<br>List 转数组：使用 List 自带的 toArray() 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// list to array</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">list. add(&quot;王磊&quot;);</span><br><span class="line">list. add(&quot;的博客&quot;);</span><br><span class="line">list. toArray();</span><br><span class="line">// array to list</span><br><span class="line">String[] array = new String[]&#123;&quot;王磊&quot;,&quot;的博客&quot;&#125;;</span><br><span class="line">Arrays. asList(array);</span><br></pre></td></tr></table></figure><h3 id="ArrayList-和-Vector-的区别"><a href="#ArrayList-和-Vector-的区别" class="headerlink" title="ArrayList 和 Vector 的区别"></a>ArrayList 和 Vector 的区别</h3><p>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的<br>性能：ArrayList 在性能方面要优于 Vector<br>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%</p><h3 id="Array-和-ArrayList-有何区别"><a href="#Array-和-ArrayList-有何区别" class="headerlink" title="Array 和 ArrayList 有何区别"></a>Array 和 ArrayList 有何区别</h3><p>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象;<br>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的;<br>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</p><h3 id="在-Queue-中-poll-和-remove-有什么区别"><a href="#在-Queue-中-poll-和-remove-有什么区别" class="headerlink" title="在 Queue 中 poll()和 remove()有什么区别"></a>在 Queue 中 poll()和 remove()有什么区别</h3><p>相同点：都是返回第一个元素，并在队列中删除返回的对象<br>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常<br>tip:</p><ol><li>queue的增加元素方法add和offer的区别在于，add方法在队列满的情况下将选择抛异常的方法来表示队列已经满了，而offer方法通过返回false表示队列已经满了；在有限队列的情况，使用offer方法优于add方法；</li><li>remove方法和poll方法都是删除队列的头元素，remove方法在队列为空的情况下将抛异常，而poll方法将返回null；</li><li>element和peek方法都是返回队列的头元素，但是不删除头元素，区别在与element方法在队列为空的情况下，将抛异常，而peek方法将返回null.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();</span><br><span class="line">queue. offer(&quot;string&quot;); // add</span><br><span class="line">System. out. println(queue. poll());</span><br><span class="line">System. out. println(queue. remove());</span><br><span class="line">System. out. println(queue. size());</span><br></pre></td></tr></table></figure></li></ol><h3 id="哪些集合类是线程安全的"><a href="#哪些集合类是线程安全的" class="headerlink" title="哪些集合类是线程安全的"></a>哪些集合类是线程安全的</h3><p>Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK 1.5 之后随着 Java. util. concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。</p><h3 id="迭代器-Iterator-是什么"><a href="#迭代器-Iterator-是什么" class="headerlink" title="迭代器 Iterator 是什么"></a>迭代器 Iterator 是什么</h3><p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p><h3 id="Iterator-怎么使用？有什么特点？"><a href="#Iterator-怎么使用？有什么特点？" class="headerlink" title="Iterator 怎么使用？有什么特点？"></a>Iterator 怎么使用？有什么特点？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; it = list. iterator();</span><br><span class="line">while(it. hasNext())&#123;</span><br><span class="line">  String obj = it. next();</span><br><span class="line">  System. out. println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p><h3 id="ConcurrentModificationException异常出现的原因"><a href="#ConcurrentModificationException异常出现的原因" class="headerlink" title="ConcurrentModificationException异常出现的原因"></a>ConcurrentModificationException异常出现的原因</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        list.add(2);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">        while(iterator.hasNext())&#123;</span><br><span class="line">            Integer integer = iterator.next();</span><br><span class="line">            if(integer==2)</span><br><span class="line">                list.remove(integer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上段代码是有问题的，会抛出ConcurrentModificationException异常。<br>原因：调用list.remove()方法导致modCount和expectedModCount的值不一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final void checkForComodification() &#123;</span><br><span class="line">    if (modCount != expectedModCount)</span><br><span class="line">    throw new ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决办法：在迭代器中如果要删除元素的话，需要调用Iterator类的remove方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        list.add(2);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">        while(iterator.hasNext())&#123;</span><br><span class="line">            Integer integer = iterator.next();</span><br><span class="line">            if(integer==2)</span><br><span class="line">                iterator.remove();   //注意这个地方</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="怎么确保一个集合不能被修改"><a href="#怎么确保一个集合不能被修改" class="headerlink" title="怎么确保一个集合不能被修改"></a>怎么确保一个集合不能被修改</h3><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来<strong>创建一个只读集合</strong>，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list. add(&quot;x&quot;);</span><br><span class="line">Collection&lt;String&gt; clist = Collections. unmodifiableCollection(list);</span><br><span class="line">clist. add(&quot;y&quot;); // 运行时此行报错</span><br><span class="line">System. out. println(list. size());</span><br></pre></td></tr></table></figure><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="并行和并发有什么区别"><a href="#并行和并发有什么区别" class="headerlink" title="并行和并发有什么区别"></a>并行和并发有什么区别</h3><ul><li>并行：多个处理器或多核处理器同时处理多个任务。</li><li>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。</li></ul><h3 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h3><p>一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</p><h3 id="守护线程是什么"><a href="#守护线程是什么" class="headerlink" title="守护线程是什么"></a>守护线程是什么</h3><p>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。</p><h3 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h3><p>常见回答</p><ul><li>继承 Thread 重写 run 方法；</li><li>实现 Runnable 接口；</li><li>实现 Callable 接口。</li></ul><p>下面做个较为全面的总结：</p><ol><li>继承Trhead类，作为线程对象存在（继承Thread对象）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class CreatThreadDemo1 extends Thread&#123;</span><br><span class="line">    /**</span><br><span class="line">     * 构造方法： 继承父类方法的Thread(String name)；方法</span><br><span class="line">     * @param name</span><br><span class="line">     */</span><br><span class="line">    public CreatThreadDemo1(String name)&#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (!interrupted())&#123;</span><br><span class="line">            System.out.println(getName()+&quot;线程执行了...&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(200);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CreatThreadDemo1 d1 = new CreatThreadDemo1(&quot;first&quot;);</span><br><span class="line">        CreatThreadDemo1 d2 = new CreatThreadDemo1(&quot;second&quot;);</span><br><span class="line"></span><br><span class="line">        d1.start();</span><br><span class="line">        d2.start();</span><br><span class="line"></span><br><span class="line">        d1.interrupt();  //中断第一个线程</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>常规方法，不多做介绍了，interrupted方法，是来判断该线程是否被中断。（终止线程不允许用stop方法，该方法不会施放占用的资源。所以我们在设计程序的时候，要按照中断线程的思维去设计，就像上面的代码一样）。</p><pre><code>* 让线程等待的方法Thread.sleep(200);//线程休息2msObject.wait();//让线程进入等待，直到调用Object的notify或者notifyAll，线程停止休眠</code></pre><ol start="2"><li>实现runnable接口，作为线程任务存在<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class CreatThreadDemo2 implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            System.out.println(&quot;线程执行了...&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //将线程任务传给线程对象</span><br><span class="line">        Thread thread = new Thread(new CreatThreadDemo2());</span><br><span class="line">        //启动线程</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>Runnable 只是来修饰线程所执行的任务，它不是一个线程对象。想要启动Runnable对象，必须将它放到一个线程对象里。</p><ol start="3"><li>匿名内部类创建线程对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class CreatThreadDemo3 extends Thread&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建无参线程对象</span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;线程执行了...&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">       //创建带线程任务的线程对象</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;线程执行了...&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        //创建带线程任务并且重写run方法的线程对象</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;runnable run 线程执行了...&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;override run 线程执行了...&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>创建带线程任务并且重写run方法的线程对象中，为什么只运行了Thread的run方法。通过查看Thread类的源码，我们可以看到Thread实现了Runnable接口，而Runnable接口里有一个run方法。所以，我们最终调用的重写的方法应该是Thread类的run方法。而不是Runnable接口的run方法。</p><ol start="4"><li>创建带返回值的线程（实现Callable接口）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class CreatThreadDemo4 implements Callable &#123;</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        CreatThreadDemo4 demo4 = new CreatThreadDemo4();</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;Integer&gt; task = new FutureTask&lt;Integer&gt;(demo4); //FutureTask最终实现的是runnable接口</span><br><span class="line"></span><br><span class="line">        Thread thread = new Thread(task);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;我可以在这里做点别的业务逻辑...因为FutureTask是提前完成任务&quot;);</span><br><span class="line">        //拿出线程执行的返回值</span><br><span class="line">        Integer result = task.get();</span><br><span class="line">        System.out.println(&quot;线程中运算的结果为:&quot;+result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //重写Callable接口的call方法</span><br><span class="line">    @Override</span><br><span class="line">    public Object call() throws Exception &#123;</span><br><span class="line">        int result = 1;</span><br><span class="line">        System.out.println(&quot;业务逻辑计算中...&quot;);</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>Callable接口介绍：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Computes a result, or throws an exception if unable to do so.</span><br><span class="line">     *</span><br><span class="line">     * @return computed result</span><br><span class="line">     * @throws Exception if unable to compute a result</span><br><span class="line">     */</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回指定泛型的call方法。然后调用FutureTask对象的get方法得到call方法的返回值。</p><ol start="5"><li><p>定时器Timer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class CreatThreadDemo5 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Timer timer = new Timer();</span><br><span class="line"></span><br><span class="line">        timer.schedule(new TimerTask() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;定时器线程执行了...&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,0,1000);   //延迟0，周期1s</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>线程池创建线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class CreatThreadDemo6 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建一个具有10个线程的线程池</span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(10);</span><br><span class="line">        long threadpoolUseTime = System.currentTimeMillis();</span><br><span class="line">        for (int i = 0;i&lt;10;i++)&#123;</span><br><span class="line">            threadPool.execute(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot;线程执行了...&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        long threadpoolUseTime1 = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;多线程用时&quot;+(threadpoolUseTime1-threadpoolUseTime));</span><br><span class="line">        //销毁线程池</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        threadpoolUseTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用java8新特性stream实现并发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class CreatThreadDemo7 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Integer&gt; values = Arrays.asList(10,20,30,40);</span><br><span class="line">        //parallel 平行的，并行的</span><br><span class="line">        int result = values.parallelStream().mapToInt(p -&gt; p*2).sum();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        //怎么证明它是并发处理呢</span><br><span class="line">        values.parallelStream().forEach(p-&gt; System.out.println(p));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">200</span><br><span class="line">40</span><br><span class="line">10</span><br><span class="line">20</span><br><span class="line">30</span><br></pre></td></tr></table></figure><h3 id="说一下runnable和callable区别"><a href="#说一下runnable和callable区别" class="headerlink" title="说一下runnable和callable区别"></a>说一下runnable和callable区别</h3><p>runnable 没有返回值，callable 可以拿到有返回值，callable 可以看作是 runnable 的补充。</p><h3 id="线程有哪些状态"><a href="#线程有哪些状态" class="headerlink" title="线程有哪些状态"></a>线程有哪些状态</h3><p>线程的状态：</p><ul><li>NEW 尚未启动</li><li>RUNNABLE 正在执行中</li><li>BLOCKED 阻塞的（被同步锁或者IO锁阻塞）</li><li>WAITING 永久等待状态</li><li>TIMED_WAITING 等待指定的时间重新被唤醒的状态</li><li>TERMINATED 执行完成</li></ul><h3 id="sleep-和-wait-有什么区别"><a href="#sleep-和-wait-有什么区别" class="headerlink" title="sleep() 和 wait() 有什么区别"></a>sleep() 和 wait() 有什么区别</h3><ul><li>类的不同：sleep() 来自 Thread，wait() 来自 Object。</li><li>释放锁：sleep() 不释放锁；wait() 释放锁。</li><li>用法不同：sleep() 时间到会自动恢复；wait() 可以使用notify()/notifyAll()直接唤醒。</li></ul><h3 id="notify-和-notifyAll-有什么区别"><a href="#notify-和-notifyAll-有什么区别" class="headerlink" title="notify()和 notifyAll()有什么区别"></a>notify()和 notifyAll()有什么区别</h3><p>notifyAll()会唤醒所有的线程，notify()只唤醒一个线程。notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</p><h3 id="线程的-run-和-start-有什么区别"><a href="#线程的-run-和-start-有什么区别" class="headerlink" title="线程的 run() 和 start() 有什么区别"></a>线程的 run() 和 start() 有什么区别</h3><p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</p><h3 id="创建线程池有哪几种方式？"><a href="#创建线程池有哪几种方式？" class="headerlink" title="创建线程池有哪几种方式？"></a>创建线程池有哪几种方式？</h3><p>线程池创建有七种方式，最核心的是最后一种：</p><ul><li>newSingleThreadExecutor()：它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；</li><li>newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过  60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；</li><li>newFixedThreadPool(int  nThreads)：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads  个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目  nThreads；</li><li>newSingleThreadScheduledExecutor()：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；</li><li>newScheduledThreadPool(int  corePoolSize)：和newSingleThreadScheduledExecutor()类似，创建的是个  ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；</li><li>newWorkStealingPool(int parallelism)：这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；</li><li>ThreadPoolExecutor()：是最原始的线程池创建，上面1-3创建方式都是对ThreadPoolExecutor的封装。</li></ul><p>常用为Executors提供的四种方法来创建线程池：</p><ol><li><p>newFixedThreadPool() :创建固定大小的线程池。</p></li><li><p>newCachedThreadPool(): 创建无限大小的线程池，线程池中线程数量不固定，可根据需求自动更改。</p></li><li><p>newSingleThreadPool() : 创建单个线程池，线程池中只有一个线程。</p></li><li><p>newScheduledThreadPool(): 创建固定大小的线程池，可以延迟或定时的执行任务。<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ExecutorService threadPool = Executors.newCachedThreadPool();</span><br><span class="line">    threadPool.execute(() -&gt; &#123;</span><br><span class="line">        for (int i = 0; i&lt; 20;i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    threadPool.shutdown();</span><br></pre></td></tr></table></figure><p> 线程池作用<br> 限制线程个数，避免线程过多导致系统运行缓慢或崩溃。<br> 不需要频繁的创建和销毁，节约资源、响应更快。</p></li></ol><h3 id="线程池都有哪些状态？"><a href="#线程池都有哪些状态？" class="headerlink" title="线程池都有哪些状态？"></a>线程池都有哪些状态？</h3><ul><li>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。</li><li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。</li><li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</li><li>TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。</li><li>TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</li></ul><h3 id="线程池中-submit-和-execute-方法有什么区别？"><a href="#线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="线程池中 submit() 和 execute() 方法有什么区别？"></a>线程池中 submit() 和 execute() 方法有什么区别？</h3><ul><li>execute()：只能执行 Runnable 类型的任务。</li><li>submit()：可以执行 Runnable 和 Callable 类型的任务。</li></ul><p>Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。</p><h3 id="在-Java-程序中怎么保证多线程的运行安全"><a href="#在-Java-程序中怎么保证多线程的运行安全" class="headerlink" title="在 Java 程序中怎么保证多线程的运行安全"></a>在 Java 程序中怎么保证多线程的运行安全</h3><ul><li>方法一：使用安全类，比如 Java. util. concurrent 下的类。</li><li>方法二：使用自动锁 synchronized。</li><li>方法三：使用手动锁 Lock。</li></ul><p>手动锁 Java 示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line">lock. lock();</span><br><span class="line">try &#123;</span><br><span class="line">    System. out. println(&quot;获得锁&quot;);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    // TODO: handle exception</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    System. out. println(&quot;释放锁&quot;);</span><br><span class="line">    lock. unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程中-synchronized-锁升级的原理是什么"><a href="#多线程中-synchronized-锁升级的原理是什么" class="headerlink" title="多线程中 synchronized 锁升级的原理是什么"></a>多线程中 synchronized 锁升级的原理是什么</h3><p>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p><p>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p><h3 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h3><p>当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p><h3 id="怎么防止死锁？"><a href="#怎么防止死锁？" class="headerlink" title="怎么防止死锁？"></a>怎么防止死锁？</h3><ul><li>尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。</li><li>尽量使用 Java. util. concurrent 并发类代替自己手写锁。</li><li>尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。</li><li>尽量减少同步的代码块</li></ul><h3 id="ThreadLocal-是什么？有哪些使用场景？"><a href="#ThreadLocal-是什么？有哪些使用场景？" class="headerlink" title="ThreadLocal 是什么？有哪些使用场景？"></a>ThreadLocal 是什么？有哪些使用场景？</h3><p>ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。<br>ThreadLocal 的经典使用场景是数据库连接和 session 管理等。</p><h3 id="说一下-synchronized-底层实现原理？"><a href="#说一下-synchronized-底层实现原理？" class="headerlink" title="说一下 synchronized 底层实现原理？"></a>说一下 synchronized 底层实现原理？</h3><p>synchronized 是由一对 monitorenter/monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在 Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能</p><h3 id="synchronized-和-volatile-的区别是什么？"><a href="#synchronized-和-volatile-的区别是什么？" class="headerlink" title="synchronized 和 volatile 的区别是什么？"></a>synchronized 和 volatile 的区别是什么？</h3><ul><li>volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。</li><li>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。</li><li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li></ul><h3 id="synchronized-和-Lock-有什么区别？"><a href="#synchronized-和-Lock-有什么区别？" class="headerlink" title="synchronized 和 Lock 有什么区别？"></a>synchronized 和 Lock 有什么区别？</h3><ul><li>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</li><li>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</li><li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li></ul><h3 id="synchronized-和-ReentrantLock-区别是什么？"><a href="#synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="synchronized 和 ReentrantLock 区别是什么？"></a>synchronized 和 ReentrantLock 区别是什么？</h3><p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进</p><p>主要区别如下：</p><ul><li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</li><li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li><li>ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。</li><li>volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。</li></ul><h3 id="说一下-atomic-的原理？"><a href="#说一下-atomic-的原理？" class="headerlink" title="说一下 atomic 的原理？"></a>说一下 atomic 的原理？</h3><p>atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><p>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p><h3 id="什么是-Java-序列化？什么情况下需要序列化？"><a href="#什么是-Java-序列化？什么情况下需要序列化？" class="headerlink" title="什么是 Java 序列化？什么情况下需要序列化？"></a>什么是 Java 序列化？什么情况下需要序列化？</h3><p>Java 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。<br>以下情况需要使用 Java 序列化：</p><ul><li>想把的内存中的对象状态保存到一个文件中或者数据库中时候；</li><li>想用套接字在网络上传送对象的时候；</li><li>想通过RMI（远程方法调用）传输对象的时候。</li></ul><h3 id="某些java类为什么要实现Serializable接口"><a href="#某些java类为什么要实现Serializable接口" class="headerlink" title="某些java类为什么要实现Serializable接口"></a>某些java类为什么要实现Serializable接口</h3><p>为了网络进行传输或者持久化</p><ul><li>除了实现Serializable接口还有什么序列化方式<ul><li>Json序列化</li><li>FastJson序列化</li><li>ProtoBuff序列化</li></ul></li></ul><h3 id="动态代理是什么？有哪些应用？"><a href="#动态代理是什么？有哪些应用？" class="headerlink" title="动态代理是什么？有哪些应用？"></a>动态代理是什么？有哪些应用？</h3><p>动态代理是运行时动态生成代理类。<br>动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端 mock、rpc，Java注解对象获取等。</p><h2 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h2><h2 id="Java-Web"><a href="#Java-Web" class="headerlink" title="Java Web"></a>Java Web</h2><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java基础知识点&quot;&gt;&lt;a href=&quot;#Java基础知识点&quot; class=&quot;headerlink&quot; title=&quot;Java基础知识点&quot;&gt;&lt;/a&gt;Java基础知识点&lt;/h2&gt;&lt;h3 id=&quot;简述什么是跨平台&quot;&gt;&lt;a href=&quot;#简述什么是跨平台&quot; class=&quot;
      
    
    </summary>
    
      <category term="java知识点整理" scheme="https://kepler-ecnu.github.io/categories/java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    
    
      <category term="java知识点" scheme="https://kepler-ecnu.github.io/tags/java%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Markdown入门教程</title>
    <link href="https://kepler-ecnu.github.io/2019/08/01/Markdown%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://kepler-ecnu.github.io/2019/08/01/Markdown入门教程/</id>
    <published>2019-08-01T09:29:41.128Z</published>
    <updated>2019-08-06T09:08:07.565Z</updated>
    
    <content type="html"><![CDATA[<p>&lt; !–more–&gt;</p><h2 id="斜体和粗体"><a href="#斜体和粗体" class="headerlink" title="斜体和粗体"></a>斜体和粗体</h2><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*斜体*或_斜体_  </span><br><span class="line">**粗体**</span><br><span class="line">***加粗斜体***</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><p>显示效果：<br><em>这是一段斜体</em><br><strong>这是一段粗体</strong><br><strong><em>这是一段加粗斜体</em></strong><br><del>这是一段删除线</del></p><h2 id="分级标题"><a href="#分级标题" class="headerlink" title="分级标题"></a>分级标题</h2><p>第一种写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这是一个一级标题</span><br><span class="line">==================</span><br><span class="line">这是一个二级标题</span><br><span class="line">------------------</span><br></pre></td></tr></table></figure><p>就是在文字的下一行增加不同的横线，不建议使用。<br>第二种写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><p>推荐使用这种方式，简单易记，不同级别的标题后面<code>#</code>不一样多，在<code>#</code>后需要空一格。</p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>Markdown 支持两种形式的链接语法：行内式和参考式两种形式，行内式一般用的较多。</p><h3 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h3><p><strong>语法说明：</strong><br><code>[]</code>里写链接文字，<code>()</code>里写链接地址，<code>()</code>中的<code>" "</code>可以为链接指定title属性，title属性可加可不加。title属性效果是鼠标悬停在链接上会出现指定的title文字。<code><a href="链接地址" title="链接标题">链接文字</a></code>这样的形式。注：链接地址与链接标题间有一个空格。<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">欢迎访问[我的博客](https://kepler-ecnu.github.io/)</span><br><span class="line">欢迎访问[我的博客](https://kepler-ecnu.github.io/ &quot;kepler&apos;s blog&quot;)</span><br></pre></td></tr></table></figure><p>显示效果：<br>欢迎访问<a href="https://kepler-ecnu.github.io/">我的博客</a><br>欢迎访问<a href="https://kepler-ecnu.github.io/" title="kepler&#39;s blog">我的博客</a> 这个设置了标题，在鼠标指在超链接上时显示标题。</p><h3 id="参考式"><a href="#参考式" class="headerlink" title="参考式"></a>参考式</h3><p>参考式超链接一般用在学术论文上，或者若某一个链接在文章中多出使用，则使用引用的方式创建链接，这样可以对链接进行同意的管理。<br><strong>语法说明：</strong><br>参考式链接分为两部分，文中的写法<code>[链接文字][链接标记]</code>，在文本的任意位置添加[链接文字]:链接地址 “链接标记”，链接地址与链接标记间一个空格。<br>如果链接文字本身可以作为链接标记，也可以写成<code>[链接文字][]</code><br>[链接文字]：链接地址的形式，见代码的最后一行。<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我经常访问的网站[baidu][1]、[bilibili][2]等</span><br><span class="line">[B站][2]有我整理的[音乐合集][]。</span><br><span class="line">[1]:https://www.baidu.com/ &quot;baidu&quot;</span><br><span class="line">[2]:https://space.bilibili.com/12737596 &quot;bilibili&quot;</span><br><span class="line">[音乐合集]:https://space.bilibili.com/12737596</span><br></pre></td></tr></table></figure><h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><p><strong>语法说明</strong><br>Markdown支持较简短的自动链接形式来处理网址和电子邮箱，只要是用<code><></code>包起来，Markdown就会自动把它转成链接。一般网址的链接文字和链接地址一样，如：<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;https://space.bilibili.com/12737596&gt;</span><br><span class="line">&lt;address@example.com&gt;</span><br></pre></td></tr></table></figure><p>显示效果：<br><a href="https://space.bilibili.com/12737596" target="_blank" rel="noopener">https://space.bilibili.com/12737596</a><br><a href="mailto:&#x61;&#x64;&#100;&#x72;&#101;&#x73;&#x73;&#x40;&#x65;&#x78;&#97;&#109;&#112;&#x6c;&#x65;&#x2e;&#99;&#x6f;&#109;" target="_blank" rel="noopener">&#x61;&#x64;&#100;&#x72;&#101;&#x73;&#x73;&#x40;&#x65;&#x78;&#97;&#109;&#112;&#x6c;&#x65;&#x2e;&#99;&#x6f;&#109;</a></p><h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><p>网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中<br>的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。<br>在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。<br><strong>语法描述：</strong><br>在你准备跳转到的指定标题后插入锚点,然后在文档的其它地方写上链接到锚点的链接。（这里不展开）</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>使用<code>*，+，-</code>表示无序列表<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 无序列表项一</span><br><span class="line">+ 无序列表项二</span><br><span class="line">- 无序列表项三</span><br></pre></td></tr></table></figure><p>显示效果：</p><ul><li>无序列表项一</li></ul><ul><li>无序列表项二</li></ul><ul><li>无序列表项三</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>有序列表则使用数字接着一个英文句点，接着空一个格写列表项。<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 有序列表项一</span><br><span class="line">2. 有序列表项二</span><br><span class="line">3. 有序列表项三</span><br></pre></td></tr></table></figure><p>显示效果：</p><ol><li>有序列表项一</li><li>有序列表项二</li><li>有序列表项三  </li></ol><h3 id="定义型列表"><a href="#定义型列表" class="headerlink" title="定义型列表"></a>定义型列表</h3><p><strong>语法说明：</strong><br>定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法<code>:</code>紧跟一个缩进（Tab）</p><h3 id="列表缩进"><a href="#列表缩进" class="headerlink" title="列表缩进"></a>列表缩进</h3><p><strong>语法说明</strong><br>列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3个空格，项目标记后面则一定要接着至少一个空格或制表符。<br>要让列表看起来更漂亮，你可以把内容用固定的缩进整理好（显示效果与代码一致）：<br>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。<br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！<br>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。<br>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。<br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！<br>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。<br>但是如果你懒，那也行：<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。</span><br><span class="line">那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。</span><br><span class="line">软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！</span><br><span class="line">* 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。</span><br><span class="line">寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。</span><br><span class="line">但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！</span><br><span class="line">悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</span><br></pre></td></tr></table></figure><p>显示效果：</p><ul><li>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。<br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！</li><li>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。<br>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。<br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！<br>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。<h3 id="包含段落的列表"><a href="#包含段落的列表" class="headerlink" title="包含段落的列表"></a>包含段落的列表</h3>列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符（显示效果与代码一致）：<br>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。<br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！<br>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。<br>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。<br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！<br>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。<br>但是如果你懒，那也行：<br>代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。</span><br><span class="line">那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。</span><br><span class="line">软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！</span><br><span class="line">*那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。</span><br><span class="line">寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。</span><br><span class="line">但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！</span><br><span class="line">悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</span><br></pre></td></tr></table></figure>显示效果：</li><li>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。<br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！</li><li>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。<br>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。<br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！<br>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</li></ul><h3 id="包含引用的列表"><a href="#包含引用的列表" class="headerlink" title="包含引用的列表"></a>包含引用的列表</h3><p><strong>语法说明：</strong><br>如果要在列表项目内放进引用，那 &gt; 就需要缩进：<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*阅读的方法：</span><br><span class="line">&gt; 拿出书本</span><br><span class="line">&gt; 放下手机</span><br><span class="line">&gt; 开始看吧</span><br></pre></td></tr></table></figure><p>显示效果：</p><ul><li>阅读的方法：<blockquote><p>拿出书本<br>放下手机<br>开始看吧</p></blockquote></li></ul><h3 id="包含代码区块的引用"><a href="#包含代码区块的引用" class="headerlink" title="包含代码区块的引用"></a>包含代码区块的引用</h3><p><strong>语法说明：</strong><br>如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：<br>一列表项包含一个列表区块：<br>        写代码块的地方</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><strong>语法说明：</strong><br>引用需要在被引用的文本前加上 &gt; 符号。<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这是一个有两段文字的引用</span><br><span class="line">&gt; text1</span><br><span class="line">&gt; text2</span><br><span class="line">&gt;</span><br><span class="line">&gt; text3</span><br><span class="line">&gt; text4</span><br></pre></td></tr></table></figure><p>显示效果：</p><blockquote><p>这是一个有两段文字的引用<br>text1<br>text2</p><p>text3<br>text4</p></blockquote><h3 id="引用的多层嵌套"><a href="#引用的多层嵌套" class="headerlink" title="引用的多层嵌套"></a>引用的多层嵌套</h3><p>区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ：<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这是一个有两段文字的引用</span><br><span class="line">&gt;&gt; text1</span><br><span class="line">&gt;&gt;&gt; text2</span><br><span class="line">&gt;</span><br><span class="line">&gt; text3</span><br><span class="line">&gt; text4</span><br></pre></td></tr></table></figure><p>显示效果：</p><blockquote><p>这是一个有两段文字的引用</p><blockquote><p>text1</p><blockquote><p>text2</p></blockquote></blockquote><p>text3<br>text4</p></blockquote><h3 id="引用的其它要素"><a href="#引用的其它要素" class="headerlink" title="引用的其它要素"></a>引用的其它要素</h3><p>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; 1. 第一列表项</span><br><span class="line">&gt; 2. 第二列表项</span><br><span class="line">&gt;&gt; text1</span><br><span class="line">&gt;&gt;&gt; text2</span><br><span class="line">&gt;</span><br><span class="line">&gt; return shell_exec(&quot;echo $input | $markdown_script&quot;);</span><br><span class="line">&gt; `return shell_exec(&quot;echo $input | $markdown_script&quot;);`</span><br></pre></td></tr></table></figure><p>显示效果：</p><blockquote><ol><li><p>第一列表项</p></li><li><p>第二列表项</p><blockquote><p>text1</p><blockquote><p>text2</p></blockquote></blockquote><pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);</code></pre><p><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);</code></p></li></ol></blockquote><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。<br>语法中图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。</p><h3 id="行内式-1"><a href="#行内式-1" class="headerlink" title="行内式"></a>行内式</h3><p><strong>语法说明：</strong><code>![图片Alt](图片地址 "图片Title")</code><br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![图片示例](http://img.redocn.com/sheji/20141219/zhongguofengdaodeliyizhanbanzhijing_3744115.jpg &quot;图片示例&quot;)</span><br></pre></td></tr></table></figure><p>显示效果：<br><img src="http://img.redocn.com/sheji/20141219/zhongguofengdaodeliyizhanbanzhijing_3744115.jpg" alt="图片示例" title="图片示例"></p><h3 id="参考式-1"><a href="#参考式-1" class="headerlink" title="参考式"></a>参考式</h3><p><strong>语法说明：（这里不作介绍）</strong><br>在文档要插入图片的地方写<code>![图片Alt][标记]</code><br>在文档的最后写上写<code>[标记]:图片地址 “Title”</code></p><h2 id="内容目录"><a href="#内容目录" class="headerlink" title="内容目录"></a>内容目录</h2><p>在段落中填写 [TOC] 以显示全文内容的目录结构。<br>Hexo博客对目录的解析似乎也有限，请在Markdown编辑器中自行尝试。Next主题的话是也可以自动生成目录的，所以不需要额外增加目录。</p><h2 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h2><p><strong>语法说明：</strong><br>在需要添加注脚的文字后加上<code>脚注名字[^脚注名字]</code>，称为加注。然后在文本的任意位置（一般在最后）添加脚注，脚注前必须有对应的脚注名字。<br>注意：经测试注脚和脚注之间必须空一行，不然会失效。成功后会发现，即使没有把注脚卸载文末，经Markdown转换后，也会自动归类到文章的最后。<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。</span><br><span class="line">[^1]: Markdown是一种纯文本标记语言</span><br><span class="line">[^2]: HyperText Markup Language 超文本标记语言</span><br><span class="line">[^Le]: 开源笔记平台，支持Markdown和笔记直接发为博文</span><br></pre></td></tr></table></figure><p>显示效果：<br>使用 Markdown<a href="Markdown是一种纯文本标记语言">^1</a>可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。</p><p>[^2]: HyperText Markup Language 超文本标记语言<br>[^Le]: 开源笔记平台，支持Markdown和笔记直接发为博文</p><h2 id="LaTex公式"><a href="#LaTex公式" class="headerlink" title="LaTex公式"></a>LaTex公式</h2><h3 id="表示行内公式"><a href="#表示行内公式" class="headerlink" title="$表示行内公式"></a>$表示行内公式</h3><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。</span><br></pre></td></tr></table></figure><p>显示效果：<br>质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。<br>注意：我的博客没有开启公式显示，所以可能公式显示不准确，请自己用Markdown编辑器查看效果</p><h3 id="表示整行公式"><a href="#表示整行公式" class="headerlink" title="$表示整行公式"></a>$表示整行公式</h3><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$\sum_&#123;i=1&#125;^n a_i=0$$</span><br><span class="line">$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$</span><br><span class="line">$$\sum^&#123;j-1&#125;_&#123;k=0&#125;&#123;\widehat&#123;\gamma&#125;_&#123;kj&#125; z_k&#125;$$</span><br></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p><strong>语法说明：</strong><br>不管是哪种方式，第一行为表头，第二行分割表头和主体部分，第三行开始每一行为一个表格行。<br>列与列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。<br>第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">简单方式写表格：</span><br><span class="line"></span><br><span class="line">学号|姓名|分数</span><br><span class="line">-|-|-</span><br><span class="line">小明|男|75</span><br><span class="line">小红|女|79</span><br><span class="line">小陆|男|92</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原生方式写表格：</span><br><span class="line"></span><br><span class="line">| 学号 | 姓名 | 分数 |</span><br><span class="line">| ---- | ---- | ---- |</span><br><span class="line">| 小明 | 男   | 75   |</span><br><span class="line">| 小红 | 女   | 79   |</span><br><span class="line">| 小陆 | 男   | 92   |</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">为表格第二列指定方向：</span><br><span class="line"></span><br><span class="line">| 产品             |     价格 |</span><br><span class="line">| ---------------- | -------: |</span><br><span class="line">| Leanote 高级账号 |  60元/年 |</span><br><span class="line">| Leanote 超级账号 | 120元/年 |</span><br></pre></td></tr></table></figure><p>显示效果：<br>简单方式写表格：</p><table><thead><tr><th>学号</th><th>姓名</th><th>分数</th></tr></thead><tbody><tr><td>小明</td><td>男</td><td>75</td></tr><tr><td>小红</td><td>女</td><td>79</td></tr><tr><td>小陆</td><td>男</td><td>92</td></tr></tbody></table><p>原生方式写表格：</p><table><thead><tr><th>学号</th><th>姓名</th><th>分数</th></tr></thead><tbody><tr><td>小明</td><td>男</td><td>75</td></tr><tr><td>小红</td><td>女</td><td>79</td></tr><tr><td>小陆</td><td>男</td><td>92</td></tr></tbody></table><p>为表格第二列指定方向：</p><table><thead><tr><th>产品</th><th align="right">价格</th></tr></thead><tbody><tr><td>Leanote 高级账号</td><td align="right">60元/年</td></tr><tr><td>Leanote 超级账号</td><td align="right">120元/年</td></tr></tbody></table><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分割线，行内不能有其他东西。也可以在星号或是减号中间插入空格。下面每种写法都可以建立分割线：<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* * *</span><br><span class="line">***</span><br><span class="line">*****</span><br><span class="line">- - -</span><br><span class="line">---------------------------------------</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(Tab), 另一种是利用”`”符号（一般在ESC键下方）包裹代码。<br><strong>语法说明：</strong><br>插入行内代码，即插入一个单词或者一句代码的情况，使用&lt;code&gt;这样的形式插入。<br>插入多行代码，可以使用缩进或者“code “,具体看示例。<br>注意： 缩进式插入前方必须有空行</p><h3 id="行内式-2"><a href="#行内式-2" class="headerlink" title="行内式"></a>行内式</h3><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C语言里的函数 `scanf()` 怎么使用？</span><br></pre></td></tr></table></figure><p>显示效果：<br>C语言里的函数 <code>scanf()</code> 怎么使用？</p><h3 id="缩进式多行代码"><a href="#缩进式多行代码" class="headerlink" title="缩进式多行代码"></a>缩进式多行代码</h3><p>缩进4个空格或是一个制表符（Tab）<br>一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Hello world\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示效果：</p><p>#include &lt;stdio.h&gt;<br>int main(void)<br>{<br>    printf(“Hello world\n”);<br>}</p><h3 id="用三个”-”包裹多行代码"><a href="#用三个”-”包裹多行代码" class="headerlink" title="用三个” `”包裹多行代码"></a>用三个” `”包裹多行代码</h3><p>输入三个<code>后空一行写代码，结束后另起一行输入三个</code>表示代码块的结束</p><h2 id="HTML-原始码"><a href="#HTML-原始码" class="headerlink" title="HTML 原始码"></a>HTML 原始码</h2><p>Markdown支持很多HTML代码，具体不展开。</p>]]></content>
    
    <summary type="html">
    
      Markdown入门使用
    
    </summary>
    
      <category term="博客搭建" scheme="https://kepler-ecnu.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Markdown" scheme="https://kepler-ecnu.github.io/tags/Markdown/"/>
    
  </entry>
  
</feed>
