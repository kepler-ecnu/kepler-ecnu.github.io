<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>The real world</title>
  
  <subtitle>You can do something</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kepler-ecnu.github.io/"/>
  <updated>2019-08-06T15:06:20.584Z</updated>
  <id>https://kepler-ecnu.github.io/</id>
  
  <author>
    <name>kepler</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java知识点整理(不间断更新)</title>
    <link href="https://kepler-ecnu.github.io/2019/08/06/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <id>https://kepler-ecnu.github.io/2019/08/06/Java知识点整理/</id>
    <published>2019-08-06T05:20:21.000Z</published>
    <updated>2019-08-06T15:06:20.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java基础知识点"><a href="#Java基础知识点" class="headerlink" title="Java基础知识点"></a>Java基础知识点</h2><h3 id="简述什么是跨平台"><a href="#简述什么是跨平台" class="headerlink" title="简述什么是跨平台"></a>简述什么是跨平台</h3><p>由于各种操作系统所支持的指令集不是完全一致的，所以在操作系统上加个虚拟机来提供统一接口，屏蔽系统之间的差异。</p><h3 id="Java有几种基本数据类型"><a href="#Java有几种基本数据类型" class="headerlink" title="Java有几种基本数据类型"></a>Java有几种基本数据类型</h3><p>有八种基本数据类型:</p><table><thead><tr><th>数据类型</th><th>字节</th><th>默认值</th></tr></thead><tbody><tr><td>byte</td><td>1</td><td>0</td></tr><tr><td>char</td><td>4</td><td>‘\u0000’</td></tr><tr><td>boolean</td><td>1</td><td>false</td></tr><tr><td>float</td><td>4</td><td>0.0f</td></tr><tr><td>double</td><td>8</td><td>0.0d</td></tr><tr><td>int</td><td>4</td><td>0</td></tr><tr><td>short</td><td>2</td><td>0</td></tr><tr><td>long</td><td>8</td><td>0</td></tr></tbody></table><h3 id="面向对象特征"><a href="#面向对象特征" class="headerlink" title="面向对象特征"></a>面向对象特征</h3><p>面向对象的编程语言有<strong>封装、继承、多态、抽象</strong>四个主要特征。</p><ul><li>封装：把描述一个对象的属性和行为封装在一个模块中，即一个类中，属性用变量定义，行为用方法定义，方法可以直接访问同一个对象中的属性。</li><li>抽象：把现实生活中的对象抽象为类。分为过程抽象和数据抽象<ul><li>过程抽象：类的方法（鸟会啼鸣等）</li><li>数据抽象：类的属性（鸟有翅膀等）</li></ul></li><li>继承：子类继承父类的特征和行为。子类可以有父类非私有的方法，也可以对父类进行扩展，也可以重写父类的方法。缺点就是提高了代码间的耦合性。</li><li>多态：<ul><li>编译时多态：方法的重载</li><li>运行时多态：向上转型、方法重写–基于继承</li></ul></li></ul><h3 id="面向对象六大原则"><a href="#面向对象六大原则" class="headerlink" title="面向对象六大原则"></a>面向对象六大原则</h3><ol><li><strong>单一职责</strong>原则—-SRP<ul><li>让每个类只专心处理自己的方法</li></ul></li><li><strong>开闭</strong>原则—-OCP<ul><li>软件中的对象（类、模块、函数等）应该<strong>对于扩展开放</strong>，<strong>对于修改是关闭</strong>的</li></ul></li><li><strong>里氏替换</strong>原则—-LSP<ul><li>子类可以去扩展父类，但是不能改变父类原有的功能</li></ul></li><li><strong>依赖倒置</strong>原则—-DIP<ul><li>应该通过调用接口或抽象类，而不是调用实现类</li></ul></li><li><strong>接口隔离</strong>原则—-ISP<ul><li>把接口分为满足依赖关系的最小接口，实现类中不能有不需要的方法</li></ul></li><li><strong>迪米特</strong>原则—-LOP<ul><li>高内聚、低耦合</li></ul></li></ol><h3 id="String属于基础的数据类型吗"><a href="#String属于基础的数据类型吗" class="headerlink" title="String属于基础的数据类型吗"></a>String属于基础的数据类型吗</h3><p>String不属于基础类型，基础类型有type、boolean、int、char、short、long、float、double，而String属于包装器类型</p><h3 id="为什么要有包装类型"><a href="#为什么要有包装类型" class="headerlink" title="为什么要有包装类型"></a>为什么要有包装类型</h3><p>为了让基本数据类型也具有对象的特征，就出现了包装类型（如在使用集合类型Collection时就一定要使用包装类型而不是基本数据类型）。因为容器都是装object的，这时就需要这些基本数据类型的包装类型了。</p><table><thead><tr><th>基本类型</th><th>包装器类型</th></tr></thead><tbody><tr><td>boolean</td><td>Boolean</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr></tbody></table><h3 id="自动装箱和自动拆箱"><a href="#自动装箱和自动拆箱" class="headerlink" title="自动装箱和自动拆箱"></a>自动装箱和自动拆箱</h3><p>自动装箱：<code>new Integer(6)</code>，底层调用：<code>Integer.valueOf(6)</code>；<br>自动拆箱：<code>int i = new Integer(6)</code>，底层调用：<code>i.intValue();</code><br>二者的区别：</p><ul><li>声明方式不同：基本数据类型不使用new关键字，而包装类型需要使用new关键字在<strong>堆中分配存储空间</strong>；</li><li>存储方式及位置不同：基本数据类型是直接将变量值存储在<strong>栈</strong>中，而包装类型是将对象放在<strong>堆</strong>中，然后通过<strong>引用</strong>来使用；</li><li>初始值不同：基本数据类型的初始值如int为0，boolean为false，而包装类型的初始值为null；</li><li>使用方式不同：基本数据类型赋值直接使用就好，而包装类型在集合如Collection、Map时会使用到。</li></ul><h3 id="String-str-“i”-与-String-str-new-String-“i”-一样么"><a href="#String-str-“i”-与-String-str-new-String-“i”-一样么" class="headerlink" title="String str = “i” 与 String str = new String(“i”)一样么"></a>String str = “i” 与 String str = new String(“i”)一样么</h3><p>不一样，因为内存的分配方式不一样。<code>String str = "i"</code>的方式，Java虚拟机会将其分配到常量池中；<code>String str = new String("i")</code>则会被分到堆内存中。</p><h3 id="如何将字符串反转"><a href="#如何将字符串反转" class="headerlink" title="如何将字符串反转"></a>如何将字符串反转</h3><p>使用StringBuilder或者StringBuffer的reverse()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// StringBuffer reverse</span><br><span class="line">StringBuffer stringBuffer = new StringBuffer();</span><br><span class="line">stringBuffer. append(&quot;abcdefg&quot;);</span><br><span class="line">System. out. println(stringBuffer. reverse()); // gfedcba</span><br><span class="line">// StringBuilder reverse</span><br><span class="line">StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">stringBuilder. append(&quot;abcdefg&quot;);</span><br><span class="line">System. out. println(stringBuilder. reverse()); // gfedcba</span><br></pre></td></tr></table></figure><h3 id="String-类常用方法"><a href="#String-类常用方法" class="headerlink" title="String 类常用方法"></a>String 类常用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">indexOf()：返回指定字符的索引。</span><br><span class="line">charAt()：返回指定索引处的字符。</span><br><span class="line">replace()：字符串替换。</span><br><span class="line">trim()：去除字符串两端空白。</span><br><span class="line">split()：分割字符串，返回一个分割后的字符串数组。</span><br><span class="line">getBytes()：返回字符串的 byte 类型数组。</span><br><span class="line">length()：返回字符串长度。</span><br><span class="line">toLowerCase()：将字符串转成小写字母。</span><br><span class="line">toUpperCase()：将字符串转成大写字符。</span><br><span class="line">substring()：截取字符串。</span><br><span class="line">equals()：字符串比较。</span><br></pre></td></tr></table></figure><h3 id="和-equals-区别"><a href="#和-equals-区别" class="headerlink" title="== 和 equals 区别"></a>== 和 equals 区别</h3><ul><li><p>== 比较的是<strong>两个引用</strong>在内存中指向的是不是同一对象（即同一内存空间），也就是说在内存中的存储位置是否一致。如果两个对象的引用相同时（指向同一对象时），== 操作符返回true,否则返回false。</p><ul><li><p>对于基本类型和引用类型 == 的作用效果是不同的：<br>基本类型：比较的是值是否相同；<br>引用类型：比较的是引用是否相同；<br>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String x = &quot;string&quot;;</span><br><span class="line">String y = &quot;string&quot;;</span><br><span class="line">String z = new String(&quot;string&quot;);</span><br><span class="line">System.out.println(x==y); // true</span><br><span class="line">System.out.println(x==z); // false</span><br><span class="line">System.out.println(x.equals(y)); // true</span><br><span class="line">System.out.println(x.equals(z)); // true</span><br></pre></td></tr></table></figure><p>代码解读：因为 x 和 y 指向的是同一个引用，所以 == 是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true</p></li></ul></li><li><p>equals 用来比较<strong>某些特征</strong>是否一样，本质上就是 == ，只不过String和Integer等重写了equals方法，把它变成了值比较。<br>首先看默认情况下equals比较一个有相同值的对象，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Cat &#123;</span><br><span class="line">    public Cat(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private String name;</span><br><span class="line"> </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Cat c1 = new Cat(&quot;王磊&quot;);</span><br><span class="line">Cat c2 = new Cat(&quot;王磊&quot;);</span><br><span class="line">System.out.println(c1.equals(c2)); // false</span><br></pre></td></tr></table></figure></li></ul><p>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">        return (this == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来 equals 本质上就是 ==。<br>那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = new String(&quot;老王&quot;);</span><br><span class="line">String s2 = new String(&quot;老王&quot;);</span><br><span class="line">System.out.println(s1.equals(s2)); // true</span><br></pre></td></tr></table></figure><p>同样的，当我们进入 String 的 equals方法，找到了答案，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">        if (this == anObject) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (anObject instanceof String) &#123;</span><br><span class="line">            String anotherString = (String)anObject;</span><br><span class="line">            int n = value.length;</span><br><span class="line">            if (n == anotherString.value.length) &#123;</span><br><span class="line">                char v1[] = value;</span><br><span class="line">                char v2[] = anotherString.value;</span><br><span class="line">                int i = 0;</span><br><span class="line">                while (n-- != 0) &#123;</span><br><span class="line">                    if (v1[i] != v2[i])</span><br><span class="line">                        return false;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。<br><strong>总结：</strong> == 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重写了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p><h3 id="String、StringBuffer和StringBuilder区别"><a href="#String、StringBuffer和StringBuilder区别" class="headerlink" title="String、StringBuffer和StringBuilder区别"></a>String、StringBuffer和StringBuilder区别</h3><ul><li><p>数据可变和不可变</p><ul><li>String底层使用一个不可变的字符数组<code>private final char value[]</code>，所以它的内容不可变</li><li>StringBuffer和StringBuilder都继承了AbstractStringBuilder底层使用的是可变字符数组：<code>char[] value;</code></li></ul></li><li><p>线程安全性</p><ul><li>StringBulider是线程不安全的，效率较高；而StringBuffer是线程安全的，效率较低；<br>通过他们的append()方法来看，SpringBuffer是有同步锁，而StringBuilder没有：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public synchronized StringBuffer append(Object obj) &#123;</span><br><span class="line">    toStringCache = null;</span><br><span class="line">    super.append(String.valueOf(obj));</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public StringBuilder append(String str) &#123;</span><br><span class="line">    super.append(str);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>相同点<br>StringBuilder与StringBuffer有公共父类AbstractBuilder；<br>最后，操作可变字符串速度：<strong>StringBuilder &gt; StringBuffer &gt; String</strong>。</p></li></ul><h3 id="两个对象的-hashCode-相同，则equals-也一定为true，对吗？"><a href="#两个对象的-hashCode-相同，则equals-也一定为true，对吗？" class="headerlink" title="两个对象的 hashCode()相同，则equals()也一定为true，对吗？"></a>两个对象的 hashCode()相同，则equals()也一定为true，对吗？</h3><p>不对，两个对象的HashCode()相同，equals()不一定true。<br>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;通话&quot;;</span><br><span class="line">String str2 = &quot;重地&quot;;</span><br><span class="line">System. out. println(String. format(&quot;str1：%d | str2：%d&quot;,  str1. hashCode(),str2. hashCode()));</span><br><span class="line">System. out. println(str1. equals(str2));</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1：1179395 | str2：1179395</span><br><span class="line"> </span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p><h3 id="两个对象值相同-x-equals-y-true-，Hashcode是否一定相同"><a href="#两个对象值相同-x-equals-y-true-，Hashcode是否一定相同" class="headerlink" title="两个对象值相同(x.equals(y)==true)，Hashcode是否一定相同"></a>两个对象值相同(x.equals(y)==true)，Hashcode是否一定相同</h3><p>第一种情况：假如这个类没有重写equals方法，如果两个对象值相同，那么他们的hashCode值一定相同；<br>第二种情况：如果重写了equals方法，但没有重写hashCode方法，就会出现不相等的情况。<br><strong>Java对于equals方法和hashCode方法的规定</strong></p><ol><li>如果两个对象相同，那么他们的hashCode值一定要相同；</li><li>如果两个对象的hashCode相同，他们并不一定相同（这里说的对象相同指的是用equals方法比较）；</li><li>equals()相等的两个对象，hashCode()一定相等；equals()不相等的两个对象，却并不能证明他们的hashCode()不相等。<br>换句话说，equals()方法不相等的两个对象，hashCode()有可能相等（我的理解是由于哈希码在生成的时候产生冲突造成的）。反过来，hashCode()不等，一定能推出equals()也不等；hashCode()相等，equals()可能相等，也可能不等。</li></ol><h3 id="什么时候需要重写equals方法和hashCode方法"><a href="#什么时候需要重写equals方法和hashCode方法" class="headerlink" title="什么时候需要重写equals方法和hashCode方法"></a>什么时候需要重写equals方法和hashCode方法</h3><p>如果想完整的使用HashSet类(或TreeSet等)，最少需要重写equals()和hashCode()方法</p><ol><li>重写hashCode()用于获得元素的存储位置；</li><li>重写equals()用于在两个元素的位置相同的时候，比较两个元素是否相等。<br>分析原因如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hashCode </span><br><span class="line">        public int hashCode()返回该对象的哈希码值。支持此方法是为了提高哈希表（例如 Java.util.Hashtable 提供的哈希表）的性能。</span><br><span class="line">        hashCode 的常规协定是： </span><br><span class="line">        在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。 </span><br><span class="line">        如果根据 equals(Object) 方法，两个对象是相等的，那么对这两个对象中的每个对象调用 hashCode 方法都必须生成相同的整数结果。 </span><br><span class="line">        如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么对这两个对象中的任一对象上调用 hashCode 方法不 要求一定生成不同的整数结果。但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能。 </span><br><span class="line">        实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。）</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">equals </span><br><span class="line">public boolean equals(Object obj)指示其他某个对象是否与此对象“相等”。 </span><br><span class="line">equals 方法在非空对象引用上实现相等关系： </span><br><span class="line"></span><br><span class="line">自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true。 </span><br><span class="line">对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。 </span><br><span class="line">传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。 </span><br><span class="line">一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。 </span><br><span class="line">对于任何非空引用值 x，x.equals(null) 都应返回 false。 </span><br><span class="line">Object 类的 equals 方法实现对象上差别可能性最大的相等关系；即，对于任何非空引用值 x 和 y，当且仅当 x 和 y 引用同一个对象时，此方法才返回 true（x == y 具有值 true）。</span><br></pre></td></tr></table></figure><h3 id="ArrayList-和-LinkdList-区别"><a href="#ArrayList-和-LinkdList-区别" class="headerlink" title="ArrayList 和 LinkdList 区别"></a>ArrayList 和 LinkdList 区别</h3><ol><li>ArrayList的实现基于<strong>动态数组</strong>的数据结构，LinkedList基于<strong>链表</strong>的数据结构；</li><li>对于随机访问get和set，ArrayList优于LinkedList，因为LinkedList需要移动指针；</li><li>对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。</li></ol><h3 id="final在Java中有什么作用"><a href="#final在Java中有什么作用" class="headerlink" title="final在Java中有什么作用"></a>final在Java中有什么作用</h3><ol><li>修饰类，则该类不能被继承；</li><li>修饰方法，则该方法不能被重写；</li><li>修饰变量，修饰的变量叫常量，必须初始化，且初始化后值不能被修改。</li></ol><h3 id="Java中-Math-round-1-5-等于多少？Math-round-2-5-等于多少？"><a href="#Java中-Math-round-1-5-等于多少？Math-round-2-5-等于多少？" class="headerlink" title="Java中 Math.round(-1.5)等于多少？Math.round(-2.5)等于多少？"></a>Java中 Math.round(-1.5)等于多少？Math.round(-2.5)等于多少？</h3><p>答案：-1，-2<br>注意：不要认为它是四舍五入<br>计算口诀：+0.5后向下取整即可<br>同理Math.round(-2.6)结果和Math.round(2.6)结果分别为-3，3</p><h3 id="抽象类必须要有抽象方法吗？"><a href="#抽象类必须要有抽象方法吗？" class="headerlink" title="抽象类必须要有抽象方法吗？"></a>抽象类必须要有抽象方法吗？</h3><p>不需要，抽象类不一定非要抽象方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abstract class Cat &#123;</span><br><span class="line">        public static void sayHi() &#123;</span><br><span class="line">            System. out. println(&quot;hi~&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="普通类和抽象类有哪些区别"><a href="#普通类和抽象类有哪些区别" class="headerlink" title="普通类和抽象类有哪些区别"></a>普通类和抽象类有哪些区别</h3><p>普通类不能包含抽象方法，抽象类可以包含抽象方法<br>抽象类不能直接实例化，普通类可以直接实例化</p><h3 id="抽象类能使用final修饰吗"><a href="#抽象类能使用final修饰吗" class="headerlink" title="抽象类能使用final修饰吗"></a>抽象类能使用final修饰吗</h3><p>不能，定义抽象类就是让其他类继承的，如果定义为final该类就不能被继承，这样彼此就会产生矛盾，所以final不能修饰抽象类。</p><h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><ul><li>实现：抽象类的子类使用extends来继承；接口必须使用implements来实现接口；</li><li>构造函数：抽象类有构造函数；接口不能有；</li><li>实现数量：类可以实现多个接口，但是只能继承一个抽象类；</li><li>访问修饰符：抽象类中的抽象方法(其前有abstract修饰)不能用private、static、synchronized、native访问修饰符修饰；接口中的方法默认使用 public 修饰，接口是一种特殊的抽象类，接口中的方法全部是抽象方法（但其前的abstract可以省略），所以抽象类中的抽象方法不能用的访问修饰符这里也不能用，而且protected访问修饰符也不能使用。</li></ul><h3 id="Java中IO流分为几种"><a href="#Java中IO流分为几种" class="headerlink" title="Java中IO流分为几种"></a>Java中IO流分为几种</h3><ul><li>按功能分：输入流（input）、输出流（output）</li><li>按类型分：字节流和字符流<br>  字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</li></ul><h3 id="BIO、NIO和AIO区别"><a href="#BIO、NIO和AIO区别" class="headerlink" title="BIO、NIO和AIO区别"></a>BIO、NIO和AIO区别</h3><ul><li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li><li>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li><li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li></ul><h3 id="Files常用方法有哪些"><a href="#Files常用方法有哪些" class="headerlink" title="Files常用方法有哪些"></a>Files常用方法有哪些</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Files. exists()：检测文件路径是否存在。</span><br><span class="line">Files. createFile()：创建文件。</span><br><span class="line">Files. createDirectory()：创建文件夹。</span><br><span class="line">Files. delete()：删除一个文件或目录。</span><br><span class="line">Files. copy()：复制文件。</span><br><span class="line">Files. move()：移动文件。</span><br><span class="line">Files. size()：查看文件个数。</span><br><span class="line">Files. read()：读取文件。</span><br><span class="line">Files. write()：写入文件。</span><br></pre></td></tr></table></figure><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="Java容器都有哪些"><a href="#Java容器都有哪些" class="headerlink" title="Java容器都有哪些"></a>Java容器都有哪些</h3><p>Java容器分为Collection和Map两大类，其下又有很多子类，如下所示：</p><ul><li>Collection<ul><li>List<ul><li>ArrayList</li><li>LinkedList</li><li>Vector</li><li>Stack</li></ul></li><li>Set<ul><li>HashSet</li><li>LinkedHashSet</li><li>TreeSet</li></ul></li></ul></li><li>Map<ul><li>HashMap<ul><li>LinkedHashMap</li></ul></li><li>TreeMap</li><li>ConcurrentHashMap</li><li>Hashtable</li></ul></li></ul><h3 id="简述Java中的集合"><a href="#简述Java中的集合" class="headerlink" title="简述Java中的集合"></a>简述Java中的集合</h3><ul><li>Collection下：List系（有序、元素允许重复）和Set系（无序、元素不重复）<br>  set根据equals和hashCode判断，一个对象要存储在Set中，必须重写equals和hashCode方法。</li><li>Map下：HashMap线程不同步；TreeMap线程同步；</li><li>Collection系列和Map系列：Map是对Colleciton的补充，两者没什么关系。</li></ul><h3 id="List、Set、Map之间的区别"><a href="#List、Set、Map之间的区别" class="headerlink" title="List、Set、Map之间的区别"></a>List、Set、Map之间的区别</h3><p>List、Set、Map之间的区别主要体现在两个方面：元素是否有序、是否允许元素重复<br>三者间的区别，如表所示：</p><table>  <tr>    <th></th>    <th></th>    <th>元素有序</th>    <th>允许元素重复</th>  </tr>  <tr>    <td colspan="2">List</td>    <td>是</td>    <td>是</td>  </tr>  <tr>    <td rowspan="3">Set</td>    <td>AbstractSet</td>    <td rowspan="2">否</td>    <td rowspan="3">否</td>  </tr>  <tr>    <td>HashSet</td>  </tr>  <tr>    <td>TreeSet</td>    <td>是（用二叉树排序）</td>  </tr>  <tr>    <td rowspan="3">Map</td>    <td>AbstractMap</td>    <td rowspan="2">否</td>    <td rowspan="3">key值必须唯一<br>value值可重复</td>  </tr>  <tr>    <td>HashMap</td>  </tr>  <tr>    <td>TreeMap</td>    <td>是（用二叉树排序）</td>  </tr></table><h3 id="HashMap、HashTable和ConcurrentHashMap区别"><a href="#HashMap、HashTable和ConcurrentHashMap区别" class="headerlink" title="HashMap、HashTable和ConcurrentHashMap区别"></a>HashMap、HashTable和ConcurrentHashMap区别</h3><p>相同点：<br>    1. HashMap和HashTable都实现了Map接口<br>    2. 都可以存储key-value数据<br>不同点：<br>    1. HashMap可以把null作为key或者value,HashTable不可以<br>    2. HashMap线程不安全，效率高，HashTable线程安全，效率低<br>    3. HashMap迭代器(Iterator)是fail-fast迭代器，而HashTable的enumerator迭代器不是fail-fast的<br>    什么是fail-fast?<br>      就是最快的时间能把错误抛出而不是让程序执行<br>    4. Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java基础知识点&quot;&gt;&lt;a href=&quot;#Java基础知识点&quot; class=&quot;headerlink&quot; title=&quot;Java基础知识点&quot;&gt;&lt;/a&gt;Java基础知识点&lt;/h2&gt;&lt;h3 id=&quot;简述什么是跨平台&quot;&gt;&lt;a href=&quot;#简述什么是跨平台&quot; class=&quot;
      
    
    </summary>
    
      <category term="java知识点整理" scheme="https://kepler-ecnu.github.io/categories/java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    
    
      <category term="java知识点" scheme="https://kepler-ecnu.github.io/tags/java%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Markdown入门教程</title>
    <link href="https://kepler-ecnu.github.io/2019/08/01/Markdown%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://kepler-ecnu.github.io/2019/08/01/Markdown入门教程/</id>
    <published>2019-08-01T09:29:41.128Z</published>
    <updated>2019-08-06T09:08:07.565Z</updated>
    
    <content type="html"><![CDATA[<p>&lt; !–more–&gt;</p><h2 id="斜体和粗体"><a href="#斜体和粗体" class="headerlink" title="斜体和粗体"></a>斜体和粗体</h2><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*斜体*或_斜体_  </span><br><span class="line">**粗体**</span><br><span class="line">***加粗斜体***</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><p>显示效果：<br><em>这是一段斜体</em><br><strong>这是一段粗体</strong><br><strong><em>这是一段加粗斜体</em></strong><br><del>这是一段删除线</del></p><h2 id="分级标题"><a href="#分级标题" class="headerlink" title="分级标题"></a>分级标题</h2><p>第一种写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这是一个一级标题</span><br><span class="line">==================</span><br><span class="line">这是一个二级标题</span><br><span class="line">------------------</span><br></pre></td></tr></table></figure><p>就是在文字的下一行增加不同的横线，不建议使用。<br>第二种写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><p>推荐使用这种方式，简单易记，不同级别的标题后面<code>#</code>不一样多，在<code>#</code>后需要空一格。</p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>Markdown 支持两种形式的链接语法：行内式和参考式两种形式，行内式一般用的较多。</p><h3 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h3><p><strong>语法说明：</strong><br><code>[]</code>里写链接文字，<code>()</code>里写链接地址，<code>()</code>中的<code>" "</code>可以为链接指定title属性，title属性可加可不加。title属性效果是鼠标悬停在链接上会出现指定的title文字。<code><a href="链接地址" title="链接标题">链接文字</a></code>这样的形式。注：链接地址与链接标题间有一个空格。<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">欢迎访问[我的博客](https://kepler-ecnu.github.io/)</span><br><span class="line">欢迎访问[我的博客](https://kepler-ecnu.github.io/ &quot;kepler&apos;s blog&quot;)</span><br></pre></td></tr></table></figure><p>显示效果：<br>欢迎访问<a href="https://kepler-ecnu.github.io/">我的博客</a><br>欢迎访问<a href="https://kepler-ecnu.github.io/" title="kepler&#39;s blog">我的博客</a> 这个设置了标题，在鼠标指在超链接上时显示标题。</p><h3 id="参考式"><a href="#参考式" class="headerlink" title="参考式"></a>参考式</h3><p>参考式超链接一般用在学术论文上，或者若某一个链接在文章中多出使用，则使用引用的方式创建链接，这样可以对链接进行同意的管理。<br><strong>语法说明：</strong><br>参考式链接分为两部分，文中的写法<code>[链接文字][链接标记]</code>，在文本的任意位置添加[链接文字]:链接地址 “链接标记”，链接地址与链接标记间一个空格。<br>如果链接文字本身可以作为链接标记，也可以写成<code>[链接文字][]</code><br>[链接文字]：链接地址的形式，见代码的最后一行。<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我经常访问的网站[baidu][1]、[bilibili][2]等</span><br><span class="line">[B站][2]有我整理的[音乐合集][]。</span><br><span class="line">[1]:https://www.baidu.com/ &quot;baidu&quot;</span><br><span class="line">[2]:https://space.bilibili.com/12737596 &quot;bilibili&quot;</span><br><span class="line">[音乐合集]:https://space.bilibili.com/12737596</span><br></pre></td></tr></table></figure><h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><p><strong>语法说明</strong><br>Markdown支持较简短的自动链接形式来处理网址和电子邮箱，只要是用<code><></code>包起来，Markdown就会自动把它转成链接。一般网址的链接文字和链接地址一样，如：<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;https://space.bilibili.com/12737596&gt;</span><br><span class="line">&lt;address@example.com&gt;</span><br></pre></td></tr></table></figure><p>显示效果：<br><a href="https://space.bilibili.com/12737596" target="_blank" rel="noopener">https://space.bilibili.com/12737596</a><br><a href="mailto:&#x61;&#x64;&#100;&#114;&#x65;&#x73;&#115;&#x40;&#101;&#120;&#97;&#109;&#x70;&#108;&#101;&#46;&#99;&#111;&#x6d;" target="_blank" rel="noopener">&#x61;&#x64;&#100;&#114;&#x65;&#x73;&#115;&#x40;&#101;&#120;&#97;&#109;&#x70;&#108;&#101;&#46;&#99;&#111;&#x6d;</a></p><h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><p>网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中<br>的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。<br>在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。<br><strong>语法描述：</strong><br>在你准备跳转到的指定标题后插入锚点,然后在文档的其它地方写上链接到锚点的链接。（这里不展开）</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>使用<code>*，+，-</code>表示无序列表<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 无序列表项一</span><br><span class="line">+ 无序列表项二</span><br><span class="line">- 无序列表项三</span><br></pre></td></tr></table></figure><p>显示效果：</p><ul><li>无序列表项一</li></ul><ul><li>无序列表项二</li></ul><ul><li>无序列表项三</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>有序列表则使用数字接着一个英文句点，接着空一个格写列表项。<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 有序列表项一</span><br><span class="line">2. 有序列表项二</span><br><span class="line">3. 有序列表项三</span><br></pre></td></tr></table></figure><p>显示效果：</p><ol><li>有序列表项一</li><li>有序列表项二</li><li>有序列表项三  </li></ol><h3 id="定义型列表"><a href="#定义型列表" class="headerlink" title="定义型列表"></a>定义型列表</h3><p><strong>语法说明：</strong><br>定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法<code>:</code>紧跟一个缩进（Tab）</p><h3 id="列表缩进"><a href="#列表缩进" class="headerlink" title="列表缩进"></a>列表缩进</h3><p><strong>语法说明</strong><br>列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3个空格，项目标记后面则一定要接着至少一个空格或制表符。<br>要让列表看起来更漂亮，你可以把内容用固定的缩进整理好（显示效果与代码一致）：<br>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。<br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！<br>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。<br>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。<br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！<br>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。<br>但是如果你懒，那也行：<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。</span><br><span class="line">那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。</span><br><span class="line">软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！</span><br><span class="line">* 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。</span><br><span class="line">寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。</span><br><span class="line">但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！</span><br><span class="line">悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</span><br></pre></td></tr></table></figure><p>显示效果：</p><ul><li>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。<br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！</li><li>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。<br>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。<br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！<br>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。<h3 id="包含段落的列表"><a href="#包含段落的列表" class="headerlink" title="包含段落的列表"></a>包含段落的列表</h3>列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符（显示效果与代码一致）：<br>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。<br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！<br>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。<br>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。<br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！<br>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。<br>但是如果你懒，那也行：<br>代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。</span><br><span class="line">那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。</span><br><span class="line">软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！</span><br><span class="line">*那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。</span><br><span class="line">寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。</span><br><span class="line">但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！</span><br><span class="line">悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</span><br></pre></td></tr></table></figure>显示效果：</li><li>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。<br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！</li><li>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。<br>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。<br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！<br>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</li></ul><h3 id="包含引用的列表"><a href="#包含引用的列表" class="headerlink" title="包含引用的列表"></a>包含引用的列表</h3><p><strong>语法说明：</strong><br>如果要在列表项目内放进引用，那 &gt; 就需要缩进：<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*阅读的方法：</span><br><span class="line">&gt; 拿出书本</span><br><span class="line">&gt; 放下手机</span><br><span class="line">&gt; 开始看吧</span><br></pre></td></tr></table></figure><p>显示效果：</p><ul><li>阅读的方法：<blockquote><p>拿出书本<br>放下手机<br>开始看吧</p></blockquote></li></ul><h3 id="包含代码区块的引用"><a href="#包含代码区块的引用" class="headerlink" title="包含代码区块的引用"></a>包含代码区块的引用</h3><p><strong>语法说明：</strong><br>如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：<br>一列表项包含一个列表区块：<br>        写代码块的地方</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><strong>语法说明：</strong><br>引用需要在被引用的文本前加上 &gt; 符号。<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这是一个有两段文字的引用</span><br><span class="line">&gt; text1</span><br><span class="line">&gt; text2</span><br><span class="line">&gt;</span><br><span class="line">&gt; text3</span><br><span class="line">&gt; text4</span><br></pre></td></tr></table></figure><p>显示效果：</p><blockquote><p>这是一个有两段文字的引用<br>text1<br>text2</p><p>text3<br>text4</p></blockquote><h3 id="引用的多层嵌套"><a href="#引用的多层嵌套" class="headerlink" title="引用的多层嵌套"></a>引用的多层嵌套</h3><p>区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ：<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这是一个有两段文字的引用</span><br><span class="line">&gt;&gt; text1</span><br><span class="line">&gt;&gt;&gt; text2</span><br><span class="line">&gt;</span><br><span class="line">&gt; text3</span><br><span class="line">&gt; text4</span><br></pre></td></tr></table></figure><p>显示效果：</p><blockquote><p>这是一个有两段文字的引用</p><blockquote><p>text1</p><blockquote><p>text2</p></blockquote></blockquote><p>text3<br>text4</p></blockquote><h3 id="引用的其它要素"><a href="#引用的其它要素" class="headerlink" title="引用的其它要素"></a>引用的其它要素</h3><p>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; 1. 第一列表项</span><br><span class="line">&gt; 2. 第二列表项</span><br><span class="line">&gt;&gt; text1</span><br><span class="line">&gt;&gt;&gt; text2</span><br><span class="line">&gt;</span><br><span class="line">&gt; return shell_exec(&quot;echo $input | $markdown_script&quot;);</span><br><span class="line">&gt; `return shell_exec(&quot;echo $input | $markdown_script&quot;);`</span><br></pre></td></tr></table></figure><p>显示效果：</p><blockquote><ol><li><p>第一列表项</p></li><li><p>第二列表项</p><blockquote><p>text1</p><blockquote><p>text2</p></blockquote></blockquote><pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);</code></pre><p><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);</code></p></li></ol></blockquote><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。<br>语法中图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。</p><h3 id="行内式-1"><a href="#行内式-1" class="headerlink" title="行内式"></a>行内式</h3><p><strong>语法说明：</strong><code>![图片Alt](图片地址 "图片Title")</code><br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![图片示例](http://img.redocn.com/sheji/20141219/zhongguofengdaodeliyizhanbanzhijing_3744115.jpg &quot;图片示例&quot;)</span><br></pre></td></tr></table></figure><p>显示效果：<br><img src="http://img.redocn.com/sheji/20141219/zhongguofengdaodeliyizhanbanzhijing_3744115.jpg" alt="图片示例" title="图片示例"></p><h3 id="参考式-1"><a href="#参考式-1" class="headerlink" title="参考式"></a>参考式</h3><p><strong>语法说明：（这里不作介绍）</strong><br>在文档要插入图片的地方写<code>![图片Alt][标记]</code><br>在文档的最后写上写<code>[标记]:图片地址 “Title”</code></p><h2 id="内容目录"><a href="#内容目录" class="headerlink" title="内容目录"></a>内容目录</h2><p>在段落中填写 [TOC] 以显示全文内容的目录结构。<br>Hexo博客对目录的解析似乎也有限，请在Markdown编辑器中自行尝试。Next主题的话是也可以自动生成目录的，所以不需要额外增加目录。</p><h2 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h2><p><strong>语法说明：</strong><br>在需要添加注脚的文字后加上<code>脚注名字[^脚注名字]</code>，称为加注。然后在文本的任意位置（一般在最后）添加脚注，脚注前必须有对应的脚注名字。<br>注意：经测试注脚和脚注之间必须空一行，不然会失效。成功后会发现，即使没有把注脚卸载文末，经Markdown转换后，也会自动归类到文章的最后。<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。</span><br><span class="line">[^1]: Markdown是一种纯文本标记语言</span><br><span class="line">[^2]: HyperText Markup Language 超文本标记语言</span><br><span class="line">[^Le]: 开源笔记平台，支持Markdown和笔记直接发为博文</span><br></pre></td></tr></table></figure><p>显示效果：<br>使用 Markdown<a href="Markdown是一种纯文本标记语言">^1</a>可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。</p><p>[^2]: HyperText Markup Language 超文本标记语言<br>[^Le]: 开源笔记平台，支持Markdown和笔记直接发为博文</p><h2 id="LaTex公式"><a href="#LaTex公式" class="headerlink" title="LaTex公式"></a>LaTex公式</h2><h3 id="表示行内公式"><a href="#表示行内公式" class="headerlink" title="$表示行内公式"></a>$表示行内公式</h3><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。</span><br></pre></td></tr></table></figure><p>显示效果：<br>质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。<br>注意：我的博客没有开启公式显示，所以可能公式显示不准确，请自己用Markdown编辑器查看效果</p><h3 id="表示整行公式"><a href="#表示整行公式" class="headerlink" title="$表示整行公式"></a>$表示整行公式</h3><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$\sum_&#123;i=1&#125;^n a_i=0$$</span><br><span class="line">$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$</span><br><span class="line">$$\sum^&#123;j-1&#125;_&#123;k=0&#125;&#123;\widehat&#123;\gamma&#125;_&#123;kj&#125; z_k&#125;$$</span><br></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p><strong>语法说明：</strong><br>不管是哪种方式，第一行为表头，第二行分割表头和主体部分，第三行开始每一行为一个表格行。<br>列与列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。<br>第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">简单方式写表格：</span><br><span class="line"></span><br><span class="line">学号|姓名|分数</span><br><span class="line">-|-|-</span><br><span class="line">小明|男|75</span><br><span class="line">小红|女|79</span><br><span class="line">小陆|男|92</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原生方式写表格：</span><br><span class="line"></span><br><span class="line">| 学号 | 姓名 | 分数 |</span><br><span class="line">| ---- | ---- | ---- |</span><br><span class="line">| 小明 | 男   | 75   |</span><br><span class="line">| 小红 | 女   | 79   |</span><br><span class="line">| 小陆 | 男   | 92   |</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">为表格第二列指定方向：</span><br><span class="line"></span><br><span class="line">| 产品             |     价格 |</span><br><span class="line">| ---------------- | -------: |</span><br><span class="line">| Leanote 高级账号 |  60元/年 |</span><br><span class="line">| Leanote 超级账号 | 120元/年 |</span><br></pre></td></tr></table></figure><p>显示效果：<br>简单方式写表格：</p><table><thead><tr><th>学号</th><th>姓名</th><th>分数</th></tr></thead><tbody><tr><td>小明</td><td>男</td><td>75</td></tr><tr><td>小红</td><td>女</td><td>79</td></tr><tr><td>小陆</td><td>男</td><td>92</td></tr></tbody></table><p>原生方式写表格：</p><table><thead><tr><th>学号</th><th>姓名</th><th>分数</th></tr></thead><tbody><tr><td>小明</td><td>男</td><td>75</td></tr><tr><td>小红</td><td>女</td><td>79</td></tr><tr><td>小陆</td><td>男</td><td>92</td></tr></tbody></table><p>为表格第二列指定方向：</p><table><thead><tr><th>产品</th><th align="right">价格</th></tr></thead><tbody><tr><td>Leanote 高级账号</td><td align="right">60元/年</td></tr><tr><td>Leanote 超级账号</td><td align="right">120元/年</td></tr></tbody></table><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分割线，行内不能有其他东西。也可以在星号或是减号中间插入空格。下面每种写法都可以建立分割线：<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* * *</span><br><span class="line">***</span><br><span class="line">*****</span><br><span class="line">- - -</span><br><span class="line">---------------------------------------</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(Tab), 另一种是利用”`”符号（一般在ESC键下方）包裹代码。<br><strong>语法说明：</strong><br>插入行内代码，即插入一个单词或者一句代码的情况，使用&lt;code&gt;这样的形式插入。<br>插入多行代码，可以使用缩进或者“code “,具体看示例。<br>注意： 缩进式插入前方必须有空行</p><h3 id="行内式-2"><a href="#行内式-2" class="headerlink" title="行内式"></a>行内式</h3><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C语言里的函数 `scanf()` 怎么使用？</span><br></pre></td></tr></table></figure><p>显示效果：<br>C语言里的函数 <code>scanf()</code> 怎么使用？</p><h3 id="缩进式多行代码"><a href="#缩进式多行代码" class="headerlink" title="缩进式多行代码"></a>缩进式多行代码</h3><p>缩进4个空格或是一个制表符（Tab）<br>一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Hello world\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示效果：</p><p>#include &lt;stdio.h&gt;<br>int main(void)<br>{<br>    printf(“Hello world\n”);<br>}</p><h3 id="用三个”-”包裹多行代码"><a href="#用三个”-”包裹多行代码" class="headerlink" title="用三个” `”包裹多行代码"></a>用三个” `”包裹多行代码</h3><p>输入三个<code>后空一行写代码，结束后另起一行输入三个</code>表示代码块的结束</p><h2 id="HTML-原始码"><a href="#HTML-原始码" class="headerlink" title="HTML 原始码"></a>HTML 原始码</h2><p>Markdown支持很多HTML代码，具体不展开。</p>]]></content>
    
    <summary type="html">
    
      Markdown入门使用
    
    </summary>
    
      <category term="博客搭建" scheme="https://kepler-ecnu.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Markdown" scheme="https://kepler-ecnu.github.io/tags/Markdown/"/>
    
  </entry>
  
</feed>
