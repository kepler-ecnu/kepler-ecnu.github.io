<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java知识点整理(不间断更新)]]></title>
    <url>%2F2019%2F08%2F06%2FJava%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[Java基础知识点简述什么是跨平台由于各种操作系统所支持的指令集不是完全一致的，所以在操作系统上加个虚拟机来提供统一接口，屏蔽系统之间的差异。 Java有几种基本数据类型有八种基本数据类型: 数据类型 字节 默认值 byte 1 0 char 4 ‘\u0000’ boolean 1 false float 4 0.0f double 8 0.0d int 4 0 short 2 0 long 8 0 面向对象特征面向对象的编程语言有封装、继承、多态、抽象四个主要特征。 封装：把描述一个对象的属性和行为封装在一个模块中，即一个类中，属性用变量定义，行为用方法定义，方法可以直接访问同一个对象中的属性。 抽象：把现实生活中的对象抽象为类。分为过程抽象和数据抽象 过程抽象：类的方法（鸟会啼鸣等） 数据抽象：类的属性（鸟有翅膀等） 继承：子类继承父类的特征和行为。子类可以有父类非私有的方法，也可以对父类进行扩展，也可以重写父类的方法。缺点就是提高了代码间的耦合性。 多态： 编译时多态：方法的重载 运行时多态：向上转型、方法重写–基于继承 面向对象六大原则 单一职责原则—-SRP 让每个类只专心处理自己的方法 开闭原则—-OCP 软件中的对象（类、模块、函数等）应该对于扩展开放，对于修改是关闭的 里氏替换原则—-LSP 子类可以去扩展父类，但是不能改变父类原有的功能 依赖倒置原则—-DIP 应该通过调用接口或抽象类，而不是调用实现类 接口隔离原则—-ISP 把接口分为满足依赖关系的最小接口，实现类中不能有不需要的方法 迪米特原则—-LOP 高内聚、低耦合 String属于基础的数据类型吗String不属于基础类型，基础类型有type、boolean、int、char、short、long、float、double，而String属于包装器类型 为什么要有包装类型为了让基本数据类型也具有对象的特征，就出现了包装类型（如在使用集合类型Collection时就一定要使用包装类型而不是基本数据类型）。因为容器都是装object的，这时就需要这些基本数据类型的包装类型了。 基本类型 包装器类型 boolean Boolean char Character int Integer byte Byte short Short long Long float Float double Double 自动装箱和自动拆箱自动装箱：new Integer(6)，底层调用：Integer.valueOf(6)；自动拆箱：int i = new Integer(6)，底层调用：i.intValue();二者的区别： 声明方式不同：基本数据类型不使用new关键字，而包装类型需要使用new关键字在堆中分配存储空间； 存储方式及位置不同：基本数据类型是直接将变量值存储在栈中，而包装类型是将对象放在堆中，然后通过引用来使用； 初始值不同：基本数据类型的初始值如int为0，boolean为false，而包装类型的初始值为null； 使用方式不同：基本数据类型赋值直接使用就好，而包装类型在集合如Collection、Map时会使用到。 String str = “i” 与 String str = new String(“i”)一样么不一样，因为内存的分配方式不一样。String str = "i"的方式，Java虚拟机会将其分配到常量池中；String str = new String("i")则会被分到堆内存中。 如何将字符串反转使用StringBuilder或者StringBuffer的reverse()方法 12345678// StringBuffer reverseStringBuffer stringBuffer = new StringBuffer();stringBuffer. append(&quot;abcdefg&quot;);System. out. println(stringBuffer. reverse()); // gfedcba// StringBuilder reverseStringBuilder stringBuilder = new StringBuilder();stringBuilder. append(&quot;abcdefg&quot;);System. out. println(stringBuilder. reverse()); // gfedcba String 类常用方法1234567891011indexOf()：返回指定字符的索引。charAt()：返回指定索引处的字符。replace()：字符串替换。trim()：去除字符串两端空白。split()：分割字符串，返回一个分割后的字符串数组。getBytes()：返回字符串的 byte 类型数组。length()：返回字符串长度。toLowerCase()：将字符串转成小写字母。toUpperCase()：将字符串转成大写字符。substring()：截取字符串。equals()：字符串比较。 == 和 equals 区别 == 比较的是两个引用在内存中指向的是不是同一对象（即同一内存空间），也就是说在内存中的存储位置是否一致。如果两个对象的引用相同时（指向同一对象时），== 操作符返回true,否则返回false。 对于基本类型和引用类型 == 的作用效果是不同的：基本类型：比较的是值是否相同；引用类型：比较的是引用是否相同；代码示例： 1234567String x = &quot;string&quot;;String y = &quot;string&quot;;String z = new String(&quot;string&quot;);System.out.println(x==y); // trueSystem.out.println(x==z); // falseSystem.out.println(x.equals(y)); // trueSystem.out.println(x.equals(z)); // true 代码解读：因为 x 和 y 指向的是同一个引用，所以 == 是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true equals 用来比较某些特征是否一样，本质上就是 == ，只不过String和Integer等重写了equals方法，把它变成了值比较。首先看默认情况下equals比较一个有相同值的对象，代码如下： 12345678910111213141516171819class Cat &#123; public Cat(String name) &#123; this.name = name; &#125; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; Cat c1 = new Cat(&quot;王磊&quot;);Cat c2 = new Cat(&quot;王磊&quot;);System.out.println(c1.equals(c2)); // false 输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下： 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 原来 equals 本质上就是 ==。那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下： 123String s1 = new String(&quot;老王&quot;);String s2 = new String(&quot;老王&quot;);System.out.println(s1.equals(s2)); // true 同样的，当我们进入 String 的 equals方法，找到了答案，代码如下： 123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; &#125; 原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。总结： == 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重写了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。 String、StringBuffer和StringBuilder区别 数据可变和不可变 String底层使用一个不可变的字符数组private final char value[]，所以它的内容不可变 StringBuffer和StringBuilder都继承了AbstractStringBuilder底层使用的是可变字符数组：char[] value; 线程安全性 StringBulider是线程不安全的，效率较高；而StringBuffer是线程安全的，效率较低；通过他们的append()方法来看，SpringBuffer是有同步锁，而StringBuilder没有：1234567891011 @Overridepublic synchronized StringBuffer append(Object obj) &#123; toStringCache = null; super.append(String.valueOf(obj)); return this;&#125;@Overridepublic StringBuilder append(String str) &#123; super.append(str); return this;&#125; 相同点StringBuilder与StringBuffer有公共父类AbstractBuilder；最后，操作可变字符串速度：StringBuilder &gt; StringBuffer &gt; String。 两个对象的 hashCode()相同，则equals()也一定为true，对吗？不对，两个对象的HashCode()相同，equals()不一定true。代码示例： 1234String str1 = &quot;通话&quot;;String str2 = &quot;重地&quot;;System. out. println(String. format(&quot;str1：%d | str2：%d&quot;, str1. hashCode(),str2. hashCode()));System. out. println(str1. equals(str2)); 执行结果： 123str1：1179395 | str2：1179395 false 代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。 两个对象值相同(x.equals(y)==true)，Hashcode是否一定相同第一种情况：假如这个类没有重写equals方法，如果两个对象值相同，那么他们的hashCode值一定相同；第二种情况：如果重写了equals方法，但没有重写hashCode方法，就会出现不相等的情况。Java对于equals方法和hashCode方法的规定 如果两个对象相同，那么他们的hashCode值一定要相同； 如果两个对象的hashCode相同，他们并不一定相同（这里说的对象相同指的是用equals方法比较）； equals()相等的两个对象，hashCode()一定相等；equals()不相等的两个对象，却并不能证明他们的hashCode()不相等。换句话说，equals()方法不相等的两个对象，hashCode()有可能相等（我的理解是由于哈希码在生成的时候产生冲突造成的）。反过来，hashCode()不等，一定能推出equals()也不等；hashCode()相等，equals()可能相等，也可能不等。 什么时候需要重写equals方法和hashCode方法如果想完整的使用HashSet类(或TreeSet等)，最少需要重写equals()和hashCode()方法 重写hashCode()用于获得元素的存储位置； 重写equals()用于在两个元素的位置相同的时候，比较两个元素是否相等。分析原因如下：1234567hashCode public int hashCode()返回该对象的哈希码值。支持此方法是为了提高哈希表（例如 Java.util.Hashtable 提供的哈希表）的性能。 hashCode 的常规协定是： 在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。 如果根据 equals(Object) 方法，两个对象是相等的，那么对这两个对象中的每个对象调用 hashCode 方法都必须生成相同的整数结果。 如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么对这两个对象中的任一对象上调用 hashCode 方法不 要求一定生成不同的整数结果。但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能。 实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。） 12345678910equals public boolean equals(Object obj)指示其他某个对象是否与此对象“相等”。 equals 方法在非空对象引用上实现相等关系： 自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true。 对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。 传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。 一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。 对于任何非空引用值 x，x.equals(null) 都应返回 false。 Object 类的 equals 方法实现对象上差别可能性最大的相等关系；即，对于任何非空引用值 x 和 y，当且仅当 x 和 y 引用同一个对象时，此方法才返回 true（x == y 具有值 true）。 ArrayList 和 LinkdList 区别 ArrayList的实现基于动态数组的数据结构，LinkedList基于链表的数据结构； 对于随机访问get和set，ArrayList优于LinkedList，因为LinkedList需要移动指针； 对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。 final在Java中有什么作用 修饰类，则该类不能被继承； 修饰方法，则该方法不能被重写； 修饰变量，修饰的变量叫常量，必须初始化，且初始化后值不能被修改。 Java中 Math.round(-1.5)等于多少？Math.round(-2.5)等于多少？答案：-1，-2注意：不要认为它是四舍五入计算口诀：+0.5后向下取整即可同理Math.round(-2.6)结果和Math.round(2.6)结果分别为-3，3 抽象类必须要有抽象方法吗？不需要，抽象类不一定非要抽象方法 12345abstract class Cat &#123; public static void sayHi() &#123; System. out. println(&quot;hi~&quot;); &#125; &#125; 普通类和抽象类有哪些区别普通类不能包含抽象方法，抽象类可以包含抽象方法抽象类不能直接实例化，普通类可以直接实例化 抽象类能使用final修饰吗不能，定义抽象类就是让其他类继承的，如果定义为final该类就不能被继承，这样彼此就会产生矛盾，所以final不能修饰抽象类。 接口和抽象类的区别 实现：抽象类的子类使用extends来继承；接口必须使用implements来实现接口； 构造函数：抽象类有构造函数；接口不能有； 实现数量：类可以实现多个接口，但是只能继承一个抽象类； 访问修饰符：抽象类中的抽象方法(其前有abstract修饰)不能用private、static、synchronized、native访问修饰符修饰；接口中的方法默认使用 public 修饰，接口是一种特殊的抽象类，接口中的方法全部是抽象方法（但其前的abstract可以省略），所以抽象类中的抽象方法不能用的访问修饰符这里也不能用，而且protected访问修饰符也不能使用。 Java中IO流分为几种 按功能分：输入流（input）、输出流（output） 按类型分：字节流和字符流 字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。 BIO、NIO和AIO区别 BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。 NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。 AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。 Files常用方法有哪些123456789Files. exists()：检测文件路径是否存在。Files. createFile()：创建文件。Files. createDirectory()：创建文件夹。Files. delete()：删除一个文件或目录。Files. copy()：复制文件。Files. move()：移动文件。Files. size()：查看文件个数。Files. read()：读取文件。Files. write()：写入文件。 容器Java容器都有哪些Java容器分为Collection和Map两大类，其下又有很多子类，如下所示： Collection List ArrayList LinkedList Vector Stack Set HashSet LinkedHashSet TreeSet Map HashMap LinkedHashMap TreeMap ConcurrentHashMap Hashtable 简述Java中的集合 Collection下：List系（有序、元素允许重复）和Set系（无序、元素不重复） set根据equals和hashCode判断，一个对象要存储在Set中，必须重写equals和hashCode方法。 Map下：HashMap线程不同步；TreeMap线程同步； Collection系列和Map系列：Map是对Colleciton的补充，两者没什么关系。 List、Set、Map之间的区别List、Set、Map之间的区别主要体现在两个方面：元素是否有序、是否允许元素重复三者间的区别，如表所示： 元素有序 允许元素重复 List 是 是 Set AbstractSet 否 否 HashSet TreeSet 是（用二叉树排序） Map AbstractMap 否 key值必须唯一value值可重复 HashMap TreeMap 是（用二叉树排序） HashMap、HashTable和ConcurrentHashMap区别相同点： 1. HashMap和HashTable都实现了Map接口 2. 都可以存储key-value数据不同点： 1. HashMap可以把null作为key或者value,HashTable不可以 2. HashMap线程不安全，效率高，HashTable线程安全，效率低 3. HashMap迭代器(Iterator)是fail-fast迭代器，而HashTable的enumerator迭代器不是fail-fast的 什么是fail-fast? 就是最快的时间能把错误抛出而不是让程序执行 4. Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。]]></content>
      <categories>
        <category>java知识点整理</category>
      </categories>
      <tags>
        <tag>java知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown入门教程]]></title>
    <url>%2F2019%2F08%2F01%2FMarkdown%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[&lt; !–more–&gt; 斜体和粗体代码： 1234*斜体*或_斜体_ **粗体*****加粗斜体***~~删除线~~ 显示效果：这是一段斜体这是一段粗体这是一段加粗斜体这是一段删除线 分级标题第一种写法： 1234这是一个一级标题==================这是一个二级标题------------------ 就是在文字的下一行增加不同的横线，不建议使用。第二种写法： 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 推荐使用这种方式，简单易记，不同级别的标题后面#不一样多，在#后需要空一格。 超链接Markdown 支持两种形式的链接语法：行内式和参考式两种形式，行内式一般用的较多。 行内式语法说明：[]里写链接文字，()里写链接地址，()中的" "可以为链接指定title属性，title属性可加可不加。title属性效果是鼠标悬停在链接上会出现指定的title文字。链接文字这样的形式。注：链接地址与链接标题间有一个空格。代码： 12欢迎访问[我的博客](https://kepler-ecnu.github.io/)欢迎访问[我的博客](https://kepler-ecnu.github.io/ &quot;kepler&apos;s blog&quot;) 显示效果：欢迎访问我的博客欢迎访问我的博客 这个设置了标题，在鼠标指在超链接上时显示标题。 参考式参考式超链接一般用在学术论文上，或者若某一个链接在文章中多出使用，则使用引用的方式创建链接，这样可以对链接进行同意的管理。语法说明：参考式链接分为两部分，文中的写法[链接文字][链接标记]，在文本的任意位置添加[链接文字]:链接地址 “链接标记”，链接地址与链接标记间一个空格。如果链接文字本身可以作为链接标记，也可以写成[链接文字][][链接文字]：链接地址的形式，见代码的最后一行。代码： 12345我经常访问的网站[baidu][1]、[bilibili][2]等[B站][2]有我整理的[音乐合集][]。[1]:https://www.baidu.com/ &quot;baidu&quot;[2]:https://space.bilibili.com/12737596 &quot;bilibili&quot;[音乐合集]:https://space.bilibili.com/12737596 自动链接语法说明Markdown支持较简短的自动链接形式来处理网址和电子邮箱，只要是用包起来，Markdown就会自动把它转成链接。一般网址的链接文字和链接地址一样，如：代码： 12&lt;https://space.bilibili.com/12737596&gt;&lt;address@example.com&gt; 显示效果：https://space.bilibili.com/12737596&#x61;&#x64;&#100;&#114;&#x65;&#x73;&#115;&#x40;&#101;&#120;&#97;&#109;&#x70;&#108;&#101;&#46;&#99;&#111;&#x6d; 锚点网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。语法描述：在你准备跳转到的指定标题后插入锚点,然后在文档的其它地方写上链接到锚点的链接。（这里不展开） 列表无序列表使用*，+，-表示无序列表代码： 123* 无序列表项一+ 无序列表项二- 无序列表项三 显示效果： 无序列表项一 无序列表项二 无序列表项三 有序列表有序列表则使用数字接着一个英文句点，接着空一个格写列表项。代码： 1231. 有序列表项一2. 有序列表项二3. 有序列表项三 显示效果： 有序列表项一 有序列表项二 有序列表项三 定义型列表语法说明：定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法:紧跟一个缩进（Tab） 列表缩进语法说明列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3个空格，项目标记后面则一定要接着至少一个空格或制表符。要让列表看起来更漂亮，你可以把内容用固定的缩进整理好（显示效果与代码一致）：轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。但是如果你懒，那也行：代码： 1234567* 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！* 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 显示效果： 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。包含段落的列表列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符（显示效果与代码一致）：轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。但是如果你懒，那也行：代码：1234567* 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！* 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 显示效果： 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 包含引用的列表语法说明：如果要在列表项目内放进引用，那 &gt; 就需要缩进：代码： 1234* 阅读的方法： &gt; 拿出书本 &gt; 放下手机 &gt; 开始看吧 显示效果： 阅读的方法： 拿出书本放下手机开始看吧 包含代码区块的引用语法说明：如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：一列表项包含一个列表区块： 写代码块的地方 引用语法说明：引用需要在被引用的文本前加上 &gt; 符号。代码： 123456&gt; 这是一个有两段文字的引用&gt; text1&gt; text2&gt;&gt; text3&gt; text4 显示效果： 这是一个有两段文字的引用text1text2 text3text4 引用的多层嵌套区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ：代码： 123456&gt; 这是一个有两段文字的引用&gt;&gt; text1&gt;&gt;&gt; text2&gt;&gt; text3&gt; text4 显示效果： 这是一个有两段文字的引用 text1 text2 text3text4 引用的其它要素引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：代码： 1234567&gt; 1. 第一列表项&gt; 2. 第二列表项&gt;&gt; text1&gt;&gt;&gt; text2&gt;&gt; return shell_exec(&quot;echo $input | $markdown_script&quot;);&gt; `return shell_exec(&quot;echo $input | $markdown_script&quot;);` 显示效果： 第一列表项 第二列表项 text1 text2 return shell_exec(&quot;echo $input | $markdown_script&quot;);return shell_exec(&quot;echo $input | $markdown_script&quot;); 插入图片图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。语法中图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。 行内式语法说明：![图片Alt](图片地址 "图片Title")代码： 1![图片示例](http://img.redocn.com/sheji/20141219/zhongguofengdaodeliyizhanbanzhijing_3744115.jpg &quot;图片示例&quot;) 显示效果： 参考式语法说明：（这里不作介绍）在文档要插入图片的地方写![图片Alt][标记]在文档的最后写上写[标记]:图片地址 “Title” 内容目录在段落中填写 [TOC] 以显示全文内容的目录结构。Hexo博客对目录的解析似乎也有限，请在Markdown编辑器中自行尝试。Next主题的话是也可以自动生成目录的，所以不需要额外增加目录。 注脚语法说明：在需要添加注脚的文字后加上脚注名字[^脚注名字]，称为加注。然后在文本的任意位置（一般在最后）添加脚注，脚注前必须有对应的脚注名字。注意：经测试注脚和脚注之间必须空一行，不然会失效。成功后会发现，即使没有把注脚卸载文末，经Markdown转换后，也会自动归类到文章的最后。代码： 1234使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。[^1]: Markdown是一种纯文本标记语言[^2]: HyperText Markup Language 超文本标记语言[^Le]: 开源笔记平台，支持Markdown和笔记直接发为博文 显示效果：使用 Markdown^1可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。 [^2]: HyperText Markup Language 超文本标记语言[^Le]: 开源笔记平台，支持Markdown和笔记直接发为博文 LaTex公式$表示行内公式代码： 1质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。 显示效果：质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。注意：我的博客没有开启公式显示，所以可能公式显示不准确，请自己用Markdown编辑器查看效果 $表示整行公式代码： 123$$\sum_&#123;i=1&#125;^n a_i=0$$$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$$$\sum^&#123;j-1&#125;_&#123;k=0&#125;&#123;\widehat&#123;\gamma&#125;_&#123;kj&#125; z_k&#125;$$ 表格语法说明：不管是哪种方式，第一行为表头，第二行分割表头和主体部分，第三行开始每一行为一个表格行。列与列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。代码： 1234567简单方式写表格：学号|姓名|分数-|-|-小明|男|75小红|女|79小陆|男|92 1234567原生方式写表格：| 学号 | 姓名 | 分数 || ---- | ---- | ---- || 小明 | 男 | 75 || 小红 | 女 | 79 || 小陆 | 男 | 92 | 123456为表格第二列指定方向：| 产品 | 价格 || ---------------- | -------: || Leanote 高级账号 | 60元/年 || Leanote 超级账号 | 120元/年 | 显示效果：简单方式写表格： 学号 姓名 分数 小明 男 75 小红 女 79 小陆 男 92 原生方式写表格： 学号 姓名 分数 小明 男 75 小红 女 79 小陆 男 92 为表格第二列指定方向： 产品 价格 Leanote 高级账号 60元/年 Leanote 超级账号 120元/年 分割线你可以在一行中用三个以上的星号、减号、底线来建立一个分割线，行内不能有其他东西。也可以在星号或是减号中间插入空格。下面每种写法都可以建立分割线：代码： 12345* * *********- - ---------------------------------------- 代码对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(Tab), 另一种是利用”`”符号（一般在ESC键下方）包裹代码。语法说明：插入行内代码，即插入一个单词或者一句代码的情况，使用&lt;code&gt;这样的形式插入。插入多行代码，可以使用缩进或者“code “,具体看示例。注意： 缩进式插入前方必须有空行 行内式代码： 1C语言里的函数 `scanf()` 怎么使用？ 显示效果：C语言里的函数 scanf() 怎么使用？ 缩进式多行代码缩进4个空格或是一个制表符（Tab）一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。代码： 12345#include &lt;stdio.h&gt;int main(void)&#123; printf(&quot;Hello world\n&quot;);&#125; 显示效果： #include &lt;stdio.h&gt;int main(void){ printf(“Hello world\n”);} 用三个” `”包裹多行代码输入三个后空一行写代码，结束后另起一行输入三个表示代码块的结束 HTML 原始码Markdown支持很多HTML代码，具体不展开。]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
