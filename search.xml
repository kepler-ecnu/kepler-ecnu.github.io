<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot-07]]></title>
    <url>%2F2019%2F08%2F14%2FSpringBoot-07%2F</url>
    <content type="text"><![CDATA[配置文件详解YML是什么SpringBoot使用一个全局的配置文件，配置文件名是固定的； application.properties application.yml 配置文件的作用：修改SpringBoot自动配置的默认值； YAML（YAML Ain’t Markup Language） YAML A Markup Language：是一个标记语言 YAML isn’t Markup Language：不是一个标记语言标记语言： 以前的配置文件；大多都使用的是xxx.xml文件； YAML：以数据为中心，比json、xml等更适合做配置文件； YAML：配置例子 12server: port: 8081 XML：配置例子 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; YML语法k:(空格)v：表示一对键值对（空格必须有）；以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的 123server: port: 8081 path: /hello 属性和值也是大小写敏感； 字面量普通的值（数字，字符串，布尔）k: v 字面量直接来写 字符串默认不用加上单引号或者双引号； &quot;&quot;：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 name: &quot;zhangsan \n lisi&quot;：输出；zhangsan 换行 lisi &apos;&apos;：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 name: ‘zhangsan \n lisi’：输出；zhangsan \n lisi对象、 Map(属性和值) (键值对)：k: v：在下一行来写对象的属性和值的关系；注意缩进​ 对象还是k: v的方式 123friends: lastName: zhangsan age: 20 行内写法： 1friends: &#123;lastName: zhangsan, age: 18&#125; 数组（List、Set）用-值表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法： 1pets: [cat, dog, pig]]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot-06]]></title>
    <url>%2F2019%2F08%2F14%2FSpringBoot-06%2F</url>
    <content type="text"><![CDATA[配置文件的使用修改配置方式 修改配置方式1：src\main\resources\application.properties1234#修改端口号server.port=8081#端口号后需额外添加字符server.servlet.context-path=/kepler 如访问：http://localhost:8081/kepler/user 1234567@RestControllerpublic class HelloWorld &#123; @GetMapping("/user") public String say() &#123; return "HelloWorld!"; &#125;&#125; 修改配置方式2：src\main\resources\application.yml1234server: port: 8081 servlet: context-path: /kepler 切换配置文件多配置文件 src\main\resources\application-dev.yml 12server: port: 8081 src\main\resources\application-prod.yml 12server: port: 8080 src\main\resources\application.yml根据active:来切换配置文件 1234567spring: profiles: active: prod或spring: profiles: active: dev 单配置文件（分块） 在单一文件中，可以用连续三个连字号（-）区分多个文件 根据active：来切换配置文件12345678910111213server: port: 8081spring: profiles: prod---server: port: 8080spring: profiles: dev---spring: profiles: active: prod 或 dev 激活指定profile 在配置文件中指定spring.profiles.active=dev 命令行： java -jar xxxx.jar –spring.profiles.active=dev可以直接在测试的时候，配置传入命令行参数 虚拟机参数，在IDEA或Eclipse中的run configuration中可以进行配置 -Dspring.profiles.active=dev 配置文件加载位置springboot 启动后扫描以下位置的application.properties或者application.yml文件，作为Spring boot的默认配置文件 位置 说明 –file:./config/ 项目目录下的config –file:./ 项目目录下 –classpath:/config/ resources目录下的config –classpath:/ resources目录下 优先级由高到底，高优先级的配置会覆盖低优先级的配置； SpringBoot会从这四个位置全部加载主配置文件；互补配置； 我们还可以通过spring.config.location来改变默认的配置文件位置 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置； 指定配置文件和默认加载的这些配置文件共同起作用形成互补配置； java -jar xxx.jar -–spring.config.location=E:/application.yml 从spring的运行日志中可以看到： 1234Loaded config file 'file:./config/application.yml' (file:./config/application.yml)Loaded config file 'file:./application.yml' (file:./application.yml)Loaded config file 'file:/C:/Users/Administrator/Desktop/demo3/target/classes/config/application.yml' (classpath:/config/application.yml)Loaded config file 'file:/C:/Users/Administrator/Desktop/demo3/target/classes/application.yml' (classpath:/application.yml) 配置文件的加载顺序： ./config/application.yml 项目目录下的config目录下的配置文件 ./application.yml 项目目录下的配置文件 classpath:/config/application.yml 资源路径下的config 目录下的配置文件 classpath:/application.yml 资源路径下的配配置文件 总结: 先加载的优先级最高，后面的优先级低。 后面的配置文件中如果有不同的配置项，也会读取进来。]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot-05]]></title>
    <url>%2F2019%2F08%2F14%2FSpringBoot-05%2F</url>
    <content type="text"><![CDATA[SwaggerAPI框架为了方便上面的API接口调试，我们可以使用： Postman：模拟POST请求 SWAgger：描述和测试API接口 添加依赖12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; Swagger配置yml配置文件 1234567swagger: title: SpringBoot学习 description: SpringBoot入门 version: 1.0.0 name: ailee url: https://kepler-ecnu.github.io email: 1519535214@qq.com Swagger配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.example.demo.config;import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.EnableWebMvc;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.Contact;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;@Configuration // 必须存在@EnableWebMvc // 必须存在@EnableSwagger2 // 必须存在@ConfigurationProperties(prefix = "swagger") // swagger 与 yml 文件中一致@Data // lombok@ComponentScan(basePackages = &#123;"com.example.demo.controller"&#125;)public class SwaggerConfig &#123; private String title; private String description; private String version; private String name; private String url; private String email; @Bean public Docket customDocket() &#123; return new Docket( DocumentationType.SWAGGER_2).apiInfo(apiInfo()); &#125; private ApiInfo apiInfo() &#123; Contact contact = new Contact(name, url, email); return new ApiInfoBuilder() .title(title) .description(description) .contact(contact) .version(version) .build(); &#125;&#125; 配置文件中的值到配置类中的注入，在第八章springboot-08-配置文件的注入中有介绍 MVC配置 作用：过滤网页静态资源123456789101112@Configurationclass WebMvcConfig implements WebMvcConfigurer &#123; public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler("swagger-ui.html") .addResourceLocations("classpath:/META-INF/resources/"); registry.addResourceHandler("/webjars/**") .addResourceLocations("classpath:/META-INF/resources/webjars/"); &#125;&#125; Swagger的具体用法，可以学习B站Swagger视频 Webjars的使用官网：https://www.webjars.org/ 12345&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1-1&lt;/version&gt;&lt;/dependency&gt; 通过jar包的方式引入了jQuery在浏览器中可以通过如下地址访问到，http://localhost:8080/webjars/jquery/3.4.1/jquery.js 地址说明：/webjars/jquery/3.4.1/jquery.js 对应上面的 webjars/ artifactId/version/文件名 可以到项目中的jar包中具体查看。]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Java</tag>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot-04]]></title>
    <url>%2F2019%2F08%2F14%2FSpringBoot-04%2F</url>
    <content type="text"><![CDATA[参数传递参数传递可以说是服务端和外界沟通的主要方式，这是非常重要的!本节内容包括： 12345678通过url传参 |---get方式Url传参 |---@PathVariable 即：url/id/1994 形式 |---@RequestParam 即：url?username=zed形式 |---POST方式传参 |---@RequestParam |---请求体中加入文本配置文件传参 get方式URL传参@PathVariable 123456789@RestControllerpublic class HelloController &#123; @GetMapping("/hello/&#123;name&#125;") public String hello(@PathVariable("name") String name)&#123; // 形参的name可以随意 System.out.println("获取到的name是："+name); return "hello "+name; &#125;&#125; 访问： http://localhost:8080/hello/xxxxx @RequestParm如果请求参数的名字跟方法中的形参名字一致可以省略@RequestParam(“name”) 12345@GetMapping("/hello")public String hello(@RequestParam("name") String name)&#123; System.out.println("获取到的name是："+name); return "hello "+name;&#125; 1234@GetMapping("/hello") public String hello( String name)&#123; return "Hello " + name; &#125; 访问：http://localhost:8080/user?name=xxxx @RequestParm + 默认参数如果请求参数的名字跟方法中的形参名字一致可以省略@RequestParam(“name”) 12345@GetMapping("/hello") public String hello(@RequestParam(value = "name",defaultValue = "admin") String name)&#123; System.out.println("获取到的name是："+name); return "hello "+name; &#125; 访问：http://localhost:8080/user?name=xxxx注意：如果没有指定默认值，并且没有传递参数将会报错Required String parameter &#39;name&#39; is not present :name参数没有提供 解决方案 1.defaultValue = “xxx” ：使用默认值 2.required = false ：标注参数是非必须的12345@GetMapping("/hello")public String hello(@RequestParam(value = "name",required = false) String name)&#123; System.out.println("获取到的name是："+name); return "hello "+name;&#125; POST方式传递数据12345678910@RestControllerpublic class HelloController &#123; public static Logger log = LoggerFactory.getLogger(HelloController.class); @PostMapping("/user") public String add(@RequestParam("name") String name,@RequestParam("age") Integer age)&#123; log.info(name+" "+age); return "name:"+name+"\nage:"+age; &#125;&#125; post不能用浏览器直接访问，这里用Postman测试： POST传递字符串文本通过HttpSerletRequest获取输入流 1234567891011121314151617181920212223242526@PostMapping("/PostString")public String postString(HttpServletRequest request) &#123; ServletInputStream is = null; try &#123; is = request.getInputStream(); StringBuilder sb = new StringBuilder(); byte[] buf = new byte[1024]; int len = 0; while ((len = is.read(buf)) != -1) &#123; sb.append(new String(buf, 0, len)); &#125; System.out.println(sb.toString()); return sb.toString(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (is != null) &#123; is.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return null;&#125; 这里用Postman测试： @RequestBody接收参数 @RequestBody可以接收GET或POST请求中的参数 把json作为参数传递，要用 RequestBody 附带说一下使用postman方式设置content-type为application/json方式测试后台接口1234567@PostMapping("/save")@ResponseBodypublic Map&lt;String,Object&gt; save(@RequestBody User user)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt; (); map.put("user",user); return map;&#125; 12345@PostMapping("/user")public String user(@RequestBody User user)&#123; log.info(user.toString()); return null;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot-03]]></title>
    <url>%2F2019%2F08%2F14%2FSpringBoot-03%2F</url>
    <content type="text"><![CDATA[原理POM 文件 父项目 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; 它的父项目是 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt; 这是真正管理Spring Boot应用里面所依赖的版本Spring Boot的版本仲裁中心；以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号） 启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-web：spring-boot-starter：spring-boot场景启动器，帮我们导入了web模块正常运行所依赖的组件；点击进去可以看到帮我们引入很多web相关的依赖Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来，要用什么功能就导入什么场景的启动器 主程序类，主入口类12345678@SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; @SpringBootApplication : Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用； 12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; @SpringBootConfiguration : Spring Boot的配置类，标注在某个类上，表示这是一个Spring Boot的配置类 @Configuration : 配置类上来标注这个注解，配置类也是容器中的一个组件@Component @EnableAutoConfiguration：开启自动配置功能 123@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; 将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器； 调用了SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)； Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作； 以前我们需要自己配置的东西，自动配置类都帮我们； 有了自动配置类，免去了我们手动编写配置注入功能组件等的工作； J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar； 自动配置原理 SpringBoot启动的时候加载主配置类，开启了自动配置功能 @EnableAutoConfiguration @EnableAutoConfiguration 作用： 利用EnableAutoConfigurationImportSelector给容器中导入一些组件 可以查看selectImports()方法的内容； List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置1234SpringFactoriesLoader.loadFactoryNames()扫描所有jar包类路径下 META-INF/spring.factories把扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中 将类路径下 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中 精髓：​ 1） SpringBoot启动会加载大量的自动配置类​ 2） 我们看我们需要的功能有没有SpringBoot默认写好的自动配置类；​ 3） 我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）​ 4） 给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值； 12xxxxAutoConfigurartion：自动配置类(给容器中添加组件)；xxxxProperties:封装配置文件中相关属性；]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot-02]]></title>
    <url>%2F2019%2F08%2F14%2FSpringBoot-02%2F</url>
    <content type="text"><![CDATA[再体验URL其他形式-窄化请求 url的其他形式：类和方法都有value时 1234567891011/** * 窄化请求 */@RestController@RequestMapping("/user")public class HelloWorld &#123; @GetMapping("/hello") public String hello()&#123; return "hello SpringBoot"; &#125;&#125; 配置多url对1映射 访问：http://localhost:8080/hello 或 http://localhost:8080/hi12345678@RestController@RequestMapping("/user")public class HelloWorld &#123; @GetMapping(value = &#123;"/hello","/hi"&#125;) public String hello()&#123; return "hello SpringBoot"; &#125;&#125; 其他创建方式 Spring Initializr：通过IDEA或者其他工具创建Initializr项目 创建Maven项目手动添加依赖 通过https://start.spring.io/ 生成定制项目 其他运行方式 在IDE中直接运行 发布Jar包运行 在pom/xml文件引用插件 123456789&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 导入这个maven插件，利用idea打包，生成的jar包，可以使用java -jar xxx.jar启动 Spring Boot 使用嵌入式的Tomcat无需再配置Tomcat]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot-01]]></title>
    <url>%2F2019%2F08%2F13%2FSpringBoot-01%2F</url>
    <content type="text"><![CDATA[初体验使用IDEA创建一个项目 目录结构说明 src/main/java: Java代码的目录 src/main/resources: 资源目录 src/test/java: 测试代码的目录 src/test/resources: 测试资源目录 POM文件说明 添加Banner文件在resources目录下创建banner.txt文件，添加以下内容可以更换成你自己的banner 12345678910$&#123;AnsiColor.BLUE&#125; _ _ | | _____ _ __ | | ___ _ __ | |/ / _ \ &apos;_ \| |/ _ \ &apos;__| | &lt; __/ |_) | | __/ | |_|\_\___| .__/|_|\___|_| |_| -----版本号-----$&#123;spring-boot.version&#125; 创建Controller类 文件模板修改 12345678@Controllerpublic class HelloWorld &#123; @RequestMapping(value = "/hello",method = RequestMethod.GET) @ResponseBody public String hello()&#123; return "hello SpringBoot"; &#125;&#125; 注解方式还有一种，和上面的效果一样 12345678910/** * 更多注解方式 */@RestControllerpublic class HelloWorld &#123; @GetMapping("/hello") public String hello()&#123; return "hello SpringBoot"; &#125;&#125; 注解说明： 123@RestController: 处理http请求:等同于@Controller+@ResponseBody@RequestMapping: value = "访问的路由" method = 请求方法@GetMapping：以GET方式请求 相当于对@RequestMapping配置的缩写 启动执行main方法访问:http://localhost:8080/hello 主程序说明： 1234567@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(Application.class, args); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot-00]]></title>
    <url>%2F2019%2F08%2F13%2FSpringBoot-00%2F</url>
    <content type="text"><![CDATA[这部分内容学习和摘录于B站稀客大大 Spring Boot 简介 简化Spring应用开发的一个框架 整个Spring技术栈的一个大整合 J2EE开发的一站式解决方案 微服务 架构风格（服务微化） 一个应用应该是一组小型服务；可以通过HTTP的方法进行互通 单体应用： ALL IN ONE 每一个功能元素最终都是一个可独立替换和独立升级的软件单元 环境准备 环境约束 jdk 1.8+ maven 3.3+ A favorite text editor or IDE: Intellij IDEA SpringBoot Maven配置进入maven文件目录，给M2_HOME\conf\settings.xml配置文件添加如下内容： 在&lt;mirrors&gt;和&lt;/mirrors&gt;之间添加如下内容 作用：国内maven仓库镜像（国内不能很好的访问maven中央仓库） 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 在&lt;profiles&gt;和&lt;/profiles&gt; 作用：指定项目编译运行使用的JDK版本 123456789101112131415161718192021222324252627&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;!-- 如果是在学校或公司有maven私服，可以在这里配置私服 --&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;accp&lt;/id&gt; &lt;name&gt;accp&lt;/name&gt; &lt;url&gt;http://192.168.1.48:8081/repository/accp/&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!-- 如果没有私服，这里不用配置 --&gt;&lt;/profile&gt; IDEA配置整合Maven进来 修改Banner12345678910$&#123;AnsiColor.BLUE&#125; _ _ | | _____ _ __ | | ___ _ __ | |/ / _ \ &apos;_ \| |/ _ \ &apos;__| | &lt; __/ |_) | | __/ | |_|\_\___| .__/|_|\___|_| |_| -----版本号-----$&#123;spring-boot.version&#125; 文字Banner可以从这个网站生成(有很多种字体样式可以选择)http://patorjk.com/software/taag${AnsiColor.BLUE} 表示Banner文字的颜色${spring-boot.version} 当前使用的SpringBoot版本]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java数据库篇]]></title>
    <url>%2F2019%2F08%2F12%2FJava%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87%2F</url>
    <content type="text"><![CDATA[MySQL主键 超键 候选键 外键 主键数据库表中存储数据对象允以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null） 超键在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。 候选键是最小超键，即没有冗余元素的超键 外键在一个表中存在的另一个表的主键称为此表的外键 假设有如下两个表：学生（学号，姓名，性别，身份证号，教师编号）教师（教师编号，姓名，工资） 超键：由超键的定义可知，学生表中含有学号或者身份证号的任意组合都为此表的超键。如：（学号）、（学号，姓名）、（身份证号，性别）等。 候选键：候选键属于超键，它是最小的超键，就是说如果再去掉候选键中的任何一个属性它就不再是超键了。学生表中的候选键为：（学号）、（身份证号）。 主键：主键就是候选键里面的一个，是人为规定的，例如学生表中，我们通常会让“学号”做主键，教师表中让“教师编号”做主键。 外键：外键比较简单，学生表中的外键就是“教师编号”。外键主要是用来描述两个表的关系。 什么是事务百度百科中解释：指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。简单的说，事务就是并发控制的单位，是用户定义的一个操作序列。 什么是锁锁（LOCKING）是最常用的并发控制机构。是防止其他事务访问指定的资源控制、实现并发控制的一种主要手段。锁是事务对某个数据库中的资源（如表和记录）存取前，先向系统提出请求，封锁该资源，事务获得锁后，即取得对数据的控制权，在事务释放它的锁之前，其他事务不能更新此数据。当事务撤消后，释放被锁定的资源。当一个用户锁住数据库中的某个对象时，其他用户就不能再访问该对象 在所有的数据库管理系统（DBMS）中，锁是实现事务的关键，锁可以保证事务的完整性和并发性。与现实生活中锁一样，它可以使某些数据的拥有者，在某段时间内不能使用某些数据或数据结构。 说一下 MySQL 常用的引擎 MyISAM：默认表类型，它是基于传统的ISAM类型，ISAM是Indexed Sequential Access Method (有索引的顺序访问方法) 的缩写，它是存储记录和文件的标准方法。不是事务安全的，而且不支持外键，如果执行大量的select，insert MyISAM比较适合。不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。 InnoDB：支持事务安全的引擎，支持外键、行锁、事务是他的最大特点。如果有大量的update和insert，建议使用InnoDB，特别是针对多个并发和QPS较高的情况。默认引擎，InnoDB 引擎提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。 说一下 MySQL 的行锁和表锁MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。 表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。 行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。 说一下乐观锁和悲观锁 乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。 悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。 数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。 数据库事务的四个特性及含义一个逻辑工作单元要成为事务，就必须满足ACID属性A：原子性（Atomicity） 事务中的操作要么都不做，要么就全做C：一致性（Consistency） 事务执行的结果必须是从数据库从一个一致性状态转换到另一个一致性状态。I：隔离性（Isolation） 一个事务的执行不能被其他事务干扰D：持久性（Durability） 一个事务一旦提交，它对数据库中数据的改变就应该是永久性的 事务的隔离级别 读未提交（Read Uncommitted) 引发脏读（读取了未提交的数据） 读已提交（Read Committed) 这是大多数数据库系统默认的隔离级别，但不是MySQL默认的 只能看见已经提交事务所做的改变 引发不可重复读，不可重读读意味着我们同一事务执行完全相同的select语句时可能看到不一样的结果。导致这种情况的原因可能有：(1)有一个交叉的事务有新的commit，导致了数据的改变; (2)一个数据库被多个实例操作时,同一事务的其他实例在该实例处理其间可能会有新的commit,多个commit提交时，只读一次出现结果不一致 可重复读（Repeatable Read） 这是MySQL的默认事务隔离级别 它确保同一事务的多个实例在并发读取数据时，看到同样的数据行 此级别可能出现的问题–幻读（Phantom Read），当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行 InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决了该问题 可串行化（Serializable） 这是最高的隔离级别 它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它在每个读的数据行上加上共享锁。 可能导致大量的超时现象和锁竞争 隔离级别 脏读 不可重复读 幻读 读未提交 √ √ √ 读已提交 × √ √ 可重复读 × × √ 可串行化 × × × 事务运行的三种模式 自动提交事务 每条单独的语句都是一个事务，每个语句都隐含一个commit 显式事务 以begin transaction 开始，以commit 或 rollback 结束。 隐性事务 在前一个事务完成时，新事务隐式启动，但每个事务仍以commit或rollback显示结束 注意：隔离级别的设置只对当前链接有效。对于使用MySQL命令窗口而言，一个窗口就相当于一个链接，当前窗口设置的隔离级别只对当前窗口中的事务有效；对于JDBC操作数据库来说，一个Connection对象相当于一个链接，而对于Connection对象设置的隔离级别只对该Connection对象有效，与其他链接Connection对象无关。 事务通常以begin（start） transaction 开始，以commit 或 rollback 结束。commit 表示提交，将事务中所有对数据库的更新写会到磁盘的物理数据库中，事务正常结束。rollback表示回滚，即在事务运行的过程中发生了某种故障，事务不能继续进行，系统将事务中对数据库的所有以完成的操作全部撤消，滚回到事务开始的状态。 视图的作用，视图可以更改么视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询；不包含任何列或数据。使用视图可以简化复杂的sql操作，隐藏具体的细节，保护数据；视图创建后，可以使用与表相同的方式利用它们。视图不能被索引，也不能有关联的触发器或默认值，如果视图本身内有order by 则对视图再次order by将被覆盖。create view 视图名 as 查询语句;对于某些视图比如未使用联结子查询分组聚集函数Distinct Union等，是可以对其更新的，对视图的更新将对基表进行更新；但是视图主要用于简化检索，保护数据，并不用于更新，而且大部分视图都不可以更新。 游标是什么游标：是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。 视图的优缺点优点： 1. 对数据库的访问，因为视图可以有选择性的选取数据库里的一部分。 2. 用户通过简单的查询可以从复杂查询中得到结果。 3. 维护数据的独立性，视图可从多个表检索数据。 4. 对于相同的数据可产生不同的视图。缺点：查询视图时，必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么就无法更改数据 列举几种表连接方式,有什么区别内连接、自连接、外连接（左、右、全）、交叉连接 内连接：只有两个元素表相匹配的才能在结果集中显示。 自连接：自连接(self join)是SQL语句中经常要用的连接方式，使用自连接可以将自身表的一个镜像当作另一个表来对待，从而能够得到一些特殊的数据。 外连接： 左外连接: 左边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。 右外连接: 右边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。 全外连接：连接的表中不匹配的数据全部会显示出来。 交叉连接：笛卡尔效应，显示的结果是链接表数的乘积。 drop,delete与truncate的区别区别一：根据sql语言分类来说，delete属于DML语言，也就是数据操作语言，而truncate属于DDL语言，也就是数据定义语言。 区别二：delete不仅可以删除表中的数据，还可以删除基于真实表创建的视图中的数据。truncate则只能删除表中的数据，不能作用于视图。 区别三：在数据库删除数据时，delete可以根据需要进行删除，也就是delete可以结合where条件进行精确的删除某一条数据，而truncate则不能支持where子句，如果作用于表，则是直接删除表所有数据。 区别四：delete删除表时，会涉及到事务处理，也就是可以支持事务提交，回滚。所谓事务就是支持数据一致性，原子性，持久性，隔离性。当使用delete删除表数据时，首先它不会真正删除，而是会将删除的数据放入一个缓存区，可以通过回滚，从而恢复数据。但是使用truncate删除表中数据时，truncate不涉及事务处理，所以被truncate删除的数据是不可恢复的。 区别五：由于delete删除数据涉及到事务处理，会涉及到缓存，当数据非常大时，有可能缓存不够用，所以这时使用delete删除数据可能达不到删除到的目的，而且速度特别慢。当涉及到大批量的数据时，truncate就非常适合，因为他不涉及到缓存，所以速度特别快，效率也高。 区别六：有时候对数据操作可能涉及到触发器，用delete删除数据时则有可能会激活触发器，进行一些操作。而truncate是不存在触发器的处理的。 区别七：在对于一些存在关联关系的表，使用delete删除数据时，可以运用sql的业务逻辑顺序来进行达到删除数据的目的。例如表A与表B存在一对多的关系，表A中id为主键，并且id在表B中是作为表B的外键。要删除数据，这时不能直接删除表B,而应该先删除表A在进行删除表B,这样就达到目的。而truncate不能删除对于由外键约束的表，它达不到删除该表的目的。 delete和truncate的应用场景 delete适用于数据量较小，对于性能要求不是很高的情况下，可以采用delete加上where子句进行删除数据。 如果需要考虑事务提交，回滚操作的，适合适用delete进行删除数据。 当涉及到大量数据，而且是不需要回滚的情况下，并且要求速度快，效率高，则可以使用truncate来删除数据。 delete和truncate是用来删除表数据的（但是保留表结构），而drop是用来删除整个表的，包括表结构和表内容，在sql语言分类上它是属于DDL语言。 他们执行的速度快慢关系：drop&gt;truncate&gt;delete。 最后，在企业级项目开发中，对于数据并不是真正的从物理上进行删除，而是进行逻辑上的删除，此时会对删除数据进行一个删除标识的处理，也就是说只是把数据从页面上隐藏了，用户暂时看不见了而已，其实数据是还存在的。 触发器的作用触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。 什么是存储过程？用什么来调用？百度百科：存储过程（Stored Procedure）是在大型数据库系统中，一组为了完成特定功能的SQL语句集，它存储在数据库中，一次编译后永久有效，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。 12345678CREATE PROCEDURE order_tot_amt@o_id int,@p_tot int outputASSELECT @p_tot = sum(Unitprice*Quantity)FROM orderdetailsWHERE orderid=@o_idGO 例子说明：该例子是建立一个简单的存储过程order_tot_amt,这个存储过程根据用户输入的订单ID号码(@o_id),由订单明细表 (orderdetails)中计算该订单销售总额[单价(Unitprice)*数量(Quantity)],这一金额通过@p_tot这一参数输出给调用这一存储过程的程序。调用：1）可以用一个命令对象来调用存储过程。2）可以供外部程序调用，比如：java程序。 存储过程的优缺点？优点： 存储过程是预编译过的，执行效率高。 存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。 安全性高，执行存储过程需要有一定权限的用户。 存储过程可以重复使用，可减少数据库开发人员的工作量。 缺点：移植性差 存储过程与函数的区别本质上没区别，执行的本质都一样。只是函数有如：只能返回一个变量的限制。而存储过程可以返回多个。 函数是可以嵌入在sql中使用的,可以在select中调用，而存储过程要让sql的query可以执行，需要把 mysql_real_connect 的最后一个参数设置为CLIENT_MULTI_STATEMENTS。函数限制比较多，比如不能用临时表，只能用表变量．还有一些函数都不可用等等．而存储过程的限制相对就比较少。 特性区别如下： 一般来说，存储过程实现的功能要复杂一点，而函数的实现的功能针对性比较强。存储过程，功能强大，可以执行包括修改表等一系列数据库操作；用户定义函数不能用于执行一组修改全局数据库状态的操作。 对于存储过程来说可以返回参数，如记录集，而函数只能返回值或者表对象。函数只能返回一个变量；而存储过程可以返回多个。存储过程的参数可以有IN,OUT,INOUT三种类型，而函数只能有IN类~~存储过程声明时不需要返回类型，而函数声明时需要描述返回类型，且函数体中必须包含一个有效的RETURN语句。 存储过程，可以使用非确定函数，不允许在用户定义函数主体中内置非确定函数。 存储过程一般是作为一个独立的部分来执行（ EXECUTE 语句执行），而函数可以作为查询语句的一个部分来调用（SELECT调用），由于函数可以返回一个表对象，因此它可以在查询语句中位于FROM关键字的后面。 SQL语句中不可用存储过程，而可以使用函数。 当存储过程和函数被执行的时候，SQL Manager会到procedure cache中去取相应的查询语句，如果在procedure cache里没有相应的查询语句，SQL Manager就会对存储过程和函数进行编译。Procedure cache中保存的是执行计划 (execution plan) ，当编译好之后就执行procedure cache中的execution plan，之后SQL SERVER会根据每个execution plan的实际情况来考虑是否要在cache中保存这个plan，评判的标准一个是这个execution plan可能被使用的频率；其次是生成这个plan的代价，也就是编译的耗时。保存在cache中的plan在下次执行时就不用再编译了。 小结：触发器与存储过程非常相似，触发器也是SQL语句集，两者唯一的区别是触发器不能用EXECUTE语句调用，而是在用户执行Transact-SQL语句时自动触发（激活）执行。触发器是在一个修改了指定表中的数据时执行的存储过程。通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。由于用户不能绕过触发器，所以可以用它来强制实施复杂的业务规则，以确保数据的完整性。触发器不同于存储过程，触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。当对某一表进行诸如UPDATE、INSERT、DELETE这些操作时，SQLSERVER就会自动执行触发器所定义的SQL语句，从而确保对数据的处理必须符合这些SQL语句所定义的规则。 索引的作用及其优缺点索引就一种特殊的查询表，数据库的搜索可以利用它加速对数据的检索。它很类似与现实生活中书的目录，不需要查询整本书内容就可以找到想要的数据。索引可以是唯一的，创建索引允许指定单个列或者是多个列。缺点是它减慢了数据录入的速度，同时也增加了数据库的尺寸大小。 索引的工作原理及其种类数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。 在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。 为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。上图展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)的复杂度内获取到相应数据。 创建索引可以大大提高系统的性能。 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 也许会有人要问：增加索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？因为，增加索引也有许多不利的方面。 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。一般来说，应该在这些列上创建索引： 在经常需要搜索的列上，可以加快搜索的速度； 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构； 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度； 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的； 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间； 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。 同样，对于有些列不应该创建索引。一般来说，不应该创建索引的的这些列具有下列特点： 对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。 对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。 对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。 当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。 根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。 唯一索引 唯一索引是不允许其中任何两行具有相同索引值的索引。 当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。主键索引 数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。 在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。聚集索引 在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。 如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。 局部性原理与磁盘预读由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。 由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。 B-/+Tree索引的性能分析到这里终于可以分析B-/+Tree索引的性能了。上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。 而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。综上所述，用B-Tree作为索引结构效率是非常高的。 数据库三大范式 第一范式（1NF）在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。简而言之，第一范式就是无重复的列。 第二范式（2NF）第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键、主码。第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是非主属性非部分依赖于主关键字。 第三范式（3NF）满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性。（我的理解是消除冗余） 为什么用自增列作为主键 如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引、如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引、如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。 数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点） 如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页 如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。 为什么使用数据索引能提高效率 数据索引的存储是有序的 在有序的情况下，通过索引查询一个数据是无需遍历索引记录的 极端情况下，数据索引的查询效率为二分法查询效率，趋近于 log2(N) B+树索引和哈希索引的区别B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接，是有序的哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可,是无序的哈希索引的优势： 等值查询。哈希索引具有绝对优势（前提是：没有大量重复键值，如果大量重复键值时，哈希索引的效率很低，因为存在所谓的哈希碰撞问题。）哈希索引不适用的场景： 不支持范围查询 不支持索引完成排序 不支持联合索引的最左前缀匹配规则 通常，B+树索引结构适用于绝大多数场景，像下面这种场景用哈希索引才更有优势：在HEAP表中，如果存储的数据重复度很低（也就是说基数很大），对该列数据以等值查询为主，没有范围查询、没有排序的时候，特别适合采用哈希索引，例如这种SQL：select id,name from table where name=’李明’; — 仅等值查询而常用的InnoDB引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况，如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引），通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。 注意：在某些工作负载下，通过哈希索引查找带来的性能提升远大于额外的监控索引搜索情况和保持这个哈希表结构所带来的开销。但某些时候，在负载高的情况下，自适应哈希索引中添加的read/write锁也会带来竞争，比如高并发的join操作。like操作和%的通配符操作也不适用于自适应哈希索引，可能要关闭自适应哈希索引。 B树和B+树的区别B树，每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为nul，叶子结点不包含任何关键字信息。B+树，所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接，所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息) 为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引 B+的磁盘读写代价更低B+的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。 B+-tree的查询效率更加稳定由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。 MySQL联合索引 联合索引是两个或更多个列上的索引。对于联合索引:Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。例如索引是key index (a,b,c). 可以支持a 、 a,b 、 a,b,c 3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。 利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引 不同于使用两个单独的索引。复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。如果您知 道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不姓，电话簿将没有用处。 什么情况下应不建或少建索引 表记录太少 经常插入、删除、修改的表 数据重复且分布平均的表字段，假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。 经常和主字段一块查询但主字段索引值比较多的表字段 MySQL分区一. 什么是表分区？表分区，是指根据一定规则，将数据库中的一张表分解成多个更小的，容易管理的部分。从逻辑上看，只有一张表，但是底层却是由多个物理分区组成。 二. 表分区与分表的区别分表：指的是通过一定规则，将一张表分解成多张不同的表。比如将用户订单记录根据时间成多个表。分表与分区的区别在于：分区从逻辑上来讲只有一张表，而分表则是将一张表分解成多张表。 三. 表分区有什么好处？ 分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备。 2. 和单个磁盘或者文件系统相比，可以存储更多数据 优化查询。在where语句中包含分区条件时，可以只扫描一个或多个分区表来提高查询效率；涉及sum和count语句时，也可以在多个分区上并行处理，最后汇总结果。 分区表更容易维护。例如：想批量删除大量数据可以清除整个分区。 可以使用分区表来避免某些特殊的瓶颈，例如InnoDB的单个索引的互斥访问，ext3问价你系统的inode锁竞争等。 四. 分区表的限制因素 一个表最多只能有1024个分区 MySQL5.1中，分区表达式必须是整数，或者返回整数的表达式。在MySQL5.5中提供了非整数表达式分区的支持。 如果分区字段中有主键或者唯一索引的列，那么多有主键列和唯一索引列都必须包含进来。即：分区字段要么不包含主键或者索引列，要么包含全部主键和索引列。 分区表中无法使用外键约束 MySQL的分区适用于一个表的所有数据和索引，不能只对表数据分区而不对索引分区，也不能只对索引分区而不对表分区，也不能只对表的一部分数据分区。 五. 如何判断当前MySQL是否支持分区？命令：show variables like ‘%partition%’ 运行结果:mysql&gt; show variables like ‘%partition%’;+——————-+——-+| Variable_name | Value |+——————-+——-+| have_partitioning | YES |+——————-+——-+1 row in set (0.00 sec)have_partintioning 的值为YES，表示支持分区。 六. MySQL支持的分区类型有哪些？ RANGE分区： 这种模式允许将数据划分不同范围。例如可以将一个表通过年份划分成若干个分区 LIST分区： 这种模式允许系统通过预定义的列表的值来对数据进行分割。按照List中的值分区，与R* ANGE的区别是，range分区的区间范围值是连续的。 HASH分区 ：这中模式允许通过对表的一个或多个列的Hash Key进行计算，最后通过这个Hash码不同数值对应的数据区域进行分区。例如可以建立一个对表主键进行分区的表。 KEY分区 ：上面Hash模式的一种延伸，这里的Hash Key是MySQL系统产生的。 行级锁定的优点 当在许多线程中访问不同的行时只存在少量锁定冲突。 回滚时只有少量的更改 可以长时间锁定单一的行。 行级锁定的缺点 比页级或表级锁定占用更多的内存。 当在表的大部分中使用时，比页级或表级锁定速度慢，因为你必须获取更多的锁。 如果你在大部分数据上经常进行GROUP BY操作或者必须经常扫描整个表，比其它锁定明显慢很多。 用高级别锁定，通过支持不同的类型锁定，你也可以很容易地调节应用程序，因为其锁成本小于行级锁定。 MySQL触发器简单实例 CREATE TRIGGER &lt;触发器名称&gt; –触发器必须有名字，最多64个字符，可能后面会附有分隔符.它和MySQL中其他对象的命名方式基本相象. { BEFORE | AFTER } –触发器有执行的时间设置：可以设置为事件发生前或后。 { INSERT | UPDATE | DELETE } –同样也能设定触发的事件：它们可以在执行insert、update或delete的过程中触发。 ON &lt;表名称&gt; –触发器是属于某一个表的:当在这个表上执行插入、 更新或删除操作的时候就导致触发器的激活. 我们不能给同一张表的同一个事件安排两个触发器。 FOR EACH ROW –触发器的执行间隔：FOR EACH ROW子句通知触发器 每隔一行执行一次动作，而不是对整个表执行一次。 &lt;触发器SQL语句&gt; –触发器包含所要触发的SQL语句：这里的语句可以是任何合法的语句， 包括复合语句，但是这里的语句受的限制和函数的一样。 MySQL优化 开启查询缓存，优化查询 explain你的select查询，这可以帮你分析你的查询语句或是表结构的性能瓶颈。EXPLAIN 的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的 当只要一行数据时使用limit 1，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据 为搜索字段建索引 使用 ENUM 而不是 VARCHAR，如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用 ENUM 而不是VARCHAR。 Prepared StatementsPrepared Statements很像存储过程，是一种运行在后台的SQL语句集合，我们可以从使用 prepared statements 获得很多好处，无论是性能问题还是安全问题。Prepared Statements 可以检查一些你绑定好的变量，这样可以保护你的程序不会受到“SQL注入式”攻击 垂直分表 选择正确的存储引擎 key和index的区别 key 是数据库的物理结构，它包含两层意义和作用，一是约束（偏重于约束和规范数据库的结构完整性），二是索引（辅助查询用的）。包括primary key, unique key, foreign key 等 index是数据库的物理结构，它只是辅助查询的，它创建时会在另外的表空间（mysql中的innodb表空间）以一个类似目录的结构存储。索引要分类的话，分为前缀索引、全文本索引等； 数据库优化思路 SQL语句优化 1）应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。 2）应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=0 3）很多时候用 exists 代替 in 是一个好的选择 4）用Where子句替换HAVING子句 因为HAVING只会在检索出所有记录之后才对结果集进行过滤 索引优化 看上文索引 数据库结构优化 1）范式优化： 比如消除冗余（节省空间） 2）反范式优化：比如适当加冗余等（减少join） 3）拆分表： 分区将数据在物理上分隔开，不同分区的数据可以制定保存在处于不同磁盘上的数据文件里。这样，当对这个表进行查询时，只需要在表分区中进行扫描，而不必进行全表扫描，明显缩短了查询时间，另外处于不同磁盘的分区也将对这个表的数据传输分散在不同的磁盘I/O，一个精心设置的分区可以将数据传输对磁盘I/O竞争均匀地分散开。对数据量大的时时表可采取此方法。可按月自动建表分区。 4）拆分其实又分垂直拆分和水平拆分： 案例： 简单购物系统暂设涉及如下表： 1.产品表（数据量10w，稳定） 2.订单表（数据量200w，且有增长趋势） 3.用户表 （数据量100w，且有增长趋势） 以mysql为例讲述下水平拆分和垂直拆分，mysql能容忍的数量级在百万静态数据可以到千万 垂直拆分： 解决问题：表与表之间的io竞争 不解决问题：单表中数据量增长出现的压力 方案： 把产品表和用户表放到一个server上 订单表单独放到一个server上水平拆分： 解决问题：单表中数据量增长出现的压力 不解决问题：表与表之间的io争夺 方案： 用户表通过性别拆分为男用户表和女用户表 订单表通过已完成和完成中拆分为已完成订单和未完成订单 产品表 未完成订单放一个server上 已完成订单表盒男用户表放一个server上 女用户表放一个server上(女的爱购物 哈哈) 服务器硬件优化这个么多花钱咯！ 数据库表创建注意事项一、字段名及字段配制合理性 剔除关系不密切的字段 字段命名要有规则及相对应的含义（不要一部分英文，一部分拼音，还有类似a.b.c这样不明含义的字段） 字段命名尽量不要使用缩写（大多数缩写都不能明确字段含义） 字段不要大小写混用（想要具有可读性，多个英文单词可使用下划线形式连接） 字段名不要使用保留字或者关键字 保持字段名和类型的一致性 慎重选择数字类型 给文本字段留足余量 二、系统特殊字段处理及建成后建议 添加删除标记（例如操作人、删除时间） 建立版本机制 三、表结构合理性配置 多型字段的处理，就是表中是否存在字段能够分解成更小独立的几部分（例如：人可以分为男人和女人） 多值字段的处理，可以将表分为三张表，这样使得检索和排序更加有调理，且保证数据的完整性！ 四、其它建议 对于大数据字段，独立表进行存储，以便影响性能（例如：简介字段） 使用varchar类型代替char，因为varchar会动态分配长度，char指定长度是固定的。 给表创建主键，对于没有主键的表，在查询和索引定义上有一定的影响。 免表字段运行为null，建议设置默认值（例如：int类型设置默认值为0）在索引查询上，效率立显！ 建立索引，最好建立在唯一和非空的字段上，建立太多的索引对后期插入、更新都存在一定的影响（考虑实际情况来创建）。 RedisRedis单线程问题单线程指的是网络请求模块使用了一个线程（所以不需考虑并发安全性），即一个线程处理所有网络请求，其他模块仍用了多个线程。 为什么说Redis能够快速执行 绝大部分请求是纯粹的内存操作（非常快速） 采用单线程,避免了不必要的上下文切换和竞争条件 非阻塞IO - IO多路复用 Redis的内部实现内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，不在io上浪费一点时间 这3个条件不是相互独立的，特别是第一条，如果请求都是耗时的，采用单线程吞吐量及性能很差。redis为特殊的场景选择了合适的技术方案。 Redis关于线程安全问题redis实际上是采用了线程封闭的观念，把任务封闭在一个线程，自然避免了线程安全问题，不过对于需要依赖多个redis操作的复合操作来说，依然需要锁，而且有可能是分布式锁。 使用Redis有哪些好处 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1) 支持丰富数据类型，支持string，list，set，sorted set，hash 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除 redis相比memcached有哪些优势 memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型 redis的速度比memcached快很多 redis可以持久化其数据 Redis支持数据的备份，即master-slave模式的数据备份。 使用底层模型不同，它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。 value大小：redis最大可以达到1GB，而memcache只有1MB Redis主从复制过程原理： 当从库和主库建立MS关系后,会向主数据库发送SYNC命令 主库接收到SYNC命令后会开始在后台保存快照(RDB持久化过程),并将期间接收到的写命令缓存起来 当快照完成后,主Redis会将快照文件和所有缓存的写命令发送给从Redis 从Redis接收到后,会载入快照文件并且执行收到的缓存的命令 之后,主Redis每当接收到写命令时就会将命令发送从Redis，从而保证数据的一致 缺点：所有的slave节点数据的复制和同步都由master节点来处理,会照成master节点压力太大,使用主从从结构来解决 Redis两种持久化方式的优缺点 RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot） AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 Redis 还可以同时使用 AOF 持久化和 RDB 持久化。当redis重启时,它会有限使用AOF文件来还原数据集,因为AOF文件保存的数据集通常比RDB文件所保存的数据集更加完整 RDB的优点： RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于进行备份： 比如说，你可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。 RDB 非常适用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心，或者亚马逊 S3 中。 RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。 RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快 Redis常见的性能问题都有哪些？如何解决？ Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。 Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化,如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。 Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。 Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内 Redis提供6种数据淘汰策略 volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰 volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰 volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰 allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰 allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰 no-enviction（驱逐）：禁止驱逐数据]]></content>
      <categories>
        <category>java知识点整理</category>
      </categories>
      <tags>
        <tag>java数据库篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java网络篇]]></title>
    <url>%2F2019%2F08%2F12%2FJava%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[OSI七层模型 具体7层 数据格式 功能与连接方式 典型设备 协议 应用层 数据 网络服务与使用者应用程序间的一个接口 终端设备（PC、手机、平板等） FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS 表示层 数据 数据表示、数据安全、数据压缩 终端设备 JPEG、MPEG、ASII 会话层 数据 会话层连接到传输层的映射；会话连接的流量控制；数据传输；会话连接恢复与释放；会话连接管理、差错控制 终端设备 SQL、NETBIOS、RPC 传输层 数据组织成数据段 用一个寻址机制来标识一个特定的应用程序（端口号） 终端设备 TCP、UDP、SPX 网络层 分割和重新组合数据包 基于网络层地址（IP地址）进行不同网络系统间的路径选择 网关、路由器 IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP 数据链路层 将比特信息封装成数据帧 在物理层上建立、撤销、标识逻辑链接和链路复用以及差错校验等功能。通过使用接收系统的硬件地址或物理地址来寻址 中继器、集线器 PPP、HDLC、VLAN、MAC 物理层 传输比特流 建立、维护和取消物理连接 光纤、同轴电缆 RJ45、CLOCK、IEEE802.3 总结： 应用层按协议打包数据 由传输层加上双方的端口号 由网络层加上双方的IP地址 由链路层加上双方的MAC地址，并将数据拆分成数据帧 数模信号转换并由物理层传输到另一端 TCP/IP模型 应用层，对应OSI参考模型应用层、表示层、会话层 传输层，对应OSI的传输层 网络层（网际层），对应OSI的网络层 网络接入层，对应OSI的数据链路层和物理层 OSI模型的网络层同时支持面向连接和面向无连接的通信，但是传输层只支持面向连接的通信；TCP/IP模型的网络层只提供无连接的服务，但是传输层上同时提供可靠和不可靠两种通信模式。 说一下TTLTime To Live数据包在传输过程中每经过一个路由器，TTL值就会减1，直到TTL=0时，数据包被丢弃，并发送ICMP报文通知源主机防止重复发送。 ping和tracert命令用的什么协议ICMP MTU是什么最大传输单元由于不同硬件的物理特性不同，对数据帧的最大长度都有不同的限制，这个最大长度称为MTU。（然后通过路由对IP报文进行分片完成传输） TCP报文TCP报文时TCP层传输的数据单元，也叫报文段。 序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。 确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。 确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效 同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。 终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接 PS：ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。 字段 含义 URG 紧急指针是否有效。为1，表示某一位需要被优先处理 ACK 确认号是否有效，一般置为1。 PSH 提示接收端应用程序立即从TCP缓冲区把数据读走。 RST 对方要求重新建立连接，复位。 SYN 请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1 FIN 希望断开连接。 通过对 TCP 头的解析，我们知道要掌握 TCP 协议，还应该重点关注以下问题： 连接维护 顺序问题 丢包问题 流量控制 拥塞控制 三次握手过程所有问题，首先都要建立连接，故最开始时连接维护的问题 握手过程第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 四次挥手过程 挥手过程1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。5）客户端收到服务器的连接释放报文 累计确认（TCP如何实现可靠传输）首先为了保证顺序性，每个包都有一个 ID。在建立连接的时候会商定起始 ID 是什么，然后按照 ID 一个个发送，为了保证不丢包，需要对发送的包都要进行应答，当然，这个应答不是一个一个来的，而是会应答某个之前的 ID，表示都收到了，这种模式成为累计应答或累计确认。 为了记录所有发送的包和接收的包，TCP 需要发送端和接收端分别来缓存这些记录，发送端的缓存里是按照包的 ID 一个个排列，根据处理的情况分成四个部分 发送并且确认的 发送尚未确认的 没有发送等待发送的 没有发送并且暂时不会发送的 这里的第三部分和第四部分就属于流量控制的内容 在 TCP 里，接收端会给发送端报一个窗口大小，叫 Advertised window。这个窗口应该等于上面的第二部分加上第三部分，超过这个窗口，接收端做不过来，就不能发送了 于是，发送端要保持下面的数据结构 对于接收端来讲，它的缓存里面的内容要简单一些 接收并且确认过的 还没接收，但是马上就能接收的 还没接收，但也无法接收的 对应的数据结构如下 顺序问题和丢包问题结合上面的图看，在发送端，1、2、3 已发送并确认；4、5、6、7、8、9 都是发送了还没确认；10、11、12 是还没发出的；13、14、15 是接收方没有空间，不准备发的。 在接收端来看，1、2、3、4、5 是已经完成 ACK 但是还没读取的；6、7 是等待接收的；8、9 是已经接收还没有 ACK 的。 发送端和接收端当前的状态如下： 1、2、3 没有问题，双方达成了一致 4、5 接收方说 ACK 了，但是发送方还没收到 6、7、8、9 肯定都发了，但是 8、9 已经到了，6、7 没到，出现了乱序，缓存着但是没办法 ACK。 根据这个例子可以知道顺序问题和丢包问题都有可能存在，所以我们先来看确认与重传机制。 假设 4 确认收到了，5 的 ACK 丢了，6、7 的数据包丢了，该怎么办？ 一种方法是超时重试或超时重传，即对每一个发送了但是没有 ACK 的包设定一个定时器，超过了一定的事件就重新尝试。这个时间必须大于往返时间，但也不宜过长，否则超时时间变长，访问就变慢了。 如果过一段时间，5、6、7 都超时了就会重新发送。接收方发现 5 原来接收过，于是丢弃 5；6 收到了，发送 ACK，要求下一个是 7，7 不幸又丢了。当 7 再次超时的时候，TCP 的策略是超时间隔加倍。每当遇到一次超时重传的时候，都会讲下一次超时时间间隔设为先前值的两倍。 超时重传的机制是超时周期可能相对较长，是否有更快的方式呢？ 有一个快速重传的机制，即当接收方接收到一个序号大于期望的报文段时，就检测到了数据流之间的间隔，于是发送三个冗余的 ACK，客户端接收到之后，知道数据报丢失，于是重传丢失的报文段。 例如，接收方发现 6、8、9 都接收了，但是 7 没来，所以肯定丢了，于是发送三个 6 的 ACK，要求下一个是 7。客户端接收到 3 个，就会发现 7 的确又丢了，不等超时，马上重发。 流量控制的问题（滑动窗口机制）在流量控制的机制里面，在对于包的确认中，会携带一个窗口的大小 简单的说一下就是接收端在发送 ACK 的时候会带上缓冲区的窗口大小，但是一般在窗口达到一定大小才会更新窗口，因为每次都更新的话，刚空下来就又被填满了 拥塞控制的问题（滑动窗口机制）也是通过窗口的大小来控制的，但是检测网络满不满是个挺难的事情，所以 TCP 发送包经常被比喻成往谁管理灌水，所以拥塞控制就是在不堵塞，不丢包的情况下尽可能的发挥带宽。 水管有粗细，网络有带宽，即每秒钟能发送多少数据；水管有长度，端到端有时延。理想状态下，水管里面的水 = 水管粗细 * 水管长度。对于网络上，通道的容量 = 带宽 * 往返时延。 如果我们设置发送窗口，使得发送但未确认的包为通道的容量，就能撑满整个管道。如图所示，假设往返时间为 8 秒，去 4 秒，回 4 秒，每秒发送一个包，已经过去了 8 秒，则 8 个包都发出去了，其中前四个已经到达接收端，但是 ACK 还没返回，不能算发送成功，5-8 后四个包还在路上，还没被接收，这个时候，管道正好撑满，在发送端，已发送未确认的 8 个包，正好等于带宽，也即每秒发送一个包，也即每秒发送一个包，乘以来回时间 8 秒。 如果在这个基础上调大窗口，使得单位时间可以发送更多的包，那么会出现接收端处理不过来，多出来的包会被丢弃，这个时候，我们可以增加一个缓存，但是缓存里面的包 4 秒内肯定达不到接收端课，它的缺点会增加时延，如果时延达到一定程度就会超时重传 TCP 拥塞控制主要来避免两种现象，包丢失和超时重传，一旦出现了这些现象说明发送的太快了，要慢一点。 具体的方法就是发送端慢启动，比如倒水，刚开始倒的很慢，渐渐变快。然后设置一个阈值，当超过这个值的时候就要慢下来 慢下来还是在增长，这时候就可能水满则溢，出现拥塞，需要降低倒水的速度，等水慢慢渗下去。 拥塞的一种表现是丢包，需要超时重传，这个时候，采用快速重传算法，将当前速度变为一半。所以速度还是在比较高的值，也没有一夜回到解放前。 为什么连接的时候是三次握手，关闭的时候却是四次握手答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。 为什么不直接关闭而是进入TIME_WAIT客户端要确认服务器能收到ACK信号。(如果不确认这一点，服务器会认为客户端没有收到自己的FIN+ACK报文，所以会重发)防止失效请求。(为了防止已失效的连接的请求数据包和正常的混淆) 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。 为什么不能用两次握手进行连接3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。 如果已经建立了连接，但是客户端突然出现故障了怎么办TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 TCP和UDP区别 TCP面向连接，UDP面向非连接 TCP提供可靠的服务（数据传输无差错、不丢失、不重复、按序到达），UDP不可靠 TCP面向字节流，UDP面向报文 TCP数据传输慢，UDP数据传输快 TCP首部开销20字节，UDP8字节 TCP 为什么是可靠连接 通过 TCP 连接传输的数据无差错，不丢失，不重复，且按顺序到达。 TCP 报文头里面的序号能使 TCP 的数据按序到达 报文头里面的确认序号能保证不丢包，累计确认及超时重传机制 TCP 拥有流量控制及拥塞控制的机制TCP 的顺序问题，丢包问题，流量控制都是通过滑动窗口来解决的拥塞控制时通过拥塞窗口来解决的 http 响应码 301 和 302 代表的是什么？有什么区别？ 301：永久重定向。 302：暂时重定向。它们的区别是，301 对搜索引擎优化（SEO）更加有利；302 有被提示为网络拦截的风险 forward 和 redirect 的区别forward 是转发 和 redirect 是重定向： 地址栏 url 显示：foward url 不会发生改变，redirect url 会发生改变； 数据共享：forward 可以共享 request 里的数据，redirect 不能共享； 效率：forward 比 redirect 效率高。 说一下 tcp 粘包是怎么产生的tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因： 发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包； 接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收 get 和 post 请求有哪些区别 get 请求会被浏览器主动缓存，而 post 不会。 get 传递参数有大小限制，而 post 没有。 post 参数传输更安全，get 的参数会明文限制在 url 上，post 不会。 如何实现跨域实现跨域有以下几种方案： 服务器端运行跨域 设置 CORS 等于 *； 在单个接口使用注解 @CrossOrigin 运行跨域； 使用 jsonp 跨域； 常用端口及其对应服务 常见服务 端口 HTTP 80 FTP 21 DNS 53 POP3 110 SMTP 25 SSH 22 nginx 80 MEMCACHED 11211 MYSQL 3306 TOMCAT 8080 NFS 2049 TLENET 23 HTTPS 443 SAMBA UDP139 TCP139 POSTFIX 25 IMAP 143 ZABBIX 10051 DHCP 56 ** 在浏览器中输入网址之后执行会发生什么 DNS解析，找到对应ip地址 客户端发起http/https请求,然后交给传输层 传输层将请求分成报文段，添加目标源和端口，并随机用一个本地接口封装进报头，然后交给网络层。 网络层加上双方的ip地址信息，并负责路由分发。 链路层中，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包进行传输了，然后发送IP数据包到达服务器的地址。 IP地址的分类A类地址：以0开头，第一个字节范围：0 ~ 127（1.0.0.0 - 126.255.255.255)；B类地址：以10开头，第一个字节范围：128 ~ 191（128.0.0.0 - 191.255.255.255);C类地址：以110开头，第一个字节范围：192 ~ 223（192.0.0.0 - 223.255.255.255);内部(私有)地址：10.0.0.0 — 10.255.255.255， 172.16.0.0 — 172.31.255.255， 192.168.0.0—192.168.255.255。 ARP是什么协议，简单语言解释一下工作原理 每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。 当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP地址。 当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。 源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。 广播发送ARP请求，单播发送ARP响应。 DHCP协议有什么作用一个局域网的网络协议，使用UDP协议工作用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。 子网掩码的作用子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。 通过IP和子网掩码计算网络号(笔试题)计算出IP二进制和子网掩码的二进制，然后取与 通过IP和子网掩码计算主机号(笔试题)将子网掩码的二进制取反，然后与IP的二进制取与。]]></content>
      <categories>
        <category>java知识点整理</category>
      </categories>
      <tags>
        <tag>java网络篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java知识点整理(不间断更新)]]></title>
    <url>%2F2019%2F08%2F06%2FJava%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[Java基础知识点简述什么是跨平台由于各种操作系统所支持的指令集不是完全一致的，所以在操作系统上加个虚拟机来提供统一接口，屏蔽系统之间的差异。 Java有几种基本数据类型有八种基本数据类型: 数据类型 字节 默认值 byte 1 0 char 4 ‘\u0000’ boolean 1 false float 4 0.0f double 8 0.0d int 4 0 short 2 0 long 8 0 面向对象特征面向对象的编程语言有封装、继承、多态、抽象四个主要特征。 封装：把描述一个对象的属性和行为封装在一个模块中，即一个类中，属性用变量定义，行为用方法定义，方法可以直接访问同一个对象中的属性。 抽象：把现实生活中的对象抽象为类。分为过程抽象和数据抽象 过程抽象：类的方法（鸟会啼鸣等） 数据抽象：类的属性（鸟有翅膀等） 继承：子类继承父类的特征和行为。子类可以有父类非私有的方法，也可以对父类进行扩展，也可以重写父类的方法。缺点就是提高了代码间的耦合性。 多态： 编译时多态：方法的重载 运行时多态：向上转型、方法重写–基于继承 面向对象六大原则 单一职责原则—-SRP 让每个类只专心处理自己的方法 开闭原则—-OCP 软件中的对象（类、模块、函数等）应该对于扩展开放，对于修改是关闭的 里氏替换原则—-LSP 子类可以去扩展父类，但是不能改变父类原有的功能 依赖倒置原则—-DIP 应该通过调用接口或抽象类，而不是调用实现类 接口隔离原则—-ISP 把接口分为满足依赖关系的最小接口，实现类中不能有不需要的方法 迪米特原则—-LOP 高内聚、低耦合 String属于基础的数据类型吗String不属于基础类型，基础类型有type、boolean、int、char、short、long、float、double，而String属于包装器类型 为什么要有包装类型为了让基本数据类型也具有对象的特征，就出现了包装类型（如在使用集合类型Collection时就一定要使用包装类型而不是基本数据类型）。因为容器都是装object的，这时就需要这些基本数据类型的包装类型了。 基本类型 包装器类型 boolean Boolean char Character int Integer byte Byte short Short long Long float Float double Double 自动装箱和自动拆箱自动装箱：new Integer(6)，底层调用：Integer.valueOf(6)；自动拆箱：int i = new Integer(6)，底层调用：i.intValue();二者的区别： 声明方式不同：基本数据类型不使用new关键字，而包装类型需要使用new关键字在堆中分配存储空间； 存储方式及位置不同：基本数据类型是直接将变量值存储在栈中，而包装类型是将对象放在堆中，然后通过引用来使用； 初始值不同：基本数据类型的初始值如int为0，boolean为false，而包装类型的初始值为null； 使用方式不同：基本数据类型赋值直接使用就好，而包装类型在集合如Collection、Map时会使用到。 String str = “i” 与 String str = new String(“i”)一样么不一样，因为内存的分配方式不一样。String str = "i"的方式，Java虚拟机会将其分配到常量池中；String str = new String("i")则会被分到堆内存中。 如何将字符串反转使用StringBuilder或者StringBuffer的reverse()方法 12345678// StringBuffer reverseStringBuffer stringBuffer = new StringBuffer();stringBuffer. append(&quot;abcdefg&quot;);System. out. println(stringBuffer. reverse()); // gfedcba// StringBuilder reverseStringBuilder stringBuilder = new StringBuilder();stringBuilder. append(&quot;abcdefg&quot;);System. out. println(stringBuilder. reverse()); // gfedcba String 类常用方法1234567891011indexOf()：返回指定字符的索引。charAt()：返回指定索引处的字符。replace()：字符串替换。trim()：去除字符串两端空白。split()：分割字符串，返回一个分割后的字符串数组。getBytes()：返回字符串的 byte 类型数组。length()：返回字符串长度。toLowerCase()：将字符串转成小写字母。toUpperCase()：将字符串转成大写字符。substring()：截取字符串。equals()：字符串比较。 == 和 equals 区别 == 比较的是两个引用在内存中指向的是不是同一对象（即同一内存空间），也就是说在内存中的存储位置是否一致。如果两个对象的引用相同时（指向同一对象时），== 操作符返回true,否则返回false。 对于基本类型和引用类型 == 的作用效果是不同的：基本类型：比较的是值是否相同；引用类型：比较的是引用是否相同；代码示例： 1234567String x = &quot;string&quot;;String y = &quot;string&quot;;String z = new String(&quot;string&quot;);System.out.println(x==y); // trueSystem.out.println(x==z); // falseSystem.out.println(x.equals(y)); // trueSystem.out.println(x.equals(z)); // true 代码解读：因为 x 和 y 指向的是同一个引用，所以 == 是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true equals 用来比较某些特征是否一样，本质上就是 == ，只不过String和Integer等重写了equals方法，把它变成了值比较。首先看默认情况下equals比较一个有相同值的对象，代码如下： 12345678910111213141516171819class Cat &#123; public Cat(String name) &#123; this.name = name; &#125; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; Cat c1 = new Cat(&quot;王磊&quot;);Cat c2 = new Cat(&quot;王磊&quot;);System.out.println(c1.equals(c2)); // false 输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下： 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 原来 equals 本质上就是 ==。那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下： 123String s1 = new String(&quot;老王&quot;);String s2 = new String(&quot;老王&quot;);System.out.println(s1.equals(s2)); // true 同样的，当我们进入 String 的 equals方法，找到了答案，代码如下： 123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; &#125; 原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。总结： == 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重写了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。 String、StringBuffer和StringBuilder区别 数据可变和不可变 String底层使用一个不可变的字符数组private final char value[]，所以它的内容不可变 StringBuffer和StringBuilder都继承了AbstractStringBuilder底层使用的是可变字符数组：char[] value; 线程安全性 StringBulider是线程不安全的，效率较高；而StringBuffer是线程安全的，效率较低；通过他们的append()方法来看，SpringBuffer是有同步锁，而StringBuilder没有：1234567891011 @Overridepublic synchronized StringBuffer append(Object obj) &#123; toStringCache = null; super.append(String.valueOf(obj)); return this;&#125;@Overridepublic StringBuilder append(String str) &#123; super.append(str); return this;&#125; 相同点StringBuilder与StringBuffer有公共父类AbstractBuilder；最后，操作可变字符串速度：StringBuilder &gt; StringBuffer &gt; String。 两个对象的 hashCode()相同，则equals()也一定为true，对吗？不对，两个对象的HashCode()相同，equals()不一定true。代码示例： 1234String str1 = &quot;通话&quot;;String str2 = &quot;重地&quot;;System. out. println(String. format(&quot;str1：%d | str2：%d&quot;, str1. hashCode(),str2. hashCode()));System. out. println(str1. equals(str2)); 执行结果： 123str1：1179395 | str2：1179395 false 代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。 两个对象值相同(x.equals(y)==true)，Hashcode是否一定相同第一种情况：假如这个类没有重写equals方法，如果两个对象值相同，那么他们的hashCode值一定相同；第二种情况：如果重写了equals方法，但没有重写hashCode方法，就会出现不相等的情况。Java对于equals方法和hashCode方法的规定 如果两个对象相同，那么他们的hashCode值一定要相同； 如果两个对象的hashCode相同，他们并不一定相同（这里说的对象相同指的是用equals方法比较）； equals()相等的两个对象，hashCode()一定相等；equals()不相等的两个对象，却并不能证明他们的hashCode()不相等。换句话说，equals()方法不相等的两个对象，hashCode()有可能相等（我的理解是由于哈希码在生成的时候产生冲突造成的）。反过来，hashCode()不等，一定能推出equals()也不等；hashCode()相等，equals()可能相等，也可能不等。 什么时候需要重写equals方法和hashCode方法如果想完整的使用HashSet类(或TreeSet等)，最少需要重写equals()和hashCode()方法 重写hashCode()用于获得元素的存储位置； 重写equals()用于在两个元素的位置相同的时候，比较两个元素是否相等。分析原因如下：1234567hashCode public int hashCode()返回该对象的哈希码值。支持此方法是为了提高哈希表（例如 Java.util.Hashtable 提供的哈希表）的性能。 hashCode 的常规协定是： 在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。 如果根据 equals(Object) 方法，两个对象是相等的，那么对这两个对象中的每个对象调用 hashCode 方法都必须生成相同的整数结果。 如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么对这两个对象中的任一对象上调用 hashCode 方法不 要求一定生成不同的整数结果。但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能。 实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。） 12345678910equals public boolean equals(Object obj)指示其他某个对象是否与此对象“相等”。 equals 方法在非空对象引用上实现相等关系： 自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true。 对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。 传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。 一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。 对于任何非空引用值 x，x.equals(null) 都应返回 false。 Object 类的 equals 方法实现对象上差别可能性最大的相等关系；即，对于任何非空引用值 x 和 y，当且仅当 x 和 y 引用同一个对象时，此方法才返回 true（x == y 具有值 true）。 final在Java中有什么作用 修饰类，则该类不能被继承； 修饰方法，则该方法不能被重写； 修饰变量，修饰的变量叫常量，必须初始化，且初始化后值不能被修改。 static和final区别 关键词 修饰对象 影响 final 变量 分配到常量池中，程序不可改变其值 方法 子类中将不能被重写 类 不能被继承 static 变量 分配在内存堆上，引用都会指向这一地址而不会重新分配内存 方法块 虚拟机优先加载 类 可以直接通过类来调用而不需要new 引用类型占用几个字节hotspot VM在64位平台上占8个字节，在32平台上占4个字节 (1&lt;3)?&quot;a&quot;:&quot;b&quot;)+3+4和(1&lt;3)?&quot;a&quot;:&quot;b&quot;)+(3+4)区别12System.out.println(((1&lt;3)?&quot;a&quot;:&quot;b&quot;)+3+4);System.out.println(((1&lt;3)?&quot;a&quot;:&quot;b&quot;)+(3+4)); 输出 12a34a7 4&amp;5 4^5 4&amp;10&gt;&gt;1各等于多少1234567// 0100 &amp; 0101 = 0100 = 4System.out.println(4&amp;5);// 0100 ^ 0101 = 0001 = 1System.out.println(4^5);System.out.println(10&gt;&gt;1); // 有疑问参考下面的运算符优先级System.out.println(4&amp;10&gt;&gt;1); 输出 12344154 同问 4|5等于多少呢答案为5Tip：与运算符用符号“&amp;”表示，其使用规律如下：两个操作数中位都为1，结果才为1，否则结果为0或运算符用符号“|”表示，其运算规律如下：两个位只要有一个为1，那么结果就是1，否则就为03&amp;4相当于0011&amp;0100，结果是0000，也就是04|5相当于0100|0101，结果是0101，也就是5java的位运算符还有两个：非运算符用符号“~”表示，其运算规律如下：如果位为0，结果是1，如果位为1，结果是0异或运算符是用符号“^”表示的，其运算规律是：两个操作数的位中，相同则结果为0，不同则结果为1 运算符优先级 运算符 结合性 [ ] . ( ) (方法调用) 从左向右 ! ~ ++ – +(一元运算) -(一元运算) 从右向左 * / % 从左向右 + - 从左向右 &lt;&lt; &gt;&gt; &gt;&gt;&gt; 从左向右 &lt; &lt;= &gt; &gt;= instanceof 从左向右 == != 从左向右 &amp; 从左向右 ^ 从左向右 | 从左向右 &amp;&amp; 从左向右 || 从左向右 ?: 从右向左 = 从右向左 Java中 Math.round(-1.5)等于多少？Math.round(-2.5)等于多少？答案：-1，-2注意：不要认为它是四舍五入计算口诀：+0.5后向下取整即可同理Math.round(-2.6)结果和Math.round(2.6)结果分别为-3，3 抽象类必须要有抽象方法吗？不需要，抽象类不一定非要抽象方法 12345abstract class Cat &#123; public static void sayHi() &#123; System. out. println(&quot;hi~&quot;); &#125; &#125; 普通类和抽象类有哪些区别普通类不能包含抽象方法，抽象类可以包含抽象方法抽象类不能直接实例化，普通类可以直接实例化 抽象类能使用final修饰吗不能，定义抽象类就是让其他类继承的，如果定义为final该类就不能被继承，这样彼此就会产生矛盾，所以final不能修饰抽象类。 接口和抽象类的区别 实现：抽象类的子类使用extends来继承；接口必须使用implements来实现接口； 构造函数：抽象类有构造函数；接口不能有； 实现数量：类可以实现多个接口，但是只能继承一个抽象类； 访问修饰符：抽象类中的抽象方法(其前有abstract修饰)不能用private、static、synchronized、native访问修饰符修饰；接口中的方法默认使用 public 修饰，接口是一种特殊的抽象类，接口中的方法全部是抽象方法（但其前的abstract可以省略），所以抽象类中的抽象方法不能用的访问修饰符这里也不能用，而且protected访问修饰符也不能使用。 Java中IO流分为几种 按功能分：输入流（input）、输出流（output） 按类型分：字节流和字符流 字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。 BIO、NIO和AIO区别 BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。 NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。 AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。 Files常用方法有哪些123456789Files. exists()：检测文件路径是否存在。Files. createFile()：创建文件。Files. createDirectory()：创建文件夹。Files. delete()：删除一个文件或目录。Files. copy()：复制文件。Files. move()：移动文件。Files. size()：查看文件个数。Files. read()：读取文件。Files. write()：写入文件。 容器Java容器都有哪些Java容器分为Collection和Map两大类，其下又有很多子类，如下所示： Collection List ArrayList LinkedList Vector Stack Set HashSet LinkedHashSet TreeSet Map HashMap LinkedHashMap TreeMap ConcurrentHashMap Hashtable 简述Java中的集合 Collection下：List系（有序、元素允许重复）和Set系（无序、元素不重复） set根据equals和hashCode判断，一个对象要存储在Set中，必须重写equals和hashCode方法。 Map下：HashMap线程不同步；TreeMap线程同步； Collection系列和Map系列：Map是对Colleciton的补充，两者没什么关系。 List、Set、Map之间的区别List、Set、Map之间的区别主要体现在两个方面：元素是否有序、是否允许元素重复三者间的区别，如表所示： 元素有序 允许元素重复 List 是 是 Set AbstractSet 否 否 HashSet TreeSet 是（用二叉树排序） Map AbstractMap 否 key值必须唯一value值可重复 HashMap TreeMap 是（用二叉树排序） HashMap、HashTable和ConcurrentHashMap区别相同点： 1. HashMap和HashTable都实现了Map接口 2. 都可以存储key-value数据不同点： 1. HashMap可以把null作为key或者value,HashTable不可以 2. HashMap线程不安全，效率高，HashTable线程安全，效率低 3. HashMap迭代器(Iterator)是fail-fast迭代器，而HashTable的enumerator迭代器不是fail-fast的 什么是fail-fast? 就是最快的时间能把错误抛出而不是让程序执行 4. Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。 如何保证线程安全又效率高Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。ConcurrentHashMap将整个Map分为N个segment(类似HashTable)，可以提供相同的线程安全，但是效率提升N倍，默认N为16。 我们能否让HashMap同步HashMap可以通过下面语句进行同步 1Map m = Collections.synchronizeMap(hashMap); 如何决定使用HashMap还是TreeMap对于在 Map 中插入、删除、定位一个元素这类操作，HashMap是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。 说一下 HashMap 的实现原理HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。 说一下 HashSet 的实现原理HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。 ArrayList 和 LinkdList 区别 ArrayList的实现基于动态数组的数据结构，LinkedList基于链表的数据结构； 对于随机访问get和set，ArrayList优于LinkedList，因为LinkedList需要移动指针； 对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。 如何实现数组和 List 之间的转换数组转 List：使用 Arrays. asList(array) 进行转换；List 转数组：使用 List 自带的 toArray() 方法 12345678// list to arrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();list. add(&quot;王磊&quot;);list. add(&quot;的博客&quot;);list. toArray();// array to listString[] array = new String[]&#123;&quot;王磊&quot;,&quot;的博客&quot;&#125;;Arrays. asList(array); ArrayList 和 Vector 的区别线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的性能：ArrayList 在性能方面要优于 Vector扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50% Array 和 ArrayList 有何区别Array 可以存储基本数据类型和对象，ArrayList 只能存储对象;Array 是指定固定大小的，而 ArrayList 大小是自动扩展的;Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。 在 Queue 中 poll()和 remove()有什么区别相同点：都是返回第一个元素，并在队列中删除返回的对象不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常tip: queue的增加元素方法add和offer的区别在于，add方法在队列满的情况下将选择抛异常的方法来表示队列已经满了，而offer方法通过返回false表示队列已经满了；在有限队列的情况，使用offer方法优于add方法； remove方法和poll方法都是删除队列的头元素，remove方法在队列为空的情况下将抛异常，而poll方法将返回null； element和peek方法都是返回队列的头元素，但是不删除头元素，区别在与element方法在队列为空的情况下，将抛异常，而peek方法将返回null.12345Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();queue. offer(&quot;string&quot;); // addSystem. out. println(queue. poll());System. out. println(queue. remove());System. out. println(queue. size()); 哪些集合类是线程安全的Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK 1.5 之后随着 Java. util. concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。 迭代器 Iterator 是什么Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。 Iterator 怎么使用？有什么特点？123456List&lt;String&gt; list = new ArrayList&lt;&gt;();Iterator&lt;String&gt; it = list. iterator();while(it. hasNext())&#123; String obj = it. next(); System. out. println(obj);&#125; Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。 ConcurrentModificationException异常出现的原因123456789101112public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(2); Iterator&lt;Integer&gt; iterator = list.iterator(); while(iterator.hasNext())&#123; Integer integer = iterator.next(); if(integer==2) list.remove(integer); &#125; &#125;&#125; 执行上段代码是有问题的，会抛出ConcurrentModificationException异常。原因：调用list.remove()方法导致modCount和expectedModCount的值不一致。 1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException();&#125; 解决办法：在迭代器中如果要删除元素的话，需要调用Iterator类的remove方法。 123456789101112public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(2); Iterator&lt;Integer&gt; iterator = list.iterator(); while(iterator.hasNext())&#123; Integer integer = iterator.next(); if(integer==2) iterator.remove(); //注意这个地方 &#125; &#125;&#125; 怎么确保一个集合不能被修改可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。 12345List&lt;String&gt; list = new ArrayList&lt;&gt;();list. add(&quot;x&quot;);Collection&lt;String&gt; clist = Collections. unmodifiableCollection(list);clist. add(&quot;y&quot;); // 运行时此行报错System. out. println(list. size()); 多线程并行和并发有什么区别 并行：多个处理器或多核处理器同时处理多个任务。 并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。 线程和进程的区别一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。 守护线程是什么守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。 创建线程的方式常见回答 继承 Thread 重写 run 方法； 实现 Runnable 接口； 实现 Callable 接口。 下面做个较为全面的总结： 继承Trhead类，作为线程对象存在（继承Thread对象）12345678910111213141516171819202122232425262728293031public class CreatThreadDemo1 extends Thread&#123; /** * 构造方法： 继承父类方法的Thread(String name)；方法 * @param name */ public CreatThreadDemo1(String name)&#123; super(name); &#125; @Override public void run() &#123; while (!interrupted())&#123; System.out.println(getName()+&quot;线程执行了...&quot;); try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; CreatThreadDemo1 d1 = new CreatThreadDemo1(&quot;first&quot;); CreatThreadDemo1 d2 = new CreatThreadDemo1(&quot;second&quot;); d1.start(); d2.start(); d1.interrupt(); //中断第一个线程 &#125;&#125; 常规方法，不多做介绍了，interrupted方法，是来判断该线程是否被中断。（终止线程不允许用stop方法，该方法不会施放占用的资源。所以我们在设计程序的时候，要按照中断线程的思维去设计，就像上面的代码一样）。 * 让线程等待的方法 Thread.sleep(200);//线程休息2ms Object.wait();//让线程进入等待，直到调用Object的notify或者notifyAll，线程停止休眠 实现runnable接口，作为线程任务存在123456789101112131415public class CreatThreadDemo2 implements Runnable &#123; @Override public void run() &#123; while (true)&#123; System.out.println(&quot;线程执行了...&quot;); &#125; &#125; public static void main(String[] args) &#123; //将线程任务传给线程对象 Thread thread = new Thread(new CreatThreadDemo2()); //启动线程 thread.start(); &#125;&#125; Runnable 只是来修饰线程所执行的任务，它不是一个线程对象。想要启动Runnable对象，必须将它放到一个线程对象里。 匿名内部类创建线程对象123456789101112131415161718192021222324252627282930public class CreatThreadDemo3 extends Thread&#123; public static void main(String[] args) &#123; //创建无参线程对象 new Thread()&#123; @Override public void run() &#123; System.out.println(&quot;线程执行了...&quot;); &#125; &#125;.start(); //创建带线程任务的线程对象 new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;线程执行了...&quot;); &#125; &#125;).start(); //创建带线程任务并且重写run方法的线程对象 new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;runnable run 线程执行了...&quot;); &#125; &#125;)&#123; @Override public void run() &#123; System.out.println(&quot;override run 线程执行了...&quot;); &#125; &#125;.start(); &#125;&#125; 创建带线程任务并且重写run方法的线程对象中，为什么只运行了Thread的run方法。通过查看Thread类的源码，我们可以看到Thread实现了Runnable接口，而Runnable接口里有一个run方法。所以，我们最终调用的重写的方法应该是Thread类的run方法。而不是Runnable接口的run方法。 创建带返回值的线程（实现Callable接口）12345678910111213141516171819202122232425public class CreatThreadDemo4 implements Callable &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; CreatThreadDemo4 demo4 = new CreatThreadDemo4(); FutureTask&lt;Integer&gt; task = new FutureTask&lt;Integer&gt;(demo4); //FutureTask最终实现的是runnable接口 Thread thread = new Thread(task); thread.start(); System.out.println(&quot;我可以在这里做点别的业务逻辑...因为FutureTask是提前完成任务&quot;); //拿出线程执行的返回值 Integer result = task.get(); System.out.println(&quot;线程中运算的结果为:&quot;+result); &#125; //重写Callable接口的call方法 @Override public Object call() throws Exception &#123; int result = 1; System.out.println(&quot;业务逻辑计算中...&quot;); Thread.sleep(3000); return result; &#125;&#125; Callable接口介绍： 123456789public interface Callable&lt;V&gt; &#123; /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;&#125; 返回指定泛型的call方法。然后调用FutureTask对象的get方法得到call方法的返回值。 定时器Timer 1234567891011121314public class CreatThreadDemo5 &#123; public static void main(String[] args) &#123; Timer timer = new Timer(); timer.schedule(new TimerTask() &#123; @Override public void run() &#123; System.out.println(&quot;定时器线程执行了...&quot;); &#125; &#125;,0,1000); //延迟0，周期1s &#125;&#125; 线程池创建线程 1234567891011121314151617181920public class CreatThreadDemo6 &#123; public static void main(String[] args) &#123; //创建一个具有10个线程的线程池 ExecutorService threadPool = Executors.newFixedThreadPool(10); long threadpoolUseTime = System.currentTimeMillis(); for (int i = 0;i&lt;10;i++)&#123; threadPool.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+&quot;线程执行了...&quot;); &#125; &#125;); &#125; long threadpoolUseTime1 = System.currentTimeMillis(); System.out.println(&quot;多线程用时&quot;+(threadpoolUseTime1-threadpoolUseTime)); //销毁线程池 threadPool.shutdown(); threadpoolUseTime = System.currentTimeMillis(); &#125;&#125; 利用java8新特性stream实现并发 12345678910public class CreatThreadDemo7 &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; values = Arrays.asList(10,20,30,40); //parallel 平行的，并行的 int result = values.parallelStream().mapToInt(p -&gt; p*2).sum(); System.out.println(result); //怎么证明它是并发处理呢 values.parallelStream().forEach(p-&gt; System.out.println(p)); &#125;&#125; 输出 1234520040102030 说一下runnable和callable区别runnable 没有返回值，callable 可以拿到有返回值，callable 可以看作是 runnable 的补充。 线程有哪些状态线程的状态： NEW 尚未启动 RUNNABLE 正在执行中 BLOCKED 阻塞的（被同步锁或者IO锁阻塞） WAITING 永久等待状态 TIMED_WAITING 等待指定的时间重新被唤醒的状态 TERMINATED 执行完成 sleep() 和 wait() 有什么区别 类的不同：sleep() 来自 Thread，wait() 来自 Object。 释放锁：sleep() 不释放锁；wait() 释放锁。 用法不同：sleep() 时间到会自动恢复；wait() 可以使用notify()/notifyAll()直接唤醒。 notify()和 notifyAll()有什么区别notifyAll()会唤醒所有的线程，notify()只唤醒一个线程。notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。 线程的 run() 和 start() 有什么区别start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。 创建线程池有哪几种方式？线程池创建有七种方式，最核心的是最后一种： newSingleThreadExecutor()：它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目； newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列； newFixedThreadPool(int nThreads)：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads； newSingleThreadScheduledExecutor()：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度； newScheduledThreadPool(int corePoolSize)：和newSingleThreadScheduledExecutor()类似，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程； newWorkStealingPool(int parallelism)：这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序； ThreadPoolExecutor()：是最原始的线程池创建，上面1-3创建方式都是对ThreadPoolExecutor的封装。 常用为Executors提供的四种方法来创建线程池： newFixedThreadPool() :创建固定大小的线程池。 newCachedThreadPool(): 创建无限大小的线程池，线程池中线程数量不固定，可根据需求自动更改。 newSingleThreadPool() : 创建单个线程池，线程池中只有一个线程。 newScheduledThreadPool(): 创建固定大小的线程池，可以延迟或定时的执行任务。示例： 12345678public static void main(String[] args) &#123; ExecutorService threadPool = Executors.newCachedThreadPool(); threadPool.execute(() -&gt; &#123; for (int i = 0; i&lt; 20;i++) &#123; System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i); &#125; &#125;); threadPool.shutdown(); 线程池作用 限制线程个数，避免线程过多导致系统运行缓慢或崩溃。 不需要频繁的创建和销毁，节约资源、响应更快。 线程池都有哪些状态？ RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。 SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。 STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。 TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。 TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。 线程池中 submit() 和 execute() 方法有什么区别？ execute()：只能执行 Runnable 类型的任务。 submit()：可以执行 Runnable 和 Callable 类型的任务。 Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。 在 Java 程序中怎么保证多线程的运行安全 方法一：使用安全类，比如 Java. util. concurrent 下的类。 方法二：使用自动锁 synchronized。 方法三：使用手动锁 Lock。 手动锁 Java 示例代码如下： 12345678910Lock lock = new ReentrantLock();lock. lock();try &#123; System. out. println(&quot;获得锁&quot;);&#125; catch (Exception e) &#123; // TODO: handle exception&#125; finally &#123; System. out. println(&quot;释放锁&quot;); lock. unlock();&#125; 多线程中 synchronized 锁升级的原理是什么synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。 锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。 什么是死锁？当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。 怎么防止死锁？ 尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。 尽量使用 Java. util. concurrent 并发类代替自己手写锁。 尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。 尽量减少同步的代码块 ThreadLocal 是什么？有哪些使用场景？ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。ThreadLocal 的经典使用场景是数据库连接和 session 管理等。 说一下 synchronized 底层实现原理？synchronized 是由一对 monitorenter/monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在 Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能 synchronized 和 volatile 的区别是什么？ volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。 volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。 volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。 synchronized 和 Lock 有什么区别？ synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。 synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。 synchronized 和 ReentrantLock 区别是什么？synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进 主要区别如下： ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作； ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁； ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。 volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。 说一下 atomic 的原理？atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。 反射什么是反射反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。 什么是 Java 序列化？什么情况下需要序列化？Java 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。以下情况需要使用 Java 序列化： 想把的内存中的对象状态保存到一个文件中或者数据库中时候； 想用套接字在网络上传送对象的时候； 想通过RMI（远程方法调用）传输对象的时候。 某些java类为什么要实现Serializable接口为了网络进行传输或者持久化 除了实现Serializable接口还有什么序列化方式 Json序列化 FastJson序列化 ProtoBuff序列化 动态代理是什么？有哪些应用？动态代理是运行时动态生成代理类。动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端 mock、rpc，Java注解对象获取等。 怎么实现动态代理？JDK 原生动态代理和 cglib 动态代理。JDK 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的。 对象拷贝为什么要使用克隆克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠克隆方法了。 如何实现对象克隆 实现 Cloneable 接口并重写 Object 类中的 clone() 方法。 实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。 深拷贝和浅拷贝区别是什么 浅克隆：当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。 深克隆：除了对象本身被复制外，对象所包含的所有成员变量也将复制 异常throw 和 throws 的区别 throw：是真实抛出一个异常。 throws：是声明可能会抛出一个异常。 final、finally、finalize 有什么区别？ final：是修饰符，如果修饰类，此类不能被继承；如果修饰方法和变量，则表示此方法和此变量不能再被改变，只能使用。 finally：是 try{} catch{} finally{} 最后一部分，表示不论发生任何情况都会执行，finally 部分可以省略，但如果 finally 部分存在，则一定会执行 finally 里面的代码。 finalize： 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法。 try-catch-finally 中哪个部分可以省略try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。 try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。 常见的异常类有哪些？ NullPointerException 空指针异常 ClassNotFoundException 指定类不存在 NumberFormatException 字符串转换为数字异常 IndexOutOfBoundsException 数组下标越界异常 ClassCastException 数据类型转换异常 FileNotFoundException 文件未找到异常 NoSuchMethodException 方法不存在异常 IOException IO 异常 SocketException Socket 异常 设计模式说一下你熟悉的设计模式 单例模式：保证被创建一次，节省系统开销。 工厂模式（简单工厂、抽象工厂）：解耦代码。 观察者模式：定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新。 外观模式：提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。 模版方法模式：定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。 状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。 简单工厂、工程方法和抽象工厂有什么区别？ 简单工厂：用来生产同一等级结构中的任意产品，对于增加新的产品，无能为力。 工厂方法：用来生产同一等级结构中的固定产品，支持增加任意产品。 抽象工厂：用来生产不同产品族的全部产品，对于增加新的产品，无能为力；支持增加产品族。 JVM(东西多，有些后续整理)说一下 JVM 的主要组成部分？及其作用？ 类加载器（ClassLoader） 运行时数据区（Runtime Data Area） 执行引擎（Execution Engine） 本地库接口（Native Interface） 组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。 说一下 JVM 运行时数据区？不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分： 程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成； Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息； 本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的； Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存； 方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。 说一下堆栈的区别？ 功能方面：堆是用来存放对象的，栈是用来执行程序的。 共享性：堆是线程共享的，栈是线程私有的。 空间大小：堆大小远远大于栈。 队列和栈是什么？有什么区别？队列和栈都是被用来预存储数据的。 队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。 栈和队列很相似，但它运行对元素进行后进先出进行检索。 说一下类装载的执行过程？类装载分为以下 5 个步骤： 加载：根据查找路径找到相应的 class 文件然后导入； 检查：检查加载的 class 文件的正确性； 准备：给类中的静态变量分配内存空间； 解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址； 初始化：对静态变量和静态代码块执行初始化工作。 怎么判断对象是否可以被回收？一般有两种方法来判断： 引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题； 可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。 Java 中都有哪些引用类型？ 强引用：发生 gc 的时候不会被回收。 软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。 弱引用：有用但不是必须的对象，在下一次GC时会被回收。 虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。 JVM垃圾处理方法 标记-清除算法（老年代）该算法分为“标记”和“清除”两个阶段: 首先标记出所有需要回收的对象(可达性分析), 在标记完成后统一清理掉所有被标记的对象。该算法会有两个问题： 效率问题，标记和清除效率不高。 空间问题: 标记清除后会产生大量不连续的内存碎片, 空间碎片太多可能会导致在运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集。所以它一般用于”垃圾不太多的区域，比如老年代”。 复制算法（新生代）该算法的核心是将可用内存按容量划分为大小相等的两块, 每次只用其中一块, 当这一块的内存用完, 就将还存活的对象（非垃圾）复制到另外一块上面, 然后把已使用过的内存空间一次清理掉。优点：不用考虑碎片问题，方法简单高效。缺点：内存浪费严重。 标记-整理算法（老年代）标记清除算法会产生内存碎片问题, 而复制算法需要有额外的内存担保空间, 于是针对老年代的特点, 又有了标记整理算法. 标记整理算法的标记过程与标记清除算法相同, 但后续步骤不再对可回收对象直接清理, 而是让所有存活的对象都向一端移动,然后清理掉端边界以外的内存。简记： 标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。 标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。 复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。 分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。 说一下 JVM 有哪些垃圾回收器？ Serial：最早的单线程串行垃圾回收器。 Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。 ParNew：是 Serial 的多线程版本。 Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。 Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。 CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。 G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。 详细介绍一下 CMS 垃圾回收器？CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。 CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？ 新生代回收器：Serial、ParNew、Parallel Scavenge 老年代回收器：Serial Old、Parallel Old、CMS 整堆回收器：G1新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。 未完待续…]]></content>
      <categories>
        <category>java知识点整理</category>
      </categories>
      <tags>
        <tag>java知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown入门教程]]></title>
    <url>%2F2019%2F08%2F01%2FMarkdown%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[&lt; !–more–&gt; 斜体和粗体代码： 1234*斜体*或_斜体_ **粗体*****加粗斜体***~~删除线~~ 显示效果：这是一段斜体这是一段粗体这是一段加粗斜体这是一段删除线 分级标题第一种写法： 1234这是一个一级标题==================这是一个二级标题------------------ 就是在文字的下一行增加不同的横线，不建议使用。第二种写法： 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 推荐使用这种方式，简单易记，不同级别的标题后面#不一样多，在#后需要空一格。 超链接Markdown 支持两种形式的链接语法：行内式和参考式两种形式，行内式一般用的较多。 行内式语法说明：[]里写链接文字，()里写链接地址，()中的" "可以为链接指定title属性，title属性可加可不加。title属性效果是鼠标悬停在链接上会出现指定的title文字。链接文字这样的形式。注：链接地址与链接标题间有一个空格。代码： 12欢迎访问[我的博客](https://kepler-ecnu.github.io/)欢迎访问[我的博客](https://kepler-ecnu.github.io/ &quot;kepler&apos;s blog&quot;) 显示效果：欢迎访问我的博客欢迎访问我的博客 这个设置了标题，在鼠标指在超链接上时显示标题。 参考式参考式超链接一般用在学术论文上，或者若某一个链接在文章中多出使用，则使用引用的方式创建链接，这样可以对链接进行同意的管理。语法说明：参考式链接分为两部分，文中的写法[链接文字][链接标记]，在文本的任意位置添加[链接文字]:链接地址 “链接标记”，链接地址与链接标记间一个空格。如果链接文字本身可以作为链接标记，也可以写成[链接文字][][链接文字]：链接地址的形式，见代码的最后一行。代码： 12345我经常访问的网站[baidu][1]、[bilibili][2]等[B站][2]有我整理的[音乐合集][]。[1]:https://www.baidu.com/ &quot;baidu&quot;[2]:https://space.bilibili.com/12737596 &quot;bilibili&quot;[音乐合集]:https://space.bilibili.com/12737596 自动链接语法说明Markdown支持较简短的自动链接形式来处理网址和电子邮箱，只要是用包起来，Markdown就会自动把它转成链接。一般网址的链接文字和链接地址一样，如：代码： 12&lt;https://space.bilibili.com/12737596&gt;&lt;address@example.com&gt; 显示效果：https://space.bilibili.com/12737596&#97;&#x64;&#x64;&#114;&#x65;&#x73;&#115;&#x40;&#x65;&#120;&#x61;&#x6d;&#112;&#x6c;&#101;&#46;&#x63;&#x6f;&#109; 锚点网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。语法描述：在你准备跳转到的指定标题后插入锚点,然后在文档的其它地方写上链接到锚点的链接。（这里不展开） 列表无序列表使用*，+，-表示无序列表代码： 123* 无序列表项一+ 无序列表项二- 无序列表项三 显示效果： 无序列表项一 无序列表项二 无序列表项三 有序列表有序列表则使用数字接着一个英文句点，接着空一个格写列表项。代码： 1231. 有序列表项一2. 有序列表项二3. 有序列表项三 显示效果： 有序列表项一 有序列表项二 有序列表项三 定义型列表语法说明：定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法:紧跟一个缩进（Tab） 列表缩进语法说明列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3个空格，项目标记后面则一定要接着至少一个空格或制表符。要让列表看起来更漂亮，你可以把内容用固定的缩进整理好（显示效果与代码一致）：轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。但是如果你懒，那也行：代码： 1234567* 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！* 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 显示效果： 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。包含段落的列表列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符（显示效果与代码一致）：轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。但是如果你懒，那也行：代码：1234567* 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！* 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 显示效果： 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 包含引用的列表语法说明：如果要在列表项目内放进引用，那 &gt; 就需要缩进：代码： 1234* 阅读的方法： &gt; 拿出书本 &gt; 放下手机 &gt; 开始看吧 显示效果： 阅读的方法： 拿出书本放下手机开始看吧 包含代码区块的引用语法说明：如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：一列表项包含一个列表区块： 写代码块的地方 引用语法说明：引用需要在被引用的文本前加上 &gt; 符号。代码： 123456&gt; 这是一个有两段文字的引用&gt; text1&gt; text2&gt;&gt; text3&gt; text4 显示效果： 这是一个有两段文字的引用text1text2 text3text4 引用的多层嵌套区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ：代码： 123456&gt; 这是一个有两段文字的引用&gt;&gt; text1&gt;&gt;&gt; text2&gt;&gt; text3&gt; text4 显示效果： 这是一个有两段文字的引用 text1 text2 text3text4 引用的其它要素引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：代码： 1234567&gt; 1. 第一列表项&gt; 2. 第二列表项&gt;&gt; text1&gt;&gt;&gt; text2&gt;&gt; return shell_exec(&quot;echo $input | $markdown_script&quot;);&gt; `return shell_exec(&quot;echo $input | $markdown_script&quot;);` 显示效果： 第一列表项 第二列表项 text1 text2 return shell_exec(&quot;echo $input | $markdown_script&quot;);return shell_exec(&quot;echo $input | $markdown_script&quot;); 插入图片图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。语法中图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。 行内式语法说明：![图片Alt](图片地址 "图片Title")代码： 1![图片示例](http://img.redocn.com/sheji/20141219/zhongguofengdaodeliyizhanbanzhijing_3744115.jpg &quot;图片示例&quot;) 显示效果： 参考式语法说明：（这里不作介绍）在文档要插入图片的地方写![图片Alt][标记]在文档的最后写上写[标记]:图片地址 “Title” 内容目录在段落中填写 [TOC] 以显示全文内容的目录结构。Hexo博客对目录的解析似乎也有限，请在Markdown编辑器中自行尝试。Next主题的话是也可以自动生成目录的，所以不需要额外增加目录。 注脚语法说明：在需要添加注脚的文字后加上脚注名字[^脚注名字]，称为加注。然后在文本的任意位置（一般在最后）添加脚注，脚注前必须有对应的脚注名字。注意：经测试注脚和脚注之间必须空一行，不然会失效。成功后会发现，即使没有把注脚卸载文末，经Markdown转换后，也会自动归类到文章的最后。代码： 1234使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。[^1]: Markdown是一种纯文本标记语言[^2]: HyperText Markup Language 超文本标记语言[^Le]: 开源笔记平台，支持Markdown和笔记直接发为博文 显示效果：使用 Markdown^1可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。 [^2]: HyperText Markup Language 超文本标记语言[^Le]: 开源笔记平台，支持Markdown和笔记直接发为博文 LaTex公式$表示行内公式代码： 1质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。 显示效果：质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。注意：我的博客没有开启公式显示，所以可能公式显示不准确，请自己用Markdown编辑器查看效果 $表示整行公式代码： 123$$\sum_&#123;i=1&#125;^n a_i=0$$$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$$$\sum^&#123;j-1&#125;_&#123;k=0&#125;&#123;\widehat&#123;\gamma&#125;_&#123;kj&#125; z_k&#125;$$ 表格语法说明：不管是哪种方式，第一行为表头，第二行分割表头和主体部分，第三行开始每一行为一个表格行。列与列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。代码： 1234567简单方式写表格：学号|姓名|分数-|-|-小明|男|75小红|女|79小陆|男|92 1234567原生方式写表格：| 学号 | 姓名 | 分数 || ---- | ---- | ---- || 小明 | 男 | 75 || 小红 | 女 | 79 || 小陆 | 男 | 92 | 123456为表格第二列指定方向：| 产品 | 价格 || ---------------- | -------: || Leanote 高级账号 | 60元/年 || Leanote 超级账号 | 120元/年 | 显示效果：简单方式写表格： 学号 姓名 分数 小明 男 75 小红 女 79 小陆 男 92 原生方式写表格： 学号 姓名 分数 小明 男 75 小红 女 79 小陆 男 92 为表格第二列指定方向： 产品 价格 Leanote 高级账号 60元/年 Leanote 超级账号 120元/年 分割线你可以在一行中用三个以上的星号、减号、底线来建立一个分割线，行内不能有其他东西。也可以在星号或是减号中间插入空格。下面每种写法都可以建立分割线：代码： 12345* * *********- - ---------------------------------------- 代码对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(Tab), 另一种是利用”`”符号（一般在ESC键下方）包裹代码。语法说明：插入行内代码，即插入一个单词或者一句代码的情况，使用&lt;code&gt;这样的形式插入。插入多行代码，可以使用缩进或者“code “,具体看示例。注意： 缩进式插入前方必须有空行 行内式代码： 1C语言里的函数 `scanf()` 怎么使用？ 显示效果：C语言里的函数 scanf() 怎么使用？ 缩进式多行代码缩进4个空格或是一个制表符（Tab）一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。代码： 12345#include &lt;stdio.h&gt;int main(void)&#123; printf(&quot;Hello world\n&quot;);&#125; 显示效果： #include &lt;stdio.h&gt;int main(void){ printf(“Hello world\n”);} 用三个” `”包裹多行代码输入三个后空一行写代码，结束后另起一行输入三个表示代码块的结束 HTML 原始码Markdown支持很多HTML代码，具体不展开。]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
