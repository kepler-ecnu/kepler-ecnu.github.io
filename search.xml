<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java知识点整理(不间断更新)]]></title>
    <url>%2F2019%2F08%2F06%2FJava%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[Java基础知识点简述什么是跨平台由于各种操作系统所支持的指令集不是完全一致的，所以在操作系统上加个虚拟机来提供统一接口，屏蔽系统之间的差异。 Java有几种基本数据类型有八种基本数据类型: 数据类型 字节 默认值 byte 1 0 char 4 ‘\u0000’ boolean 1 false float 4 0.0f double 8 0.0d int 4 0 short 2 0 long 8 0 面向对象特征面向对象的编程语言有封装、继承、多态、抽象四个主要特征。 封装：把描述一个对象的属性和行为封装在一个模块中，即一个类中，属性用变量定义，行为用方法定义，方法可以直接访问同一个对象中的属性。 抽象：把现实生活中的对象抽象为类。分为过程抽象和数据抽象 过程抽象：类的方法（鸟会啼鸣等） 数据抽象：类的属性（鸟有翅膀等） 继承：子类继承父类的特征和行为。子类可以有父类非私有的方法，也可以对父类进行扩展，也可以重写父类的方法。缺点就是提高了代码间的耦合性。 多态： 编译时多态：方法的重载 运行时多态：向上转型、方法重写–基于继承 面向对象六大原则 单一职责原则—-SRP 让每个类只专心处理自己的方法 开闭原则—-OCP 软件中的对象（类、模块、函数等）应该对于扩展开放，对于修改是关闭的 里氏替换原则—-LSP 子类可以去扩展父类，但是不能改变父类原有的功能 依赖倒置原则—-DIP 应该通过调用接口或抽象类，而不是调用实现类 接口隔离原则—-ISP 把接口分为满足依赖关系的最小接口，实现类中不能有不需要的方法 迪米特原则—-LOP 高内聚、低耦合 String属于基础的数据类型吗String不属于基础类型，基础类型有type、boolean、int、char、short、long、float、double，而String属于包装器类型 为什么要有包装类型为了让基本数据类型也具有对象的特征，就出现了包装类型（如在使用集合类型Collection时就一定要使用包装类型而不是基本数据类型）。因为容器都是装object的，这时就需要这些基本数据类型的包装类型了。 基本类型 包装器类型 boolean Boolean char Character int Integer byte Byte short Short long Long float Float double Double 自动装箱和自动拆箱自动装箱：new Integer(6)，底层调用：Integer.valueOf(6)；自动拆箱：int i = new Integer(6)，底层调用：i.intValue();二者的区别： 声明方式不同：基本数据类型不使用new关键字，而包装类型需要使用new关键字在堆中分配存储空间； 存储方式及位置不同：基本数据类型是直接将变量值存储在栈中，而包装类型是将对象放在堆中，然后通过引用来使用； 初始值不同：基本数据类型的初始值如int为0，boolean为false，而包装类型的初始值为null； 使用方式不同：基本数据类型赋值直接使用就好，而包装类型在集合如Collection、Map时会使用到。 String str = “i” 与 String str = new String(“i”)一样么不一样，因为内存的分配方式不一样。String str = "i"的方式，Java虚拟机会将其分配到常量池中；String str = new String("i")则会被分到堆内存中。 如何将字符串反转使用StringBuilder或者StringBuffer的reverse()方法 12345678// StringBuffer reverseStringBuffer stringBuffer = new StringBuffer();stringBuffer. append(&quot;abcdefg&quot;);System. out. println(stringBuffer. reverse()); // gfedcba// StringBuilder reverseStringBuilder stringBuilder = new StringBuilder();stringBuilder. append(&quot;abcdefg&quot;);System. out. println(stringBuilder. reverse()); // gfedcba String 类常用方法1234567891011indexOf()：返回指定字符的索引。charAt()：返回指定索引处的字符。replace()：字符串替换。trim()：去除字符串两端空白。split()：分割字符串，返回一个分割后的字符串数组。getBytes()：返回字符串的 byte 类型数组。length()：返回字符串长度。toLowerCase()：将字符串转成小写字母。toUpperCase()：将字符串转成大写字符。substring()：截取字符串。equals()：字符串比较。 == 和 equals 区别 == 比较的是两个引用在内存中指向的是不是同一对象（即同一内存空间），也就是说在内存中的存储位置是否一致。如果两个对象的引用相同时（指向同一对象时），== 操作符返回true,否则返回false。 对于基本类型和引用类型 == 的作用效果是不同的：基本类型：比较的是值是否相同；引用类型：比较的是引用是否相同；代码示例： 1234567String x = &quot;string&quot;;String y = &quot;string&quot;;String z = new String(&quot;string&quot;);System.out.println(x==y); // trueSystem.out.println(x==z); // falseSystem.out.println(x.equals(y)); // trueSystem.out.println(x.equals(z)); // true 代码解读：因为 x 和 y 指向的是同一个引用，所以 == 是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true equals 用来比较某些特征是否一样，本质上就是 == ，只不过String和Integer等重写了equals方法，把它变成了值比较。首先看默认情况下equals比较一个有相同值的对象，代码如下： 12345678910111213141516171819class Cat &#123; public Cat(String name) &#123; this.name = name; &#125; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; Cat c1 = new Cat(&quot;王磊&quot;);Cat c2 = new Cat(&quot;王磊&quot;);System.out.println(c1.equals(c2)); // false 输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下： 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 原来 equals 本质上就是 ==。那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下： 123String s1 = new String(&quot;老王&quot;);String s2 = new String(&quot;老王&quot;);System.out.println(s1.equals(s2)); // true 同样的，当我们进入 String 的 equals方法，找到了答案，代码如下： 123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; &#125; 原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。总结： == 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重写了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。 String、StringBuffer和StringBuilder区别 数据可变和不可变 String底层使用一个不可变的字符数组private final char value[]，所以它的内容不可变 StringBuffer和StringBuilder都继承了AbstractStringBuilder底层使用的是可变字符数组：char[] value; 线程安全性 StringBulider是线程不安全的，效率较高；而StringBuffer是线程安全的，效率较低；通过他们的append()方法来看，SpringBuffer是有同步锁，而StringBuilder没有：1234567891011 @Overridepublic synchronized StringBuffer append(Object obj) &#123; toStringCache = null; super.append(String.valueOf(obj)); return this;&#125;@Overridepublic StringBuilder append(String str) &#123; super.append(str); return this;&#125; 相同点StringBuilder与StringBuffer有公共父类AbstractBuilder；最后，操作可变字符串速度：StringBuilder &gt; StringBuffer &gt; String。 两个对象的 hashCode()相同，则equals()也一定为true，对吗？不对，两个对象的HashCode()相同，equals()不一定true。代码示例： 1234String str1 = &quot;通话&quot;;String str2 = &quot;重地&quot;;System. out. println(String. format(&quot;str1：%d | str2：%d&quot;, str1. hashCode(),str2. hashCode()));System. out. println(str1. equals(str2)); 执行结果： 123str1：1179395 | str2：1179395 false 代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。 两个对象值相同(x.equals(y)==true)，Hashcode是否一定相同第一种情况：假如这个类没有重写equals方法，如果两个对象值相同，那么他们的hashCode值一定相同；第二种情况：如果重写了equals方法，但没有重写hashCode方法，就会出现不相等的情况。Java对于equals方法和hashCode方法的规定 如果两个对象相同，那么他们的hashCode值一定要相同； 如果两个对象的hashCode相同，他们并不一定相同（这里说的对象相同指的是用equals方法比较）； equals()相等的两个对象，hashCode()一定相等；equals()不相等的两个对象，却并不能证明他们的hashCode()不相等。换句话说，equals()方法不相等的两个对象，hashCode()有可能相等（我的理解是由于哈希码在生成的时候产生冲突造成的）。反过来，hashCode()不等，一定能推出equals()也不等；hashCode()相等，equals()可能相等，也可能不等。 什么时候需要重写equals方法和hashCode方法如果想完整的使用HashSet类(或TreeSet等)，最少需要重写equals()和hashCode()方法 重写hashCode()用于获得元素的存储位置； 重写equals()用于在两个元素的位置相同的时候，比较两个元素是否相等。分析原因如下：1234567hashCode public int hashCode()返回该对象的哈希码值。支持此方法是为了提高哈希表（例如 Java.util.Hashtable 提供的哈希表）的性能。 hashCode 的常规协定是： 在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。 如果根据 equals(Object) 方法，两个对象是相等的，那么对这两个对象中的每个对象调用 hashCode 方法都必须生成相同的整数结果。 如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么对这两个对象中的任一对象上调用 hashCode 方法不 要求一定生成不同的整数结果。但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能。 实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。） 12345678910equals public boolean equals(Object obj)指示其他某个对象是否与此对象“相等”。 equals 方法在非空对象引用上实现相等关系： 自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true。 对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。 传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。 一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。 对于任何非空引用值 x，x.equals(null) 都应返回 false。 Object 类的 equals 方法实现对象上差别可能性最大的相等关系；即，对于任何非空引用值 x 和 y，当且仅当 x 和 y 引用同一个对象时，此方法才返回 true（x == y 具有值 true）。 final在Java中有什么作用 修饰类，则该类不能被继承； 修饰方法，则该方法不能被重写； 修饰变量，修饰的变量叫常量，必须初始化，且初始化后值不能被修改。 static和final区别 关键词 修饰对象 影响 final 变量 分配到常量池中，程序不可改变其值 方法 子类中将不能被重写 类 不能被继承 static 变量 分配在内存堆上，引用都会指向这一地址而不会重新分配内存 方法块 虚拟机优先加载 类 可以直接通过类来调用而不需要new 引用类型占用几个字节hotspot VM在64位平台上占8个字节，在32平台上占4个字节 (1&lt;3)?&quot;a&quot;:&quot;b&quot;)+3+4和(1&lt;3)?&quot;a&quot;:&quot;b&quot;)+(3+4)区别12System.out.println(((1&lt;3)?&quot;a&quot;:&quot;b&quot;)+3+4);System.out.println(((1&lt;3)?&quot;a&quot;:&quot;b&quot;)+(3+4)); 输出 12a34a7 4&amp;5 4^5 4&amp;10&gt;&gt;1各等于多少1234567// 0100 &amp; 0101 = 0100 = 4System.out.println(4&amp;5);// 0100 ^ 0101 = 0001 = 1System.out.println(4^5);System.out.println(10&gt;&gt;1); // 有疑问参考下面的运算符优先级System.out.println(4&amp;10&gt;&gt;1); 输出 12344154 同问 4|5等于多少呢答案为5Tip：与运算符用符号“&amp;”表示，其使用规律如下：两个操作数中位都为1，结果才为1，否则结果为0或运算符用符号“|”表示，其运算规律如下：两个位只要有一个为1，那么结果就是1，否则就为03&amp;4相当于0011&amp;0100，结果是0000，也就是04|5相当于0100|0101，结果是0101，也就是5java的位运算符还有两个：非运算符用符号“~”表示，其运算规律如下：如果位为0，结果是1，如果位为1，结果是0异或运算符是用符号“^”表示的，其运算规律是：两个操作数的位中，相同则结果为0，不同则结果为1 运算符优先级 运算符 结合性 [ ] . ( ) (方法调用) 从左向右 ! ~ ++ – +(一元运算) -(一元运算) 从右向左 * / % 从左向右 + - 从左向右 &lt;&lt; &gt;&gt; &gt;&gt;&gt; 从左向右 &lt; &lt;= &gt; &gt;= instanceof 从左向右 == != 从左向右 &amp; 从左向右 ^ 从左向右 | 从左向右 &amp;&amp; 从左向右 || 从左向右 ?: 从右向左 = 从右向左 Java中 Math.round(-1.5)等于多少？Math.round(-2.5)等于多少？答案：-1，-2注意：不要认为它是四舍五入计算口诀：+0.5后向下取整即可同理Math.round(-2.6)结果和Math.round(2.6)结果分别为-3，3 抽象类必须要有抽象方法吗？不需要，抽象类不一定非要抽象方法 12345abstract class Cat &#123; public static void sayHi() &#123; System. out. println(&quot;hi~&quot;); &#125; &#125; 普通类和抽象类有哪些区别普通类不能包含抽象方法，抽象类可以包含抽象方法抽象类不能直接实例化，普通类可以直接实例化 抽象类能使用final修饰吗不能，定义抽象类就是让其他类继承的，如果定义为final该类就不能被继承，这样彼此就会产生矛盾，所以final不能修饰抽象类。 接口和抽象类的区别 实现：抽象类的子类使用extends来继承；接口必须使用implements来实现接口； 构造函数：抽象类有构造函数；接口不能有； 实现数量：类可以实现多个接口，但是只能继承一个抽象类； 访问修饰符：抽象类中的抽象方法(其前有abstract修饰)不能用private、static、synchronized、native访问修饰符修饰；接口中的方法默认使用 public 修饰，接口是一种特殊的抽象类，接口中的方法全部是抽象方法（但其前的abstract可以省略），所以抽象类中的抽象方法不能用的访问修饰符这里也不能用，而且protected访问修饰符也不能使用。 Java中IO流分为几种 按功能分：输入流（input）、输出流（output） 按类型分：字节流和字符流 字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。 BIO、NIO和AIO区别 BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。 NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。 AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。 Files常用方法有哪些123456789Files. exists()：检测文件路径是否存在。Files. createFile()：创建文件。Files. createDirectory()：创建文件夹。Files. delete()：删除一个文件或目录。Files. copy()：复制文件。Files. move()：移动文件。Files. size()：查看文件个数。Files. read()：读取文件。Files. write()：写入文件。 容器Java容器都有哪些Java容器分为Collection和Map两大类，其下又有很多子类，如下所示： Collection List ArrayList LinkedList Vector Stack Set HashSet LinkedHashSet TreeSet Map HashMap LinkedHashMap TreeMap ConcurrentHashMap Hashtable 简述Java中的集合 Collection下：List系（有序、元素允许重复）和Set系（无序、元素不重复） set根据equals和hashCode判断，一个对象要存储在Set中，必须重写equals和hashCode方法。 Map下：HashMap线程不同步；TreeMap线程同步； Collection系列和Map系列：Map是对Colleciton的补充，两者没什么关系。 List、Set、Map之间的区别List、Set、Map之间的区别主要体现在两个方面：元素是否有序、是否允许元素重复三者间的区别，如表所示： 元素有序 允许元素重复 List 是 是 Set AbstractSet 否 否 HashSet TreeSet 是（用二叉树排序） Map AbstractMap 否 key值必须唯一value值可重复 HashMap TreeMap 是（用二叉树排序） HashMap、HashTable和ConcurrentHashMap区别相同点： 1. HashMap和HashTable都实现了Map接口 2. 都可以存储key-value数据不同点： 1. HashMap可以把null作为key或者value,HashTable不可以 2. HashMap线程不安全，效率高，HashTable线程安全，效率低 3. HashMap迭代器(Iterator)是fail-fast迭代器，而HashTable的enumerator迭代器不是fail-fast的 什么是fail-fast? 就是最快的时间能把错误抛出而不是让程序执行 4. Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。 如何保证线程安全又效率高Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。ConcurrentHashMap将整个Map分为N个segment(类似HashTable)，可以提供相同的线程安全，但是效率提升N倍，默认N为16。 我们能否让HashMap同步HashMap可以通过下面语句进行同步 1Map m = Collections.synchronizeMap(hashMap); 如何决定使用HashMap还是TreeMap对于在 Map 中插入、删除、定位一个元素这类操作，HashMap是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。 说一下 HashMap 的实现原理HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。 说一下 HashSet 的实现原理HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。 ArrayList 和 LinkdList 区别 ArrayList的实现基于动态数组的数据结构，LinkedList基于链表的数据结构； 对于随机访问get和set，ArrayList优于LinkedList，因为LinkedList需要移动指针； 对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。 如何实现数组和 List 之间的转换数组转 List：使用 Arrays. asList(array) 进行转换；List 转数组：使用 List 自带的 toArray() 方法 12345678// list to arrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();list. add(&quot;王磊&quot;);list. add(&quot;的博客&quot;);list. toArray();// array to listString[] array = new String[]&#123;&quot;王磊&quot;,&quot;的博客&quot;&#125;;Arrays. asList(array); ArrayList 和 Vector 的区别线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的性能：ArrayList 在性能方面要优于 Vector扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50% Array 和 ArrayList 有何区别Array 可以存储基本数据类型和对象，ArrayList 只能存储对象;Array 是指定固定大小的，而 ArrayList 大小是自动扩展的;Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。 在 Queue 中 poll()和 remove()有什么区别相同点：都是返回第一个元素，并在队列中删除返回的对象不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常tip: queue的增加元素方法add和offer的区别在于，add方法在队列满的情况下将选择抛异常的方法来表示队列已经满了，而offer方法通过返回false表示队列已经满了；在有限队列的情况，使用offer方法优于add方法； remove方法和poll方法都是删除队列的头元素，remove方法在队列为空的情况下将抛异常，而poll方法将返回null； element和peek方法都是返回队列的头元素，但是不删除头元素，区别在与element方法在队列为空的情况下，将抛异常，而peek方法将返回null.12345Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();queue. offer(&quot;string&quot;); // addSystem. out. println(queue. poll());System. out. println(queue. remove());System. out. println(queue. size()); 哪些集合类是线程安全的Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK 1.5 之后随着 Java. util. concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。 迭代器 Iterator 是什么Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。 Iterator 怎么使用？有什么特点？123456List&lt;String&gt; list = new ArrayList&lt;&gt;();Iterator&lt;String&gt; it = list. iterator();while(it. hasNext())&#123; String obj = it. next(); System. out. println(obj);&#125; Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。 ConcurrentModificationException异常出现的原因123456789101112public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(2); Iterator&lt;Integer&gt; iterator = list.iterator(); while(iterator.hasNext())&#123; Integer integer = iterator.next(); if(integer==2) list.remove(integer); &#125; &#125;&#125; 执行上段代码是有问题的，会抛出ConcurrentModificationException异常。原因：调用list.remove()方法导致modCount和expectedModCount的值不一致。 1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException();&#125; 解决办法：在迭代器中如果要删除元素的话，需要调用Iterator类的remove方法。 123456789101112public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(2); Iterator&lt;Integer&gt; iterator = list.iterator(); while(iterator.hasNext())&#123; Integer integer = iterator.next(); if(integer==2) iterator.remove(); //注意这个地方 &#125; &#125;&#125; 怎么确保一个集合不能被修改可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。 12345List&lt;String&gt; list = new ArrayList&lt;&gt;();list. add(&quot;x&quot;);Collection&lt;String&gt; clist = Collections. unmodifiableCollection(list);clist. add(&quot;y&quot;); // 运行时此行报错System. out. println(list. size()); 多线程并行和并发有什么区别 并行：多个处理器或多核处理器同时处理多个任务。 并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。 线程和进程的区别一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。 守护线程是什么守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。 创建线程的方式常见回答 继承 Thread 重写 run 方法； 实现 Runnable 接口； 实现 Callable 接口。 下面做个较为全面的总结： 继承Trhead类，作为线程对象存在（继承Thread对象）12345678910111213141516171819202122232425262728293031public class CreatThreadDemo1 extends Thread&#123; /** * 构造方法： 继承父类方法的Thread(String name)；方法 * @param name */ public CreatThreadDemo1(String name)&#123; super(name); &#125; @Override public void run() &#123; while (!interrupted())&#123; System.out.println(getName()+&quot;线程执行了...&quot;); try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; CreatThreadDemo1 d1 = new CreatThreadDemo1(&quot;first&quot;); CreatThreadDemo1 d2 = new CreatThreadDemo1(&quot;second&quot;); d1.start(); d2.start(); d1.interrupt(); //中断第一个线程 &#125;&#125; 常规方法，不多做介绍了，interrupted方法，是来判断该线程是否被中断。（终止线程不允许用stop方法，该方法不会施放占用的资源。所以我们在设计程序的时候，要按照中断线程的思维去设计，就像上面的代码一样）。 * 让线程等待的方法 Thread.sleep(200);//线程休息2ms Object.wait();//让线程进入等待，直到调用Object的notify或者notifyAll，线程停止休眠 实现runnable接口，作为线程任务存在123456789101112131415public class CreatThreadDemo2 implements Runnable &#123; @Override public void run() &#123; while (true)&#123; System.out.println(&quot;线程执行了...&quot;); &#125; &#125; public static void main(String[] args) &#123; //将线程任务传给线程对象 Thread thread = new Thread(new CreatThreadDemo2()); //启动线程 thread.start(); &#125;&#125; Runnable 只是来修饰线程所执行的任务，它不是一个线程对象。想要启动Runnable对象，必须将它放到一个线程对象里。 匿名内部类创建线程对象123456789101112131415161718192021222324252627282930public class CreatThreadDemo3 extends Thread&#123; public static void main(String[] args) &#123; //创建无参线程对象 new Thread()&#123; @Override public void run() &#123; System.out.println(&quot;线程执行了...&quot;); &#125; &#125;.start(); //创建带线程任务的线程对象 new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;线程执行了...&quot;); &#125; &#125;).start(); //创建带线程任务并且重写run方法的线程对象 new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;runnable run 线程执行了...&quot;); &#125; &#125;)&#123; @Override public void run() &#123; System.out.println(&quot;override run 线程执行了...&quot;); &#125; &#125;.start(); &#125;&#125; 创建带线程任务并且重写run方法的线程对象中，为什么只运行了Thread的run方法。通过查看Thread类的源码，我们可以看到Thread实现了Runnable接口，而Runnable接口里有一个run方法。所以，我们最终调用的重写的方法应该是Thread类的run方法。而不是Runnable接口的run方法。 创建带返回值的线程（实现Callable接口）12345678910111213141516171819202122232425public class CreatThreadDemo4 implements Callable &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; CreatThreadDemo4 demo4 = new CreatThreadDemo4(); FutureTask&lt;Integer&gt; task = new FutureTask&lt;Integer&gt;(demo4); //FutureTask最终实现的是runnable接口 Thread thread = new Thread(task); thread.start(); System.out.println(&quot;我可以在这里做点别的业务逻辑...因为FutureTask是提前完成任务&quot;); //拿出线程执行的返回值 Integer result = task.get(); System.out.println(&quot;线程中运算的结果为:&quot;+result); &#125; //重写Callable接口的call方法 @Override public Object call() throws Exception &#123; int result = 1; System.out.println(&quot;业务逻辑计算中...&quot;); Thread.sleep(3000); return result; &#125;&#125; Callable接口介绍： 123456789public interface Callable&lt;V&gt; &#123; /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;&#125; 返回指定泛型的call方法。然后调用FutureTask对象的get方法得到call方法的返回值。 定时器Timer 1234567891011121314public class CreatThreadDemo5 &#123; public static void main(String[] args) &#123; Timer timer = new Timer(); timer.schedule(new TimerTask() &#123; @Override public void run() &#123; System.out.println(&quot;定时器线程执行了...&quot;); &#125; &#125;,0,1000); //延迟0，周期1s &#125;&#125; 线程池创建线程 1234567891011121314151617181920public class CreatThreadDemo6 &#123; public static void main(String[] args) &#123; //创建一个具有10个线程的线程池 ExecutorService threadPool = Executors.newFixedThreadPool(10); long threadpoolUseTime = System.currentTimeMillis(); for (int i = 0;i&lt;10;i++)&#123; threadPool.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+&quot;线程执行了...&quot;); &#125; &#125;); &#125; long threadpoolUseTime1 = System.currentTimeMillis(); System.out.println(&quot;多线程用时&quot;+(threadpoolUseTime1-threadpoolUseTime)); //销毁线程池 threadPool.shutdown(); threadpoolUseTime = System.currentTimeMillis(); &#125;&#125; 利用java8新特性stream实现并发 12345678910public class CreatThreadDemo7 &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; values = Arrays.asList(10,20,30,40); //parallel 平行的，并行的 int result = values.parallelStream().mapToInt(p -&gt; p*2).sum(); System.out.println(result); //怎么证明它是并发处理呢 values.parallelStream().forEach(p-&gt; System.out.println(p)); &#125;&#125; 输出 1234520040102030 说一下runnable和callable区别runnable 没有返回值，callable 可以拿到有返回值，callable 可以看作是 runnable 的补充。 线程有哪些状态线程的状态： NEW 尚未启动 RUNNABLE 正在执行中 BLOCKED 阻塞的（被同步锁或者IO锁阻塞） WAITING 永久等待状态 TIMED_WAITING 等待指定的时间重新被唤醒的状态 TERMINATED 执行完成 sleep() 和 wait() 有什么区别 类的不同：sleep() 来自 Thread，wait() 来自 Object。 释放锁：sleep() 不释放锁；wait() 释放锁。 用法不同：sleep() 时间到会自动恢复；wait() 可以使用notify()/notifyAll()直接唤醒。 notify()和 notifyAll()有什么区别notifyAll()会唤醒所有的线程，notify()只唤醒一个线程。notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。 线程的 run() 和 start() 有什么区别start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。 创建线程池有哪几种方式？线程池创建有七种方式，最核心的是最后一种： newSingleThreadExecutor()：它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目； newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列； newFixedThreadPool(int nThreads)：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads； newSingleThreadScheduledExecutor()：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度； newScheduledThreadPool(int corePoolSize)：和newSingleThreadScheduledExecutor()类似，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程； newWorkStealingPool(int parallelism)：这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序； ThreadPoolExecutor()：是最原始的线程池创建，上面1-3创建方式都是对ThreadPoolExecutor的封装。 常用为Executors提供的四种方法来创建线程池： newFixedThreadPool() :创建固定大小的线程池。 newCachedThreadPool(): 创建无限大小的线程池，线程池中线程数量不固定，可根据需求自动更改。 newSingleThreadPool() : 创建单个线程池，线程池中只有一个线程。 newScheduledThreadPool(): 创建固定大小的线程池，可以延迟或定时的执行任务。示例： 12345678public static void main(String[] args) &#123; ExecutorService threadPool = Executors.newCachedThreadPool(); threadPool.execute(() -&gt; &#123; for (int i = 0; i&lt; 20;i++) &#123; System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i); &#125; &#125;); threadPool.shutdown(); 线程池作用 限制线程个数，避免线程过多导致系统运行缓慢或崩溃。 不需要频繁的创建和销毁，节约资源、响应更快。 线程池都有哪些状态？ RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。 SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。 STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。 TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。 TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。 线程池中 submit() 和 execute() 方法有什么区别？ execute()：只能执行 Runnable 类型的任务。 submit()：可以执行 Runnable 和 Callable 类型的任务。 Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。 在 Java 程序中怎么保证多线程的运行安全 方法一：使用安全类，比如 Java. util. concurrent 下的类。 方法二：使用自动锁 synchronized。 方法三：使用手动锁 Lock。 手动锁 Java 示例代码如下： 12345678910Lock lock = new ReentrantLock();lock. lock();try &#123; System. out. println(&quot;获得锁&quot;);&#125; catch (Exception e) &#123; // TODO: handle exception&#125; finally &#123; System. out. println(&quot;释放锁&quot;); lock. unlock();&#125; 多线程中 synchronized 锁升级的原理是什么synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。 锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。 什么是死锁？当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。 怎么防止死锁？ 尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。 尽量使用 Java. util. concurrent 并发类代替自己手写锁。 尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。 尽量减少同步的代码块 ThreadLocal 是什么？有哪些使用场景？ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。ThreadLocal 的经典使用场景是数据库连接和 session 管理等。 说一下 synchronized 底层实现原理？synchronized 是由一对 monitorenter/monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在 Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能 synchronized 和 volatile 的区别是什么？ volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。 volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。 volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。 synchronized 和 Lock 有什么区别？ synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。 synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。 synchronized 和 ReentrantLock 区别是什么？synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进 主要区别如下： ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作； ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁； ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。 volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。 说一下 atomic 的原理？atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。 反射对象拷贝Java Web异常网络设计模式JVM]]></content>
      <categories>
        <category>java知识点整理</category>
      </categories>
      <tags>
        <tag>java知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown入门教程]]></title>
    <url>%2F2019%2F08%2F01%2FMarkdown%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[&lt; !–more–&gt; 斜体和粗体代码： 1234*斜体*或_斜体_ **粗体*****加粗斜体***~~删除线~~ 显示效果：这是一段斜体这是一段粗体这是一段加粗斜体这是一段删除线 分级标题第一种写法： 1234这是一个一级标题==================这是一个二级标题------------------ 就是在文字的下一行增加不同的横线，不建议使用。第二种写法： 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 推荐使用这种方式，简单易记，不同级别的标题后面#不一样多，在#后需要空一格。 超链接Markdown 支持两种形式的链接语法：行内式和参考式两种形式，行内式一般用的较多。 行内式语法说明：[]里写链接文字，()里写链接地址，()中的" "可以为链接指定title属性，title属性可加可不加。title属性效果是鼠标悬停在链接上会出现指定的title文字。链接文字这样的形式。注：链接地址与链接标题间有一个空格。代码： 12欢迎访问[我的博客](https://kepler-ecnu.github.io/)欢迎访问[我的博客](https://kepler-ecnu.github.io/ &quot;kepler&apos;s blog&quot;) 显示效果：欢迎访问我的博客欢迎访问我的博客 这个设置了标题，在鼠标指在超链接上时显示标题。 参考式参考式超链接一般用在学术论文上，或者若某一个链接在文章中多出使用，则使用引用的方式创建链接，这样可以对链接进行同意的管理。语法说明：参考式链接分为两部分，文中的写法[链接文字][链接标记]，在文本的任意位置添加[链接文字]:链接地址 “链接标记”，链接地址与链接标记间一个空格。如果链接文字本身可以作为链接标记，也可以写成[链接文字][][链接文字]：链接地址的形式，见代码的最后一行。代码： 12345我经常访问的网站[baidu][1]、[bilibili][2]等[B站][2]有我整理的[音乐合集][]。[1]:https://www.baidu.com/ &quot;baidu&quot;[2]:https://space.bilibili.com/12737596 &quot;bilibili&quot;[音乐合集]:https://space.bilibili.com/12737596 自动链接语法说明Markdown支持较简短的自动链接形式来处理网址和电子邮箱，只要是用包起来，Markdown就会自动把它转成链接。一般网址的链接文字和链接地址一样，如：代码： 12&lt;https://space.bilibili.com/12737596&gt;&lt;address@example.com&gt; 显示效果：https://space.bilibili.com/12737596&#x61;&#x64;&#100;&#114;&#x65;&#x73;&#115;&#x40;&#101;&#120;&#97;&#109;&#x70;&#108;&#101;&#46;&#99;&#111;&#x6d; 锚点网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。语法描述：在你准备跳转到的指定标题后插入锚点,然后在文档的其它地方写上链接到锚点的链接。（这里不展开） 列表无序列表使用*，+，-表示无序列表代码： 123* 无序列表项一+ 无序列表项二- 无序列表项三 显示效果： 无序列表项一 无序列表项二 无序列表项三 有序列表有序列表则使用数字接着一个英文句点，接着空一个格写列表项。代码： 1231. 有序列表项一2. 有序列表项二3. 有序列表项三 显示效果： 有序列表项一 有序列表项二 有序列表项三 定义型列表语法说明：定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法:紧跟一个缩进（Tab） 列表缩进语法说明列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3个空格，项目标记后面则一定要接着至少一个空格或制表符。要让列表看起来更漂亮，你可以把内容用固定的缩进整理好（显示效果与代码一致）：轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。但是如果你懒，那也行：代码： 1234567* 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！* 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 显示效果： 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。包含段落的列表列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符（显示效果与代码一致）：轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。但是如果你懒，那也行：代码：1234567* 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！* 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 显示效果： 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 包含引用的列表语法说明：如果要在列表项目内放进引用，那 &gt; 就需要缩进：代码： 1234* 阅读的方法： &gt; 拿出书本 &gt; 放下手机 &gt; 开始看吧 显示效果： 阅读的方法： 拿出书本放下手机开始看吧 包含代码区块的引用语法说明：如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：一列表项包含一个列表区块： 写代码块的地方 引用语法说明：引用需要在被引用的文本前加上 &gt; 符号。代码： 123456&gt; 这是一个有两段文字的引用&gt; text1&gt; text2&gt;&gt; text3&gt; text4 显示效果： 这是一个有两段文字的引用text1text2 text3text4 引用的多层嵌套区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ：代码： 123456&gt; 这是一个有两段文字的引用&gt;&gt; text1&gt;&gt;&gt; text2&gt;&gt; text3&gt; text4 显示效果： 这是一个有两段文字的引用 text1 text2 text3text4 引用的其它要素引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：代码： 1234567&gt; 1. 第一列表项&gt; 2. 第二列表项&gt;&gt; text1&gt;&gt;&gt; text2&gt;&gt; return shell_exec(&quot;echo $input | $markdown_script&quot;);&gt; `return shell_exec(&quot;echo $input | $markdown_script&quot;);` 显示效果： 第一列表项 第二列表项 text1 text2 return shell_exec(&quot;echo $input | $markdown_script&quot;);return shell_exec(&quot;echo $input | $markdown_script&quot;); 插入图片图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。语法中图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。 行内式语法说明：![图片Alt](图片地址 "图片Title")代码： 1![图片示例](http://img.redocn.com/sheji/20141219/zhongguofengdaodeliyizhanbanzhijing_3744115.jpg &quot;图片示例&quot;) 显示效果： 参考式语法说明：（这里不作介绍）在文档要插入图片的地方写![图片Alt][标记]在文档的最后写上写[标记]:图片地址 “Title” 内容目录在段落中填写 [TOC] 以显示全文内容的目录结构。Hexo博客对目录的解析似乎也有限，请在Markdown编辑器中自行尝试。Next主题的话是也可以自动生成目录的，所以不需要额外增加目录。 注脚语法说明：在需要添加注脚的文字后加上脚注名字[^脚注名字]，称为加注。然后在文本的任意位置（一般在最后）添加脚注，脚注前必须有对应的脚注名字。注意：经测试注脚和脚注之间必须空一行，不然会失效。成功后会发现，即使没有把注脚卸载文末，经Markdown转换后，也会自动归类到文章的最后。代码： 1234使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。[^1]: Markdown是一种纯文本标记语言[^2]: HyperText Markup Language 超文本标记语言[^Le]: 开源笔记平台，支持Markdown和笔记直接发为博文 显示效果：使用 Markdown^1可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。 [^2]: HyperText Markup Language 超文本标记语言[^Le]: 开源笔记平台，支持Markdown和笔记直接发为博文 LaTex公式$表示行内公式代码： 1质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。 显示效果：质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。注意：我的博客没有开启公式显示，所以可能公式显示不准确，请自己用Markdown编辑器查看效果 $表示整行公式代码： 123$$\sum_&#123;i=1&#125;^n a_i=0$$$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$$$\sum^&#123;j-1&#125;_&#123;k=0&#125;&#123;\widehat&#123;\gamma&#125;_&#123;kj&#125; z_k&#125;$$ 表格语法说明：不管是哪种方式，第一行为表头，第二行分割表头和主体部分，第三行开始每一行为一个表格行。列与列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。代码： 1234567简单方式写表格：学号|姓名|分数-|-|-小明|男|75小红|女|79小陆|男|92 1234567原生方式写表格：| 学号 | 姓名 | 分数 || ---- | ---- | ---- || 小明 | 男 | 75 || 小红 | 女 | 79 || 小陆 | 男 | 92 | 123456为表格第二列指定方向：| 产品 | 价格 || ---------------- | -------: || Leanote 高级账号 | 60元/年 || Leanote 超级账号 | 120元/年 | 显示效果：简单方式写表格： 学号 姓名 分数 小明 男 75 小红 女 79 小陆 男 92 原生方式写表格： 学号 姓名 分数 小明 男 75 小红 女 79 小陆 男 92 为表格第二列指定方向： 产品 价格 Leanote 高级账号 60元/年 Leanote 超级账号 120元/年 分割线你可以在一行中用三个以上的星号、减号、底线来建立一个分割线，行内不能有其他东西。也可以在星号或是减号中间插入空格。下面每种写法都可以建立分割线：代码： 12345* * *********- - ---------------------------------------- 代码对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(Tab), 另一种是利用”`”符号（一般在ESC键下方）包裹代码。语法说明：插入行内代码，即插入一个单词或者一句代码的情况，使用&lt;code&gt;这样的形式插入。插入多行代码，可以使用缩进或者“code “,具体看示例。注意： 缩进式插入前方必须有空行 行内式代码： 1C语言里的函数 `scanf()` 怎么使用？ 显示效果：C语言里的函数 scanf() 怎么使用？ 缩进式多行代码缩进4个空格或是一个制表符（Tab）一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。代码： 12345#include &lt;stdio.h&gt;int main(void)&#123; printf(&quot;Hello world\n&quot;);&#125; 显示效果： #include &lt;stdio.h&gt;int main(void){ printf(“Hello world\n”);} 用三个” `”包裹多行代码输入三个后空一行写代码，结束后另起一行输入三个表示代码块的结束 HTML 原始码Markdown支持很多HTML代码，具体不展开。]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
