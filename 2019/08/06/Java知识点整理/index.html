<!DOCTYPE html>





<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32.ico?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16.ico?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2">


<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.3.0',
    sidebar: {"position":"left","display":"post","offset":10,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    copycode: {"enable":true,"show_result":true,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    search: {
      root: '/',
      path: 'search.xml'
    },
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>


<script>(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/163152dc.js","daovoice")</script>


  <meta name="description" content="Java基础知识点简述什么是跨平台由于各种操作系统所支持的指令集不是完全一致的，所以在操作系统上加个虚拟机来提供统一接口，屏蔽系统之间的差异。 Java有几种基本数据类型有八种基本数据类型:    数据类型 字节 默认值    byte 1 0   char 4 ‘\u0000’   boolean 1 false   float 4 0.0f   double 8 0.0d   int 4 0">
<meta name="keywords" content="java知识点">
<meta property="og:type" content="article">
<meta property="og:title" content="Java知识点整理(不间断更新)">
<meta property="og:url" content="https://kepler-ecnu.github.io/2019/08/06/Java知识点整理/index.html">
<meta property="og:site_name" content="The real world">
<meta property="og:description" content="Java基础知识点简述什么是跨平台由于各种操作系统所支持的指令集不是完全一致的，所以在操作系统上加个虚拟机来提供统一接口，屏蔽系统之间的差异。 Java有几种基本数据类型有八种基本数据类型:    数据类型 字节 默认值    byte 1 0   char 4 ‘\u0000’   boolean 1 false   float 4 0.0f   double 8 0.0d   int 4 0">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://kepler-ecnu.github.io/images/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.webp">
<meta property="og:image" content="https://kepler-ecnu.github.io/images/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.webp">
<meta property="og:image" content="https://kepler-ecnu.github.io/images/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.webp">
<meta property="og:image" content="https://kepler-ecnu.github.io/images/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95.webp">
<meta property="og:image" content="https://kepler-ecnu.github.io/images/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E6%B3%95.webp">
<meta property="og:image" content="https://kepler-ecnu.github.io/images/serial.webp">
<meta property="og:image" content="https://kepler-ecnu.github.io/images/parnew.webp">
<meta property="og:image" content="https://kepler-ecnu.github.io/images/cms.webp">
<meta property="og:image" content="https://kepler-ecnu.github.io/images/g1.webp">
<meta property="og:updated_time" content="2019-08-17T09:51:56.782Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java知识点整理(不间断更新)">
<meta name="twitter:description" content="Java基础知识点简述什么是跨平台由于各种操作系统所支持的指令集不是完全一致的，所以在操作系统上加个虚拟机来提供统一接口，屏蔽系统之间的差异。 Java有几种基本数据类型有八种基本数据类型:    数据类型 字节 默认值    byte 1 0   char 4 ‘\u0000’   boolean 1 false   float 4 0.0f   double 8 0.0d   int 4 0">
<meta name="twitter:image" content="https://kepler-ecnu.github.io/images/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.webp">
  <link rel="canonical" href="https://kepler-ecnu.github.io/2019/08/06/Java知识点整理/">


<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Java知识点整理(不间断更新) | The real world</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">The real world</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">You can do something</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
    <ul id="menu" class="menu">
        
        
        
          
          <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        <li class="menu-item menu-item-search">
          <a href="javascript:;" class="popup-trigger">
          
            <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>


    </div>
</nav>

</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kepler-ecnu.github.io/2019/08/06/Java知识点整理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="kepler">
      <meta itemprop="description" content="GGS  DDU">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The real world">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">Java知识点整理(不间断更新)

              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-06 13:20:21" itemprop="dateCreated datePublished" datetime="2019-08-06T13:20:21+08:00">2019-08-06</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-17 17:51:56" itemprop="dateModified" datetime="2019-08-17T17:51:56+08:00">2019-08-17</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java知识点整理/" itemprop="url" rel="index"><span itemprop="name">java知识点整理</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/08/06/Java知识点整理/" class="post-meta-item leancloud_visitors" data-flag-title="Java知识点整理(不间断更新)">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">评论数：</span>
    
  
    <a href="/2019/08/06/Java知识点整理/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/08/06/Java知识点整理/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">36k</span>
            </span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">33 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Java基础知识点"><a href="#Java基础知识点" class="headerlink" title="Java基础知识点"></a>Java基础知识点</h2><h3 id="简述什么是跨平台"><a href="#简述什么是跨平台" class="headerlink" title="简述什么是跨平台"></a>简述什么是跨平台</h3><p>由于各种操作系统所支持的指令集不是完全一致的，所以在操作系统上加个虚拟机来提供统一接口，屏蔽系统之间的差异。</p>
<h3 id="Java有几种基本数据类型"><a href="#Java有几种基本数据类型" class="headerlink" title="Java有几种基本数据类型"></a>Java有几种基本数据类型</h3><p>有八种基本数据类型:</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>字节</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>char</td>
<td>4</td>
<td>‘\u0000’</td>
</tr>
<tr>
<td>boolean</td>
<td>1</td>
<td>false</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>0.0d</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>0</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
<td>0</td>
</tr>
</tbody></table>
<h3 id="面向对象特征"><a href="#面向对象特征" class="headerlink" title="面向对象特征"></a>面向对象特征</h3><p>面向对象的编程语言有<strong>封装、继承、多态、抽象</strong>四个主要特征。</p>
<ul>
<li>封装：把描述一个对象的属性和行为封装在一个模块中，即一个类中，属性用变量定义，行为用方法定义，方法可以直接访问同一个对象中的属性。</li>
<li>抽象：把现实生活中的对象抽象为类。分为过程抽象和数据抽象<ul>
<li>过程抽象：类的方法（鸟会啼鸣等）</li>
<li>数据抽象：类的属性（鸟有翅膀等）</li>
</ul>
</li>
<li>继承：子类继承父类的特征和行为。子类可以有父类非私有的方法，也可以对父类进行扩展，也可以重写父类的方法。缺点就是提高了代码间的耦合性。</li>
<li>多态：<ul>
<li>编译时多态：方法的重载</li>
<li>运行时多态：向上转型、方法重写–基于继承</li>
</ul>
</li>
</ul>
<h3 id="面向对象六大原则"><a href="#面向对象六大原则" class="headerlink" title="面向对象六大原则"></a>面向对象六大原则</h3><ol>
<li><strong>单一职责</strong>原则—-SRP<ul>
<li>让每个类只专心处理自己的方法</li>
</ul>
</li>
<li><strong>开闭</strong>原则—-OCP<ul>
<li>软件中的对象（类、模块、函数等）应该<strong>对于扩展开放</strong>，<strong>对于修改是关闭</strong>的</li>
</ul>
</li>
<li><strong>里氏替换</strong>原则—-LSP<ul>
<li>子类可以去扩展父类，但是不能改变父类原有的功能</li>
</ul>
</li>
<li><strong>依赖倒置</strong>原则—-DIP<ul>
<li>应该通过调用接口或抽象类，而不是调用实现类</li>
</ul>
</li>
<li><strong>接口隔离</strong>原则—-ISP<ul>
<li>把接口分为满足依赖关系的最小接口，实现类中不能有不需要的方法</li>
</ul>
</li>
<li><strong>迪米特</strong>原则—-LOP<ul>
<li>高内聚、低耦合</li>
</ul>
</li>
</ol>
<h3 id="String属于基础的数据类型吗"><a href="#String属于基础的数据类型吗" class="headerlink" title="String属于基础的数据类型吗"></a>String属于基础的数据类型吗</h3><p>String不属于基础类型，基础类型有type、boolean、int、char、short、long、float、double，而String属于包装器类型</p>
<h3 id="为什么要有包装类型"><a href="#为什么要有包装类型" class="headerlink" title="为什么要有包装类型"></a>为什么要有包装类型</h3><p>为了让基本数据类型也具有对象的特征，就出现了包装类型（如在使用集合类型Collection时就一定要使用包装类型而不是基本数据类型）。因为容器都是装object的，这时就需要这些基本数据类型的包装类型了。</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>包装器类型</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
</tbody></table>
<h3 id="自动装箱和自动拆箱"><a href="#自动装箱和自动拆箱" class="headerlink" title="自动装箱和自动拆箱"></a>自动装箱和自动拆箱</h3><p>自动装箱：<code>new Integer(6)</code>，底层调用：<code>Integer.valueOf(6)</code>；<br>自动拆箱：<code>int i = new Integer(6)</code>，底层调用：<code>i.intValue();</code><br>二者的区别：</p>
<ul>
<li>声明方式不同：基本数据类型不使用new关键字，而包装类型需要使用new关键字在<strong>堆中分配存储空间</strong>；</li>
<li>存储方式及位置不同：基本数据类型是直接将变量值存储在<strong>栈</strong>中，而包装类型是将对象放在<strong>堆</strong>中，然后通过<strong>引用</strong>来使用；</li>
<li>初始值不同：基本数据类型的初始值如int为0，boolean为false，而包装类型的初始值为null；</li>
<li>使用方式不同：基本数据类型赋值直接使用就好，而包装类型在集合如Collection、Map时会使用到。</li>
</ul>
<h3 id="String-str-“i”-与-String-str-new-String-“i”-一样么"><a href="#String-str-“i”-与-String-str-new-String-“i”-一样么" class="headerlink" title="String str = “i” 与 String str = new String(“i”)一样么"></a>String str = “i” 与 String str = new String(“i”)一样么</h3><p>不一样，因为内存的分配方式不一样。<code>String str = "i"</code>的方式，Java虚拟机会将其分配到常量池中；<code>String str = new String("i")</code>则会被分到堆内存中。</p>
<h3 id="如何将字符串反转"><a href="#如何将字符串反转" class="headerlink" title="如何将字符串反转"></a>如何将字符串反转</h3><p>使用StringBuilder或者StringBuffer的reverse()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// StringBuffer reverse</span><br><span class="line">StringBuffer stringBuffer = new StringBuffer();</span><br><span class="line">stringBuffer. append(&quot;abcdefg&quot;);</span><br><span class="line">System. out. println(stringBuffer. reverse()); // gfedcba</span><br><span class="line">// StringBuilder reverse</span><br><span class="line">StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">stringBuilder. append(&quot;abcdefg&quot;);</span><br><span class="line">System. out. println(stringBuilder. reverse()); // gfedcba</span><br></pre></td></tr></table></figure>

<h3 id="String-类常用方法"><a href="#String-类常用方法" class="headerlink" title="String 类常用方法"></a>String 类常用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">indexOf()：返回指定字符的索引。</span><br><span class="line">charAt()：返回指定索引处的字符。</span><br><span class="line">replace()：字符串替换。</span><br><span class="line">trim()：去除字符串两端空白。</span><br><span class="line">split()：分割字符串，返回一个分割后的字符串数组。</span><br><span class="line">getBytes()：返回字符串的 byte 类型数组。</span><br><span class="line">length()：返回字符串长度。</span><br><span class="line">toLowerCase()：将字符串转成小写字母。</span><br><span class="line">toUpperCase()：将字符串转成大写字符。</span><br><span class="line">substring()：截取字符串。</span><br><span class="line">equals()：字符串比较。</span><br></pre></td></tr></table></figure>

<h3 id="和-equals-区别"><a href="#和-equals-区别" class="headerlink" title="== 和 equals 区别"></a>== 和 equals 区别</h3><ul>
<li><p>== 比较的是<strong>两个引用</strong>在内存中指向的是不是同一对象（即同一内存空间），也就是说在内存中的存储位置是否一致。如果两个对象的引用相同时（指向同一对象时），== 操作符返回true,否则返回false。</p>
<ul>
<li><p>对于基本类型和引用类型 == 的作用效果是不同的：<br>基本类型：比较的是值是否相同；<br>引用类型：比较的是引用是否相同；<br>代码示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String x = &quot;string&quot;;</span><br><span class="line">String y = &quot;string&quot;;</span><br><span class="line">String z = new String(&quot;string&quot;);</span><br><span class="line">System.out.println(x==y); // true</span><br><span class="line">System.out.println(x==z); // false</span><br><span class="line">System.out.println(x.equals(y)); // true</span><br><span class="line">System.out.println(x.equals(z)); // true</span><br></pre></td></tr></table></figure>

<p>代码解读：因为 x 和 y 指向的是同一个引用，所以 == 是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true</p>
</li>
</ul>
</li>
<li><p>equals 用来比较<strong>某些特征</strong>是否一样，本质上就是 == ，只不过String和Integer等重写了equals方法，把它变成了值比较。<br>首先看默认情况下equals比较一个有相同值的对象，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Cat &#123;</span><br><span class="line">    public Cat(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private String name;</span><br><span class="line"> </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Cat c1 = new Cat(&quot;王磊&quot;);</span><br><span class="line">Cat c2 = new Cat(&quot;王磊&quot;);</span><br><span class="line">System.out.println(c1.equals(c2)); // false</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">        return (this == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来 equals 本质上就是 ==。<br>那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = new String(&quot;老王&quot;);</span><br><span class="line">String s2 = new String(&quot;老王&quot;);</span><br><span class="line">System.out.println(s1.equals(s2)); // true</span><br></pre></td></tr></table></figure>

<p>同样的，当我们进入 String 的 equals方法，找到了答案，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">        if (this == anObject) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (anObject instanceof String) &#123;</span><br><span class="line">            String anotherString = (String)anObject;</span><br><span class="line">            int n = value.length;</span><br><span class="line">            if (n == anotherString.value.length) &#123;</span><br><span class="line">                char v1[] = value;</span><br><span class="line">                char v2[] = anotherString.value;</span><br><span class="line">                int i = 0;</span><br><span class="line">                while (n-- != 0) &#123;</span><br><span class="line">                    if (v1[i] != v2[i])</span><br><span class="line">                        return false;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。<br><strong>总结：</strong> == 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重写了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p>
<h3 id="String、StringBuffer和StringBuilder区别"><a href="#String、StringBuffer和StringBuilder区别" class="headerlink" title="String、StringBuffer和StringBuilder区别"></a>String、StringBuffer和StringBuilder区别</h3><ul>
<li><p>数据可变和不可变</p>
<ul>
<li>String底层使用一个不可变的字符数组<code>private final char value[]</code>，所以它的内容不可变</li>
<li>StringBuffer和StringBuilder都继承了AbstractStringBuilder底层使用的是可变字符数组：<code>char[] value;</code></li>
</ul>
</li>
<li><p>线程安全性</p>
<ul>
<li>StringBulider是线程不安全的，效率较高；而StringBuffer是线程安全的，效率较低；<br>通过他们的append()方法来看，SpringBuffer是有同步锁，而StringBuilder没有：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">	@Override</span><br><span class="line">public synchronized StringBuffer append(Object obj) &#123;</span><br><span class="line">    toStringCache = null;</span><br><span class="line">    super.append(String.valueOf(obj));</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public StringBuilder append(String str) &#123;</span><br><span class="line">    super.append(str);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>相同点<br>StringBuilder与StringBuffer有公共父类AbstractBuilder；<br>最后，操作可变字符串速度：<strong>StringBuilder &gt; StringBuffer &gt; String</strong>。</p>
</li>
</ul>
<h3 id="两个对象的-hashCode-相同，则equals-也一定为true，对吗？"><a href="#两个对象的-hashCode-相同，则equals-也一定为true，对吗？" class="headerlink" title="两个对象的 hashCode()相同，则equals()也一定为true，对吗？"></a>两个对象的 hashCode()相同，则equals()也一定为true，对吗？</h3><p>不对，两个对象的HashCode()相同，equals()不一定true。<br>代码示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;通话&quot;;</span><br><span class="line">String str2 = &quot;重地&quot;;</span><br><span class="line">System. out. println(String. format(&quot;str1：%d | str2：%d&quot;,  str1. hashCode(),str2. hashCode()));</span><br><span class="line">System. out. println(str1. equals(str2));</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1：1179395 | str2：1179395</span><br><span class="line"> </span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<p>代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p>
<h3 id="两个对象值相同-x-equals-y-true-，Hashcode是否一定相同"><a href="#两个对象值相同-x-equals-y-true-，Hashcode是否一定相同" class="headerlink" title="两个对象值相同(x.equals(y)==true)，Hashcode是否一定相同"></a>两个对象值相同(x.equals(y)==true)，Hashcode是否一定相同</h3><p>第一种情况：假如这个类没有重写equals方法，如果两个对象值相同，那么他们的hashCode值一定相同；<br>第二种情况：如果重写了equals方法，但没有重写hashCode方法，就会出现不相等的情况。<br><strong>Java对于equals方法和hashCode方法的规定</strong></p>
<ol>
<li>如果两个对象相同，那么他们的hashCode值一定要相同；</li>
<li>如果两个对象的hashCode相同，他们并不一定相同（这里说的对象相同指的是用equals方法比较）；</li>
<li>equals()相等的两个对象，hashCode()一定相等；equals()不相等的两个对象，却并不能证明他们的hashCode()不相等。<br>换句话说，equals()方法不相等的两个对象，hashCode()有可能相等（我的理解是由于哈希码在生成的时候产生冲突造成的）。反过来，hashCode()不等，一定能推出equals()也不等；hashCode()相等，equals()可能相等，也可能不等。</li>
</ol>
<h3 id="什么时候需要重写equals方法和hashCode方法"><a href="#什么时候需要重写equals方法和hashCode方法" class="headerlink" title="什么时候需要重写equals方法和hashCode方法"></a>什么时候需要重写equals方法和hashCode方法</h3><p>如果想完整的使用HashSet类(或TreeSet等)，最少需要重写equals()和hashCode()方法</p>
<ol>
<li>重写hashCode()用于获得元素的存储位置；</li>
<li>重写equals()用于在两个元素的位置相同的时候，比较两个元素是否相等。<br>分析原因如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hashCode </span><br><span class="line">        public int hashCode()返回该对象的哈希码值。支持此方法是为了提高哈希表（例如 Java.util.Hashtable 提供的哈希表）的性能。</span><br><span class="line">        hashCode 的常规协定是： </span><br><span class="line">        在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。 </span><br><span class="line">        如果根据 equals(Object) 方法，两个对象是相等的，那么对这两个对象中的每个对象调用 hashCode 方法都必须生成相同的整数结果。 </span><br><span class="line">        如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么对这两个对象中的任一对象上调用 hashCode 方法不 要求一定生成不同的整数结果。但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能。 </span><br><span class="line">        实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。）</span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">equals </span><br><span class="line">public boolean equals(Object obj)指示其他某个对象是否与此对象“相等”。 </span><br><span class="line">equals 方法在非空对象引用上实现相等关系： </span><br><span class="line"></span><br><span class="line">自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true。 </span><br><span class="line">对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。 </span><br><span class="line">传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。 </span><br><span class="line">一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。 </span><br><span class="line">对于任何非空引用值 x，x.equals(null) 都应返回 false。 </span><br><span class="line">Object 类的 equals 方法实现对象上差别可能性最大的相等关系；即，对于任何非空引用值 x 和 y，当且仅当 x 和 y 引用同一个对象时，此方法才返回 true（x == y 具有值 true）。</span><br></pre></td></tr></table></figure>

<h3 id="final在Java中有什么作用"><a href="#final在Java中有什么作用" class="headerlink" title="final在Java中有什么作用"></a>final在Java中有什么作用</h3><ol>
<li>修饰类，则该类不能被继承；</li>
<li>修饰方法，则该方法不能被重写；</li>
<li>修饰变量，修饰的变量叫常量，必须初始化，且初始化后值不能被修改。</li>
</ol>
<h3 id="static和final区别"><a href="#static和final区别" class="headerlink" title="static和final区别"></a>static和final区别</h3>
	<table>
  <tr>
    <th>关键词</th>
    <th>修饰对象</th>
    <th>影响</th>
  </tr>
  <tr>
    <td rowspan="3">final</td>
    <td>变量</td>
    <td>分配到常量池中，程序不可改变其值</td>
  </tr>
  <tr>
    <td>方法</td>
    <td>子类中将不能被重写</td>
  </tr>
  <tr>
    <td>类</td>
    <td>不能被继承</td>
  </tr>
  <tr>
    <td rowspan="3">static</td>
    <td>变量</td>
    <td>分配在<span style="color:rgb(253, 104, 100)">内存堆</span>上，引用都会指向这一地址而不会重新分配内存</td>
  </tr>
  <tr>
    <td>方法块</td>
    <td>虚拟机优先加载</td>
  </tr>
  <tr>
    <td>类</td>
    <td>可以直接通过类来调用而不需要new</td>
  </tr>
</table>


<h3 id="引用类型占用几个字节"><a href="#引用类型占用几个字节" class="headerlink" title="引用类型占用几个字节"></a>引用类型占用几个字节</h3><p>hotspot VM在64位平台上占8个字节，在32平台上占4个字节</p>
<h3 id="1-lt-3-quot-a-quot-quot-b-quot-3-4和-1-lt-3-quot-a-quot-quot-b-quot-3-4-区别"><a href="#1-lt-3-quot-a-quot-quot-b-quot-3-4和-1-lt-3-quot-a-quot-quot-b-quot-3-4-区别" class="headerlink" title="(1&lt;3)?&quot;a&quot;:&quot;b&quot;)+3+4和(1&lt;3)?&quot;a&quot;:&quot;b&quot;)+(3+4)区别"></a><code>(1&lt;3)?&quot;a&quot;:&quot;b&quot;)+3+4</code>和<code>(1&lt;3)?&quot;a&quot;:&quot;b&quot;)+(3+4)</code>区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(((1&lt;3)?&quot;a&quot;:&quot;b&quot;)+3+4);</span><br><span class="line">System.out.println(((1&lt;3)?&quot;a&quot;:&quot;b&quot;)+(3+4));</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a34</span><br><span class="line">a7</span><br></pre></td></tr></table></figure>

<h3 id="4-amp-5-4-5-4-amp-10-gt-gt-1各等于多少"><a href="#4-amp-5-4-5-4-amp-10-gt-gt-1各等于多少" class="headerlink" title="4&amp;5 4^5 4&amp;10&gt;&gt;1各等于多少"></a><code>4&amp;5</code> <code>4^5</code> <code>4&amp;10&gt;&gt;1</code>各等于多少</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 0100 &amp; 0101 = 0100 = 4</span><br><span class="line">System.out.println(4&amp;5);</span><br><span class="line">// 0100 ^ 0101 = 0001 = 1</span><br><span class="line">System.out.println(4^5);</span><br><span class="line">System.out.println(10&gt;&gt;1);</span><br><span class="line"> // 有疑问参考下面的运算符优先级</span><br><span class="line">System.out.println(4&amp;10&gt;&gt;1);</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">5</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>同问 <code>4|5</code>等于多少呢<br>答案为5<br>Tip：<br>与运算符用符号“&amp;”表示，其使用规律如下：<br>两个操作数中位都为1，结果才为1，否则结果为0<br>或运算符用符号“|”表示，其运算规律如下：<br>两个位只要有一个为1，那么结果就是1，否则就为0<br>3&amp;4相当于0011&amp;0100，结果是0000，也就是0<br>4|5相当于0100|0101，结果是0101，也就是5<br>java的位运算符还有两个：<br>非运算符用符号“~”表示，其运算规律如下：<br>如果位为0，结果是1，如果位为1，结果是0<br>异或运算符是用符号“^”表示的，其运算规律是：<br>两个操作数的位中，相同则结果为0，不同则结果为1</p>
<p>运算符优先级</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>结合性</th>
</tr>
</thead>
<tbody><tr>
<td>[ ] . ( ) (方法调用)</td>
<td>从左向右</td>
</tr>
<tr>
<td>! ~ ++ – +(一元运算) -(一元运算)</td>
<td>从右向左</td>
</tr>
<tr>
<td>* / %</td>
<td>从左向右</td>
</tr>
<tr>
<td>+ -</td>
<td>从左向右</td>
</tr>
<tr>
<td>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</td>
<td>从左向右</td>
</tr>
<tr>
<td>&lt; &lt;= &gt; &gt;= instanceof</td>
<td>从左向右</td>
</tr>
<tr>
<td>== !=</td>
<td>从左向右</td>
</tr>
<tr>
<td>&amp;</td>
<td>从左向右</td>
</tr>
<tr>
<td>^</td>
<td>从左向右</td>
</tr>
<tr>
<td>|</td>
<td>从左向右</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>从左向右</td>
</tr>
<tr>
<td>||</td>
<td>从左向右</td>
</tr>
<tr>
<td>?:</td>
<td>从右向左</td>
</tr>
<tr>
<td>=</td>
<td>从右向左</td>
</tr>
</tbody></table>
<h3 id="Java中-Math-round-1-5-等于多少？Math-round-2-5-等于多少？"><a href="#Java中-Math-round-1-5-等于多少？Math-round-2-5-等于多少？" class="headerlink" title="Java中 Math.round(-1.5)等于多少？Math.round(-2.5)等于多少？"></a>Java中 Math.round(-1.5)等于多少？Math.round(-2.5)等于多少？</h3><p>答案：-1，-2<br>注意：不要认为它是四舍五入<br>计算口诀：+0.5后向下取整即可<br>同理Math.round(-2.6)结果和Math.round(2.6)结果分别为-3，3</p>
<h3 id="抽象类必须要有抽象方法吗？"><a href="#抽象类必须要有抽象方法吗？" class="headerlink" title="抽象类必须要有抽象方法吗？"></a>抽象类必须要有抽象方法吗？</h3><p>不需要，抽象类不一定非要抽象方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abstract class Cat &#123;</span><br><span class="line">        public static void sayHi() &#123;</span><br><span class="line">            System. out. println(&quot;hi~&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="普通类和抽象类有哪些区别"><a href="#普通类和抽象类有哪些区别" class="headerlink" title="普通类和抽象类有哪些区别"></a>普通类和抽象类有哪些区别</h3><p>普通类不能包含抽象方法，抽象类可以包含抽象方法<br>抽象类不能直接实例化，普通类可以直接实例化</p>
<h3 id="抽象类能使用final修饰吗"><a href="#抽象类能使用final修饰吗" class="headerlink" title="抽象类能使用final修饰吗"></a>抽象类能使用final修饰吗</h3><p>不能，定义抽象类就是让其他类继承的，如果定义为final该类就不能被继承，这样彼此就会产生矛盾，所以final不能修饰抽象类。</p>
<h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><ul>
<li>实现：抽象类的子类使用extends来继承；接口必须使用implements来实现接口；</li>
<li>构造函数：抽象类有构造函数；接口不能有；</li>
<li>实现数量：类可以实现多个接口，但是只能继承一个抽象类；</li>
<li>访问修饰符：抽象类中的抽象方法(其前有abstract修饰)不能用private、static、synchronized、native访问修饰符修饰；接口中的方法默认使用 public 修饰，接口是一种特殊的抽象类，接口中的方法全部是抽象方法（但其前的abstract可以省略），所以抽象类中的抽象方法不能用的访问修饰符这里也不能用，而且protected访问修饰符也不能使用。</li>
</ul>
<h3 id="Java中IO流分为几种"><a href="#Java中IO流分为几种" class="headerlink" title="Java中IO流分为几种"></a>Java中IO流分为几种</h3><ul>
<li>按功能分：输入流（input）、输出流（output）</li>
<li>按类型分：字节流和字符流<br>  字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</li>
</ul>
<h3 id="BIO、NIO和AIO区别"><a href="#BIO、NIO和AIO区别" class="headerlink" title="BIO、NIO和AIO区别"></a>BIO、NIO和AIO区别</h3><ul>
<li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li>
<li>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li>
<li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li>
</ul>
<h3 id="Files常用方法有哪些"><a href="#Files常用方法有哪些" class="headerlink" title="Files常用方法有哪些"></a>Files常用方法有哪些</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Files. exists()：检测文件路径是否存在。</span><br><span class="line">Files. createFile()：创建文件。</span><br><span class="line">Files. createDirectory()：创建文件夹。</span><br><span class="line">Files. delete()：删除一个文件或目录。</span><br><span class="line">Files. copy()：复制文件。</span><br><span class="line">Files. move()：移动文件。</span><br><span class="line">Files. size()：查看文件个数。</span><br><span class="line">Files. read()：读取文件。</span><br><span class="line">Files. write()：写入文件。</span><br></pre></td></tr></table></figure>

<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="Java容器都有哪些"><a href="#Java容器都有哪些" class="headerlink" title="Java容器都有哪些"></a>Java容器都有哪些</h3><p>Java容器分为Collection和Map两大类，其下又有很多子类，如下所示：</p>
<ul>
<li>Collection<ul>
<li>List<ul>
<li>ArrayList</li>
<li>LinkedList</li>
<li>Vector</li>
<li>Stack</li>
</ul>
</li>
<li>Set<ul>
<li>HashSet</li>
<li>LinkedHashSet</li>
<li>TreeSet</li>
</ul>
</li>
</ul>
</li>
<li>Map<ul>
<li>HashMap<ul>
<li>LinkedHashMap</li>
</ul>
</li>
<li>TreeMap</li>
<li>ConcurrentHashMap</li>
<li>Hashtable</li>
</ul>
</li>
</ul>
<h3 id="简述Java中的集合"><a href="#简述Java中的集合" class="headerlink" title="简述Java中的集合"></a>简述Java中的集合</h3><ul>
<li>Collection下：List系（有序、元素允许重复）和Set系（无序、元素不重复）<br>  set根据equals和hashCode判断，一个对象要存储在Set中，必须重写equals和hashCode方法。</li>
<li>Map下：HashMap线程不同步；TreeMap线程同步；</li>
<li>Collection系列和Map系列：Map是对Colleciton的补充，两者没什么关系。</li>
</ul>
<h3 id="List、Set、Map之间的区别"><a href="#List、Set、Map之间的区别" class="headerlink" title="List、Set、Map之间的区别"></a>List、Set、Map之间的区别</h3><p>List、Set、Map之间的区别主要体现在两个方面：元素是否有序、是否允许元素重复<br>三者间的区别，如表所示：</p>

	<table>
  <tr>
    <th></th>
    <th></th>
    <th>元素有序</th>
    <th>允许元素重复</th>
  </tr>
  <tr>
    <td colspan="2">List</td>
    <td>是</td>
    <td>是</td>
  </tr>
  <tr>
    <td rowspan="3">Set</td>
    <td>AbstractSet</td>
    <td rowspan="2">否</td>
    <td rowspan="3">否</td>
  </tr>
  <tr>
    <td>HashSet</td>
  </tr>
  <tr>
    <td>TreeSet</td>
    <td>是（用二叉树排序）</td>
  </tr>
  <tr>
    <td rowspan="3">Map</td>
    <td>AbstractMap</td>
    <td rowspan="2">否</td>
    <td rowspan="3">key值必须唯一<br>value值可重复</td>
  </tr>
  <tr>
    <td>HashMap</td>
  </tr>
  <tr>
    <td>TreeMap</td>
    <td>是（用二叉树排序）</td>
  </tr>
</table>


<h3 id="HashMap、HashTable和ConcurrentHashMap区别"><a href="#HashMap、HashTable和ConcurrentHashMap区别" class="headerlink" title="HashMap、HashTable和ConcurrentHashMap区别"></a>HashMap、HashTable和ConcurrentHashMap区别</h3><p>相同点：<br>    1. HashMap和HashTable都实现了Map接口<br>    2. 都可以存储key-value数据<br>不同点：<br>    1. HashMap可以把null作为key或者value,HashTable不可以<br>    2. HashMap线程不安全，效率高，HashTable线程安全，效率低<br>    3. HashMap迭代器(Iterator)是fail-fast迭代器，而HashTable的enumerator迭代器不是fail-fast的<br>    什么是fail-fast?<br>      就是最快的时间能把错误抛出而不是让程序执行<br>    4. Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</p>
<h4 id="如何保证线程安全又效率高"><a href="#如何保证线程安全又效率高" class="headerlink" title="如何保证线程安全又效率高"></a>如何保证线程安全又效率高</h4><p>Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。ConcurrentHashMap将整个Map分为N个segment(类似HashTable)，可以提供相同的线程安全，但是效率提升N倍，默认N为16。</p>
<h4 id="我们能否让HashMap同步"><a href="#我们能否让HashMap同步" class="headerlink" title="我们能否让HashMap同步"></a>我们能否让HashMap同步</h4><p>HashMap可以通过下面语句进行同步</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map m = Collections.synchronizeMap(hashMap);</span><br></pre></td></tr></table></figure>

<h3 id="如何决定使用HashMap还是TreeMap"><a href="#如何决定使用HashMap还是TreeMap" class="headerlink" title="如何决定使用HashMap还是TreeMap"></a>如何决定使用HashMap还是TreeMap</h3><p>对于在 Map 中插入、删除、定位一个元素这类操作，HashMap是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。</p>
<h3 id="说一下-HashMap-的实现原理"><a href="#说一下-HashMap-的实现原理" class="headerlink" title="说一下 HashMap 的实现原理"></a>说一下 HashMap 的实现原理</h3><p>HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。</p>
<h3 id="说一下-HashSet-的实现原理"><a href="#说一下-HashSet-的实现原理" class="headerlink" title="说一下 HashSet 的实现原理"></a>说一下 HashSet 的实现原理</h3><p>HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，<strong>HashSet 不允许重复的值</strong>。</p>
<h3 id="ArrayList-和-LinkdList-区别"><a href="#ArrayList-和-LinkdList-区别" class="headerlink" title="ArrayList 和 LinkdList 区别"></a>ArrayList 和 LinkdList 区别</h3><ol>
<li>ArrayList的实现基于<strong>动态数组</strong>的数据结构，LinkedList基于<strong>链表</strong>的数据结构；</li>
<li>对于随机访问get和set，ArrayList优于LinkedList，因为LinkedList需要移动指针；</li>
<li>对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。<br>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</li>
</ol>
<h3 id="如何实现数组和-List-之间的转换"><a href="#如何实现数组和-List-之间的转换" class="headerlink" title="如何实现数组和 List 之间的转换"></a>如何实现数组和 List 之间的转换</h3><p>数组转 List：使用 Arrays. asList(array) 进行转换；<br>List 转数组：使用 List 自带的 toArray() 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// list to array</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">list. add(&quot;王磊&quot;);</span><br><span class="line">list. add(&quot;的博客&quot;);</span><br><span class="line">list. toArray();</span><br><span class="line">// array to list</span><br><span class="line">String[] array = new String[]&#123;&quot;王磊&quot;,&quot;的博客&quot;&#125;;</span><br><span class="line">Arrays. asList(array);</span><br></pre></td></tr></table></figure>

<h3 id="ArrayList-和-Vector-的区别"><a href="#ArrayList-和-Vector-的区别" class="headerlink" title="ArrayList 和 Vector 的区别"></a>ArrayList 和 Vector 的区别</h3><p>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的<br>性能：ArrayList 在性能方面要优于 Vector<br>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%</p>
<h3 id="Array-和-ArrayList-有何区别"><a href="#Array-和-ArrayList-有何区别" class="headerlink" title="Array 和 ArrayList 有何区别"></a>Array 和 ArrayList 有何区别</h3><p>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象;<br>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的;<br>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</p>
<h3 id="在-Queue-中-poll-和-remove-有什么区别"><a href="#在-Queue-中-poll-和-remove-有什么区别" class="headerlink" title="在 Queue 中 poll()和 remove()有什么区别"></a>在 Queue 中 poll()和 remove()有什么区别</h3><p>相同点：都是返回第一个元素，并在队列中删除返回的对象<br>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常<br>tip:</p>
<ol>
<li>queue的增加元素方法add和offer的区别在于，add方法在队列满的情况下将选择抛异常的方法来表示队列已经满了，而offer方法通过返回false表示队列已经满了；在有限队列的情况，使用offer方法优于add方法；</li>
<li>remove方法和poll方法都是删除队列的头元素，remove方法在队列为空的情况下将抛异常，而poll方法将返回null；</li>
<li>element和peek方法都是返回队列的头元素，但是不删除头元素，区别在与element方法在队列为空的情况下，将抛异常，而peek方法将返回null.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();</span><br><span class="line">queue. offer(&quot;string&quot;); // add</span><br><span class="line">System. out. println(queue. poll());</span><br><span class="line">System. out. println(queue. remove());</span><br><span class="line">System. out. println(queue. size());</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="哪些集合类是线程安全的"><a href="#哪些集合类是线程安全的" class="headerlink" title="哪些集合类是线程安全的"></a>哪些集合类是线程安全的</h3><p>Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK 1.5 之后随着 Java. util. concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。</p>
<h3 id="迭代器-Iterator-是什么"><a href="#迭代器-Iterator-是什么" class="headerlink" title="迭代器 Iterator 是什么"></a>迭代器 Iterator 是什么</h3><p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p>
<h3 id="Iterator-怎么使用？有什么特点？"><a href="#Iterator-怎么使用？有什么特点？" class="headerlink" title="Iterator 怎么使用？有什么特点？"></a>Iterator 怎么使用？有什么特点？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; it = list. iterator();</span><br><span class="line">while(it. hasNext())&#123;</span><br><span class="line">  String obj = it. next();</span><br><span class="line">  System. out. println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p>
<h3 id="ConcurrentModificationException异常出现的原因"><a href="#ConcurrentModificationException异常出现的原因" class="headerlink" title="ConcurrentModificationException异常出现的原因"></a>ConcurrentModificationException异常出现的原因</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        list.add(2);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">        while(iterator.hasNext())&#123;</span><br><span class="line">            Integer integer = iterator.next();</span><br><span class="line">            if(integer==2)</span><br><span class="line">                list.remove(integer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行上段代码是有问题的，会抛出ConcurrentModificationException异常。<br>原因：调用list.remove()方法导致modCount和expectedModCount的值不一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final void checkForComodification() &#123;</span><br><span class="line">    if (modCount != expectedModCount)</span><br><span class="line">    throw new ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决办法：在迭代器中如果要删除元素的话，需要调用Iterator类的remove方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        list.add(2);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">        while(iterator.hasNext())&#123;</span><br><span class="line">            Integer integer = iterator.next();</span><br><span class="line">            if(integer==2)</span><br><span class="line">                iterator.remove();   //注意这个地方</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="怎么确保一个集合不能被修改"><a href="#怎么确保一个集合不能被修改" class="headerlink" title="怎么确保一个集合不能被修改"></a>怎么确保一个集合不能被修改</h3><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来<strong>创建一个只读集合</strong>，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list. add(&quot;x&quot;);</span><br><span class="line">Collection&lt;String&gt; clist = Collections. unmodifiableCollection(list);</span><br><span class="line">clist. add(&quot;y&quot;); // 运行时此行报错</span><br><span class="line">System. out. println(list. size());</span><br></pre></td></tr></table></figure>

<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="并行和并发有什么区别"><a href="#并行和并发有什么区别" class="headerlink" title="并行和并发有什么区别"></a>并行和并发有什么区别</h3><ul>
<li>并行：多个处理器或多核处理器同时处理多个任务。</li>
<li>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。</li>
</ul>
<h3 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h3><p>一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</p>
<h3 id="守护线程是什么"><a href="#守护线程是什么" class="headerlink" title="守护线程是什么"></a>守护线程是什么</h3><p>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。</p>
<h3 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h3><p>常见回答</p>
<ul>
<li>继承 Thread 重写 run 方法；</li>
<li>实现 Runnable 接口；</li>
<li>实现 Callable 接口。</li>
</ul>
<p>下面做个较为全面的总结：</p>
<ol>
<li>继承Trhead类，作为线程对象存在（继承Thread对象）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class CreatThreadDemo1 extends Thread&#123;</span><br><span class="line">    /**</span><br><span class="line">     * 构造方法： 继承父类方法的Thread(String name)；方法</span><br><span class="line">     * @param name</span><br><span class="line">     */</span><br><span class="line">    public CreatThreadDemo1(String name)&#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (!interrupted())&#123;</span><br><span class="line">            System.out.println(getName()+&quot;线程执行了...&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(200);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CreatThreadDemo1 d1 = new CreatThreadDemo1(&quot;first&quot;);</span><br><span class="line">        CreatThreadDemo1 d2 = new CreatThreadDemo1(&quot;second&quot;);</span><br><span class="line"></span><br><span class="line">        d1.start();</span><br><span class="line">        d2.start();</span><br><span class="line"></span><br><span class="line">        d1.interrupt();  //中断第一个线程</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>常规方法，不多做介绍了，interrupted方法，是来判断该线程是否被中断。（终止线程不允许用stop方法，该方法不会施放占用的资源。所以我们在设计程序的时候，要按照中断线程的思维去设计，就像上面的代码一样）。</p>
<pre><code>* 让线程等待的方法
Thread.sleep(200);//线程休息2ms
Object.wait();//让线程进入等待，直到调用Object的notify或者notifyAll，线程停止休眠</code></pre><ol start="2">
<li>实现runnable接口，作为线程任务存在<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class CreatThreadDemo2 implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            System.out.println(&quot;线程执行了...&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //将线程任务传给线程对象</span><br><span class="line">        Thread thread = new Thread(new CreatThreadDemo2());</span><br><span class="line">        //启动线程</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>Runnable 只是来修饰线程所执行的任务，它不是一个线程对象。想要启动Runnable对象，必须将它放到一个线程对象里。</p>
<ol start="3">
<li>匿名内部类创建线程对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class CreatThreadDemo3 extends Thread&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建无参线程对象</span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;线程执行了...&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">       //创建带线程任务的线程对象</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;线程执行了...&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        //创建带线程任务并且重写run方法的线程对象</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;runnable run 线程执行了...&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;override run 线程执行了...&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>创建带线程任务并且重写run方法的线程对象中，为什么只运行了Thread的run方法。通过查看Thread类的源码，我们可以看到Thread实现了Runnable接口，而Runnable接口里有一个run方法。所以，我们最终调用的重写的方法应该是Thread类的run方法。而不是Runnable接口的run方法。</p>
<ol start="4">
<li>创建带返回值的线程（实现Callable接口）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class CreatThreadDemo4 implements Callable &#123;</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        CreatThreadDemo4 demo4 = new CreatThreadDemo4();</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;Integer&gt; task = new FutureTask&lt;Integer&gt;(demo4); //FutureTask最终实现的是runnable接口</span><br><span class="line"></span><br><span class="line">        Thread thread = new Thread(task);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;我可以在这里做点别的业务逻辑...因为FutureTask是提前完成任务&quot;);</span><br><span class="line">        //拿出线程执行的返回值</span><br><span class="line">        Integer result = task.get();</span><br><span class="line">        System.out.println(&quot;线程中运算的结果为:&quot;+result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //重写Callable接口的call方法</span><br><span class="line">    @Override</span><br><span class="line">    public Object call() throws Exception &#123;</span><br><span class="line">        int result = 1;</span><br><span class="line">        System.out.println(&quot;业务逻辑计算中...&quot;);</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>Callable接口介绍：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Computes a result, or throws an exception if unable to do so.</span><br><span class="line">     *</span><br><span class="line">     * @return computed result</span><br><span class="line">     * @throws Exception if unable to compute a result</span><br><span class="line">     */</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回指定泛型的call方法。然后调用FutureTask对象的get方法得到call方法的返回值。</p>
<ol start="5">
<li><p>定时器Timer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class CreatThreadDemo5 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Timer timer = new Timer();</span><br><span class="line"></span><br><span class="line">        timer.schedule(new TimerTask() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;定时器线程执行了...&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,0,1000);   //延迟0，周期1s</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程池创建线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class CreatThreadDemo6 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建一个具有10个线程的线程池</span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(10);</span><br><span class="line">        long threadpoolUseTime = System.currentTimeMillis();</span><br><span class="line">        for (int i = 0;i&lt;10;i++)&#123;</span><br><span class="line">            threadPool.execute(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot;线程执行了...&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        long threadpoolUseTime1 = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;多线程用时&quot;+(threadpoolUseTime1-threadpoolUseTime));</span><br><span class="line">        //销毁线程池</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        threadpoolUseTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用java8新特性stream实现并发</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class CreatThreadDemo7 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Integer&gt; values = Arrays.asList(10,20,30,40);</span><br><span class="line">        //parallel 平行的，并行的</span><br><span class="line">        int result = values.parallelStream().mapToInt(p -&gt; p*2).sum();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        //怎么证明它是并发处理呢</span><br><span class="line">        values.parallelStream().forEach(p-&gt; System.out.println(p));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">200</span><br><span class="line">40</span><br><span class="line">10</span><br><span class="line">20</span><br><span class="line">30</span><br></pre></td></tr></table></figure>

<h3 id="说一下runnable和callable区别"><a href="#说一下runnable和callable区别" class="headerlink" title="说一下runnable和callable区别"></a>说一下runnable和callable区别</h3><p>runnable 没有返回值，callable 可以拿到有返回值，callable 可以看作是 runnable 的补充。</p>
<h3 id="线程有哪些状态"><a href="#线程有哪些状态" class="headerlink" title="线程有哪些状态"></a>线程有哪些状态</h3><p>线程的状态：</p>
<ul>
<li>NEW 尚未启动</li>
<li>RUNNABLE 正在执行中</li>
<li>BLOCKED 阻塞的（被同步锁或者IO锁阻塞）</li>
<li>WAITING 永久等待状态</li>
<li>TIMED_WAITING 等待指定的时间重新被唤醒的状态</li>
<li>TERMINATED 执行完成</li>
</ul>
<h3 id="sleep-和-wait-有什么区别"><a href="#sleep-和-wait-有什么区别" class="headerlink" title="sleep() 和 wait() 有什么区别"></a>sleep() 和 wait() 有什么区别</h3><ul>
<li>类的不同：sleep() 来自 Thread，wait() 来自 Object。</li>
<li>释放锁：sleep() 不释放锁；wait() 释放锁。</li>
<li>用法不同：sleep() 时间到会自动恢复；wait() 可以使用notify()/notifyAll()直接唤醒。</li>
</ul>
<h3 id="notify-和-notifyAll-有什么区别"><a href="#notify-和-notifyAll-有什么区别" class="headerlink" title="notify()和 notifyAll()有什么区别"></a>notify()和 notifyAll()有什么区别</h3><p>notifyAll()会唤醒所有的线程，notify()只唤醒一个线程。notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</p>
<h3 id="线程的-run-和-start-有什么区别"><a href="#线程的-run-和-start-有什么区别" class="headerlink" title="线程的 run() 和 start() 有什么区别"></a>线程的 run() 和 start() 有什么区别</h3><p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</p>
<h3 id="创建线程池有哪几种方式？"><a href="#创建线程池有哪几种方式？" class="headerlink" title="创建线程池有哪几种方式？"></a>创建线程池有哪几种方式？</h3><p>线程池创建有七种方式，最核心的是最后一种：</p>
<ul>
<li>newSingleThreadExecutor()：它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；</li>
<li>newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过  60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；</li>
<li>newFixedThreadPool(int  nThreads)：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads  个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目  nThreads；</li>
<li>newSingleThreadScheduledExecutor()：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；</li>
<li>newScheduledThreadPool(int  corePoolSize)：和newSingleThreadScheduledExecutor()类似，创建的是个  ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；</li>
<li>newWorkStealingPool(int parallelism)：这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；</li>
<li>ThreadPoolExecutor()：是最原始的线程池创建，上面1-3创建方式都是对ThreadPoolExecutor的封装。</li>
</ul>
<p>常用为Executors提供的四种方法来创建线程池：</p>
<ol>
<li><p>newFixedThreadPool() :创建固定大小的线程池。</p>
</li>
<li><p>newCachedThreadPool(): 创建无限大小的线程池，线程池中线程数量不固定，可根据需求自动更改。</p>
</li>
<li><p>newSingleThreadPool() : 创建单个线程池，线程池中只有一个线程。</p>
</li>
<li><p>newScheduledThreadPool(): 创建固定大小的线程池，可以延迟或定时的执行任务。<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ExecutorService threadPool = Executors.newCachedThreadPool();</span><br><span class="line">    threadPool.execute(() -&gt; &#123;</span><br><span class="line">        for (int i = 0; i&lt; 20;i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    threadPool.shutdown();</span><br></pre></td></tr></table></figure>

<p> 线程池作用<br> 限制线程个数，避免线程过多导致系统运行缓慢或崩溃。<br> 不需要频繁的创建和销毁，节约资源、响应更快。</p>
</li>
</ol>
<h3 id="线程池都有哪些状态？"><a href="#线程池都有哪些状态？" class="headerlink" title="线程池都有哪些状态？"></a>线程池都有哪些状态？</h3><ul>
<li>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。</li>
<li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。</li>
<li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</li>
<li>TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。</li>
<li>TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</li>
</ul>
<h3 id="线程池中-submit-和-execute-方法有什么区别？"><a href="#线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="线程池中 submit() 和 execute() 方法有什么区别？"></a>线程池中 submit() 和 execute() 方法有什么区别？</h3><ul>
<li>execute()：只能执行 Runnable 类型的任务。</li>
<li>submit()：可以执行 Runnable 和 Callable 类型的任务。</li>
</ul>
<p>Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。</p>
<h3 id="在-Java-程序中怎么保证多线程的运行安全"><a href="#在-Java-程序中怎么保证多线程的运行安全" class="headerlink" title="在 Java 程序中怎么保证多线程的运行安全"></a>在 Java 程序中怎么保证多线程的运行安全</h3><ul>
<li>方法一：使用安全类，比如 Java. util. concurrent 下的类。</li>
<li>方法二：使用自动锁 synchronized。</li>
<li>方法三：使用手动锁 Lock。</li>
</ul>
<p>手动锁 Java 示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line">lock. lock();</span><br><span class="line">try &#123;</span><br><span class="line">    System. out. println(&quot;获得锁&quot;);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    // TODO: handle exception</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    System. out. println(&quot;释放锁&quot;);</span><br><span class="line">    lock. unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多线程中-synchronized-锁升级的原理是什么"><a href="#多线程中-synchronized-锁升级的原理是什么" class="headerlink" title="多线程中 synchronized 锁升级的原理是什么"></a>多线程中 synchronized 锁升级的原理是什么</h3><p>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p>
<p>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p>
<h3 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h3><p>当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p>
<h3 id="怎么防止死锁？"><a href="#怎么防止死锁？" class="headerlink" title="怎么防止死锁？"></a>怎么防止死锁？</h3><ul>
<li>尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。</li>
<li>尽量使用 Java. util. concurrent 并发类代替自己手写锁。</li>
<li>尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。</li>
<li>尽量减少同步的代码块</li>
</ul>
<h3 id="ThreadLocal-是什么？有哪些使用场景？"><a href="#ThreadLocal-是什么？有哪些使用场景？" class="headerlink" title="ThreadLocal 是什么？有哪些使用场景？"></a>ThreadLocal 是什么？有哪些使用场景？</h3><p>ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。<br>ThreadLocal 的经典使用场景是数据库连接和 session 管理等。</p>
<h3 id="说一下-synchronized-底层实现原理？"><a href="#说一下-synchronized-底层实现原理？" class="headerlink" title="说一下 synchronized 底层实现原理？"></a>说一下 synchronized 底层实现原理？</h3><p>synchronized 是由一对 monitorenter/monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在 Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能</p>
<h3 id="synchronized-和-volatile-的区别是什么？"><a href="#synchronized-和-volatile-的区别是什么？" class="headerlink" title="synchronized 和 volatile 的区别是什么？"></a>synchronized 和 volatile 的区别是什么？</h3><ul>
<li>volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。</li>
<li>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。</li>
<li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li>
</ul>
<h3 id="synchronized-和-Lock-有什么区别？"><a href="#synchronized-和-Lock-有什么区别？" class="headerlink" title="synchronized 和 Lock 有什么区别？"></a>synchronized 和 Lock 有什么区别？</h3><ul>
<li>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</li>
<li>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</li>
<li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li>
</ul>
<h3 id="synchronized-和-ReentrantLock-区别是什么？"><a href="#synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="synchronized 和 ReentrantLock 区别是什么？"></a>synchronized 和 ReentrantLock 区别是什么？</h3><p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进</p>
<p>主要区别如下：</p>
<ul>
<li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</li>
<li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li>
<li>ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。</li>
<li>volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。</li>
</ul>
<h3 id="说一下-atomic-的原理？"><a href="#说一下-atomic-的原理？" class="headerlink" title="说一下 atomic 的原理？"></a>说一下 atomic 的原理？</h3><p>atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><p>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p>
<h3 id="什么是-Java-序列化？什么情况下需要序列化？"><a href="#什么是-Java-序列化？什么情况下需要序列化？" class="headerlink" title="什么是 Java 序列化？什么情况下需要序列化？"></a>什么是 Java 序列化？什么情况下需要序列化？</h3><p>Java 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。<br>以下情况需要使用 Java 序列化：</p>
<ul>
<li>想把的内存中的对象状态保存到一个文件中或者数据库中时候；</li>
<li>想用套接字在网络上传送对象的时候；</li>
<li>想通过RMI（远程方法调用）传输对象的时候。</li>
</ul>
<h3 id="某些java类为什么要实现Serializable接口"><a href="#某些java类为什么要实现Serializable接口" class="headerlink" title="某些java类为什么要实现Serializable接口"></a>某些java类为什么要实现Serializable接口</h3><p>为了网络进行传输或者持久化</p>
<ul>
<li>除了实现Serializable接口还有什么序列化方式<ul>
<li>Json序列化</li>
<li>FastJson序列化</li>
<li>ProtoBuff序列化</li>
</ul>
</li>
</ul>
<h3 id="动态代理是什么？有哪些应用？"><a href="#动态代理是什么？有哪些应用？" class="headerlink" title="动态代理是什么？有哪些应用？"></a>动态代理是什么？有哪些应用？</h3><p>动态代理是运行时动态生成代理类。<br>动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端 mock、rpc，Java注解对象获取等。</p>
<h3 id="怎么实现动态代理？"><a href="#怎么实现动态代理？" class="headerlink" title="怎么实现动态代理？"></a>怎么实现动态代理？</h3><p>JDK 原生动态代理和 cglib 动态代理。JDK 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的。</p>
<h2 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h2><h3 id="为什么要使用克隆"><a href="#为什么要使用克隆" class="headerlink" title="为什么要使用克隆"></a>为什么要使用克隆</h3><p>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠克隆方法了。</p>
<h3 id="如何实现对象克隆"><a href="#如何实现对象克隆" class="headerlink" title="如何实现对象克隆"></a>如何实现对象克隆</h3><ul>
<li>实现 Cloneable 接口并重写 Object 类中的 clone() 方法。</li>
<li>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</li>
</ul>
<h3 id="深拷贝和浅拷贝区别是什么"><a href="#深拷贝和浅拷贝区别是什么" class="headerlink" title="深拷贝和浅拷贝区别是什么"></a>深拷贝和浅拷贝区别是什么</h3><ul>
<li>浅克隆：当对象被复制时只复制它本身和其中包含的值类型的成员变量，而<strong>引用类型</strong>的成员对象并没有复制。</li>
<li>深克隆：除了对象本身被复制外，对象所包含的所有成员变量也将复制</li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="throw-和-throws-的区别"><a href="#throw-和-throws-的区别" class="headerlink" title="throw 和 throws 的区别"></a>throw 和 throws 的区别</h3><ul>
<li>throw：是真实抛出一个异常。</li>
<li>throws：是声明可能会抛出一个异常。</li>
</ul>
<h3 id="final、finally、finalize-有什么区别？"><a href="#final、finally、finalize-有什么区别？" class="headerlink" title="final、finally、finalize 有什么区别？"></a>final、finally、finalize 有什么区别？</h3><ul>
<li>final：是修饰符，如果修饰类，此类不能被继承；如果修饰方法和变量，则表示此方法和此变量不能再被改变，只能使用。</li>
<li>finally：是 try{} catch{} finally{} 最后一部分，表示不论发生任何情况都会执行，finally 部分可以省略，但如果 finally 部分存在，则一定会执行 finally 里面的代码。</li>
<li>finalize： 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法。</li>
</ul>
<h3 id="try-catch-finally-中哪个部分可以省略"><a href="#try-catch-finally-中哪个部分可以省略" class="headerlink" title="try-catch-finally 中哪个部分可以省略"></a>try-catch-finally 中哪个部分可以省略</h3><p>try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。</p>
<h3 id="try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？"><a href="#try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？" class="headerlink" title="try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？"></a>try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h3><p>finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。</p>
<h3 id="常见的异常类有哪些？"><a href="#常见的异常类有哪些？" class="headerlink" title="常见的异常类有哪些？"></a>常见的异常类有哪些？</h3><ul>
<li>NullPointerException 空指针异常</li>
<li>ClassNotFoundException 指定类不存在</li>
<li>NumberFormatException 字符串转换为数字异常</li>
<li>IndexOutOfBoundsException 数组下标越界异常</li>
<li>ClassCastException 数据类型转换异常</li>
<li>FileNotFoundException 文件未找到异常</li>
<li>NoSuchMethodException 方法不存在异常</li>
<li>IOException IO 异常</li>
<li>SocketException Socket 异常</li>
</ul>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="说一下你熟悉的设计模式"><a href="#说一下你熟悉的设计模式" class="headerlink" title="说一下你熟悉的设计模式"></a>说一下你熟悉的设计模式</h3><ul>
<li>单例模式：保证被创建一次，节省系统开销。</li>
<li>工厂模式（简单工厂、抽象工厂）：解耦代码。</li>
<li>观察者模式：定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新。</li>
<li>外观模式：提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。</li>
<li>模版方法模式：定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。</li>
<li>状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</li>
</ul>
<h3 id="简单工厂、工程方法和抽象工厂有什么区别？"><a href="#简单工厂、工程方法和抽象工厂有什么区别？" class="headerlink" title="简单工厂、工程方法和抽象工厂有什么区别？"></a>简单工厂、工程方法和抽象工厂有什么区别？</h3><ul>
<li>简单工厂：用来生产同一等级结构中的任意产品，对于增加新的产品，无能为力。</li>
<li>工厂方法：用来生产同一等级结构中的固定产品，支持增加任意产品。</li>
<li>抽象工厂：用来生产不同产品族的全部产品，对于增加新的产品，无能为力；支持增加产品族。</li>
</ul>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="说一下-JVM-的主要组成部分？及其作用？"><a href="#说一下-JVM-的主要组成部分？及其作用？" class="headerlink" title="说一下 JVM 的主要组成部分？及其作用？"></a>说一下 JVM 的主要组成部分？及其作用？</h3><ul>
<li>类加载器（ClassLoader）</li>
<li>运行时数据区（Runtime Data Area）</li>
<li>执行引擎（Execution Engine）</li>
<li>本地库接口（Native Interface）</li>
</ul>
<p><strong>组件的作用：</strong> 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p>
<h3 id="说一下-JVM-运行时数据区？"><a href="#说一下-JVM-运行时数据区？" class="headerlink" title="说一下 JVM 运行时数据区？"></a>说一下 JVM 运行时数据区？</h3><p>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：</p>
<ul>
<li>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；</li>
<li>Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；</li>
<li>本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；</li>
<li>Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；</li>
<li>方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</li>
</ul>
<h3 id="说一下堆栈的区别？"><a href="#说一下堆栈的区别？" class="headerlink" title="说一下堆栈的区别？"></a>说一下堆栈的区别？</h3><ul>
<li>功能方面：堆是用来存放对象的，栈是用来执行程序的。</li>
<li>共享性：堆是线程共享的，栈是线程私有的。</li>
<li>空间大小：堆大小远远大于栈。</li>
</ul>
<h3 id="队列和栈是什么？有什么区别？"><a href="#队列和栈是什么？有什么区别？" class="headerlink" title="队列和栈是什么？有什么区别？"></a>队列和栈是什么？有什么区别？</h3><p>队列和栈都是被用来预存储数据的。</p>
<p>队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。</p>
<p>栈和队列很相似，但它运行对元素进行后进先出进行检索。</p>
<h3 id="说一下类装载的执行过程？"><a href="#说一下类装载的执行过程？" class="headerlink" title="说一下类装载的执行过程？"></a>说一下类装载的执行过程？</h3><p>类装载分为以下 5 个步骤：</p>
<ul>
<li>加载：根据查找路径找到相应的 class 文件然后导入；</li>
<li>检查：检查加载的 class 文件的正确性；</li>
<li>准备：给类中的静态变量分配内存空间；</li>
<li>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li>
<li>初始化：对静态变量和静态代码块执行初始化工作。</li>
</ul>
<h3 id="怎么判断对象是否可以被回收？"><a href="#怎么判断对象是否可以被回收？" class="headerlink" title="怎么判断对象是否可以被回收？"></a>怎么判断对象是否可以被回收？</h3><p>一般有两种方法来判断：</p>
<ul>
<li>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</li>
<li>可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</li>
</ul>
<h3 id="Java-中都有哪些引用类型？"><a href="#Java-中都有哪些引用类型？" class="headerlink" title="Java 中都有哪些引用类型？"></a>Java 中都有哪些引用类型？</h3><ul>
<li>强引用：发生 gc 的时候不会被回收。</li>
<li>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。</li>
<li>弱引用：有用但不是必须的对象，在下一次GC时会被回收。</li>
<li>虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。</li>
</ul>
<h3 id="JVM垃圾处理方法"><a href="#JVM垃圾处理方法" class="headerlink" title="JVM垃圾处理方法"></a>JVM垃圾处理方法</h3><ol>
<li>标记-清除算法（老年代）<br>该算法分为“标记”和“清除”两个阶段: 首先标记出所有需要回收的对象(可达性分析), 在标记完成后统一清理掉所有被标记的对象。<br><img src="/images/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.webp" alt="标记清除算法"><br>该算法会有两个问题：<ol>
<li>效率问题，标记和清除效率不高。</li>
<li>空间问题: 标记清除后会产生大量不连续的内存碎片, 空间碎片太多可能会导致在运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集。<br>所以它一般用于”垃圾不太多的区域，比如老年代”。</li>
</ol>
</li>
<li>复制算法（新生代）<br>该算法的核心是将可用内存按容量划分为大小相等的两块, 每次只用其中一块, 当这一块的内存用完, 就将还存活的对象（非垃圾）复制到另外一块上面, 然后把已使用过的内存空间一次清理掉。<br>优点：不用考虑碎片问题，方法简单高效。<br>缺点：内存浪费严重。</li>
</ol>
<p>现代商用VM的新生代均采用复制算法，但由于新生代中的98%的对象都是生存周期极短的，因此并不需完全按照1∶1的比例划分新生代空间，而是将新生代划分为一块较大的Eden区和两块较小的Survivor区(HotSpot默认Eden和Survivor的大小比例为8∶1), 每次只用Eden和其中一块Survivor。<br>当发生MinorGC时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor上， 最后清理掉Eden和刚才用过的Survivor的空间。当Survivor空间不够用(不足以保存尚存活的对象)时，需要依赖老年代进行空间分配担保机制，这部分内存直接进入老年代。<br><img src="/images/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.webp" alt="复制算法"><br><strong>复制算法的空间分配担保：</strong><br>在执行Minor GC前, VM会首先检查老年代是否有足够的空间存放新生代尚存活对象, 由于新生代使用复制收集算法, 为了提升内存利用率, 只使用了其中一个Survivor作为轮换备份, 因此当出现大量对象在Minor GC后仍然存活的情况时, 就需要老年代进行分配担保, 让Survivor无法容纳的对象直接进入老年代, 但前提是老年代需要有足够的空间容纳这些存活对象.<br>但存活对象的大小在实际完成GC前是无法明确知道的, 因此Minor GC前, VM会先首先检查老年代连续空间是否大于新生代对象总大小或历次晋升的平均大小, 如果条件成立, 则进行Minor GC, 否则进行Full GC(让老年代腾出更多空间).<br>然而取历次晋升的对象的平均大小也是有一定风险的, 如果某次Minor GC存活后的对象突增,远远高于平均值的话,依然可能导致担保失败(Handle Promotion Failure, 老年代也无法存放这些对象了), 此时就只好在失败后重新发起一次Full GC(让老年代腾出更多空间).</p>
<ol start="3">
<li>标记-整理算法（老年代）<br>标记清除算法会产生内存碎片问题, 而复制算法需要有额外的内存担保空间, 于是针对老年代的特点, 又有了标记整理算法. 标记整理算法的标记过程与标记清除算法相同, 但后续步骤不再对可回收对象直接清理, 而是让所有存活的对象都向一端移动,然后清理掉端边界以外的内存。<br><img src="/images/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.webp" alt="标记整理算法"><br>简记：</li>
</ol>
<ul>
<li>标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。</li>
<li>标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</li>
<li>复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。</li>
<li>分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</li>
</ul>
<h3 id="说一下-JVM-有哪些垃圾回收器？"><a href="#说一下-JVM-有哪些垃圾回收器？" class="headerlink" title="说一下 JVM 有哪些垃圾回收器？"></a>说一下 JVM 有哪些垃圾回收器？</h3><ul>
<li>Serial：最早的单线程串行垃圾回收器。</li>
<li>Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。</li>
<li>ParNew：是 Serial 的多线程版本。</li>
<li>Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。</li>
<li>Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。</li>
<li>CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。</li>
<li>G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。</li>
</ul>
<h3 id="详细介绍一下-CMS-垃圾回收器？"><a href="#详细介绍一下-CMS-垃圾回收器？" class="headerlink" title="详细介绍一下 CMS 垃圾回收器？"></a>详细介绍一下 CMS 垃圾回收器？</h3><p>CMS 是英文 Concurrent Mark-Sweep  的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM  的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。</p>
<p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现  Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p>
<h3 id="新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"><a href="#新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？" class="headerlink" title="新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"></a>新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</h3><ul>
<li>新生代回收器：Serial、ParNew、Parallel Scavenge</li>
<li>老年代回收器：Serial Old、Parallel Old、CMS</li>
<li>整堆回收器：G1<br>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</li>
</ul>
<h3 id="新生代、老年代、持久代都存储哪些东西"><a href="#新生代、老年代、持久代都存储哪些东西" class="headerlink" title="新生代、老年代、持久代都存储哪些东西"></a>新生代、老年代、持久代都存储哪些东西</h3><ul>
<li>新生代：<br>方法中new一个对象，就会先进入新生代。</li>
<li>老年代：<br>新生代中经历了N次垃圾回收仍然存活的对象就会被放到老年代中。<br>大对象一般直接放入老年代。<br>当Survivor空间不足。需要老年代担保一些空间，也会将对象放入老年代。</li>
<li>永久代：<br>指的就是方法区。</li>
</ul>
<h3 id="可达性算法中，哪些对象可作为GC-Roots对象"><a href="#可达性算法中，哪些对象可作为GC-Roots对象" class="headerlink" title="可达性算法中，哪些对象可作为GC Roots对象"></a>可达性算法中，哪些对象可作为GC Roots对象</h3><ul>
<li>虚拟机栈中引用的对象</li>
<li>方法区静态成员引用的对象</li>
<li>方法区常量引用对象</li>
<li>本地方法栈JNI引用的对象</li>
</ul>
<h3 id="什么时候进行MinGC和FullGC"><a href="#什么时候进行MinGC和FullGC" class="headerlink" title="什么时候进行MinGC和FullGC"></a>什么时候进行MinGC和FullGC</h3><ul>
<li>MinGC:<br>当Eden区满时,触发Minor GC.</li>
<li>FullGC:<br>调用System.gc时，系统建议执行Full GC，但是不必然执行<br>老年代空间不足<br>方法区空间不足<br>通过Minor GC后进入老年代的平均大小大于老年代的剩余空间<br>堆中分配很大的对象，而老年代没有足够的空间</li>
</ul>
<h3 id="如何判定对象为垃圾对象"><a href="#如何判定对象为垃圾对象" class="headerlink" title="如何判定对象为垃圾对象"></a>如何判定对象为垃圾对象</h3><p>在堆里面存放着Java世界中几乎所有的对象实例, 垃圾收集器在对堆进行回收前, 第一件事就是判断哪些对象已死(可回收).</p>
<ul>
<li><strong>引用计数法</strong><br>在JDK1.2之前，使用的是引用计数器算法。<br>在对象中添加一个引用计数器，当有地方引用这个对象的时候，引用计数器的值就+1，当引用失效的时候，计数器的值就-1，当引用计数器被减为零的时候，标志着这个对象已经没有引用了，可以回收了！<br><img src="/images/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95.webp" alt="引用计数法"></li>
</ul>
<p><strong>问题：</strong>如果在A类中调用B类的方法，B类中调用A类的方法，这样当其他所有的引用都消失了之后，A和B还有一个相互的引用，也就是说两个对象的引用计数器各为1，而实际上这两个对象都已经没有额外的引用，已经是垃圾了。但是该算法并不会计算出该类型的垃圾。</p>
<ul>
<li><strong>可达性分析法</strong><br>在主流商用语言(如Java、C#)的主流实现中, 都是通过可达性分析算法来判定对象是否存活的: 通过一系列的称为 GC Roots 的对象作为起点, 然后向下搜索; 搜索所走过的路径称为引用链/Reference Chain, 当一个对象到 GC Roots 没有任何引用链相连时, 即该对象不可达, 也就说明此对象是不可用的, 如下图:虽然E和F相互关联， 但它们到GC Roots是不可达的, 因此也会被判定为可回收的对象。<br><img src="/images/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E6%B3%95.webp" alt="可达性分析法"></li>
</ul>
<p><strong>注:</strong>即使在可达性分析算法中不可达的对象, VM也并不是马上对其回收, 因为要真正宣告一个对象死亡, 至少要经历两次标记过程: 第一次是在可达性分析后发现没有与GC Roots相连接的引用链, 第二次是GC对在F-Queue执行队列中的对象进行的小规模标记(对象需要覆盖finalize()方法且没被调用过).</p>
<h3 id="你能说出来几个垃圾收集器"><a href="#你能说出来几个垃圾收集器" class="headerlink" title="你能说出来几个垃圾收集器"></a>你能说出来几个垃圾收集器</h3><ul>
<li><p><strong>Serial</strong><br>Serial收集器是Hotspot运行在Client模式下的<strong>默认新生代收集器</strong>, 它在进行垃圾收集时，会暂停所有的工作进程，用一个线程去完成GC工作<br><img src="/images/serial.webp" alt="serial"><br>特点：简单高效，适合jvm管理内存不大的情况（十兆到百兆）。</p>
</li>
<li><p>Parnew<br>ParNew收集器其实是Serial的多线程版本，回收策略完全一样，但是他们又有着不同。<br><img src="/images/parnew.webp" alt="parnew"><br>我们说了Parnew是多线程gc收集，所以它配合多核心的cpu效果更好，如果是一个cpu，他俩效果就差不多。（可用-XX:ParallelGCThreads参数控制GC线程数）</p>
</li>
<li><p>CMS<br>CMS(Concurrent Mark Sweep)收集器是一款具有划时代意义的收集器, 一款<strong>真正意义上的并发收集器</strong>, 虽然现在已经有了理论意义上表现更好的G1收集器, 但现在主流互联网企业线上选用的仍是CMS(如Taobao),又称多并发低暂停的收集器。<br><img src="/images/cms.webp" alt="cms"><br>由他的英文组成可以看出，它是基于标记-清除算法实现的。整个过程分4个步骤：</p>
<ol>
<li>初始标记(CMS initial mark):仅只标记一下GC Roots能直接关联到的对象, 速度很快</li>
<li>并发标记(CMS concurrent mark: GC Roots Tracing过程)</li>
<li>重新标记(CMS remark):修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录</li>
<li>并发清除(CMS concurrent sweep: 已死对象将会就地释放)<br>可以看到，初始标记、重新标记需要STW(stop the world 即：挂起用户线程)操作。因为最耗时的操作是并发标记和并发清除。所以总体上我们认为CMS的GC与用户线程是并发运行的。</li>
</ol>
</li>
</ul>
<p><strong>优点：</strong>并发收集、低停顿<br><strong>缺点：</strong></p>
<ol>
<li>CMS默认启动的回收线程数=(CPU数目+3)*4<br>当CPU数&gt;4时, GC线程最多占用不超过25%的CPU资源, 但是当CPU数&lt;=4时, GC线程可能就会过多的占用用户CPU资源, 从而导致应用程序变慢, 总吞吐量降低.</li>
<li>无法清除浮动垃圾（GC运行到并发清除阶段时用户线程产生的垃圾），因为用户线程是需要内存的，如果浮动垃圾施放不及时，很可能就造成内存溢出，所以CMS不能像别的垃圾收集器那样等老年代几乎满了才触发，CMS提供了参数-XX:CMSInitiatingOccupancyFraction来设置GC触发百分比(1.6后默认92%),当然我们还得设置启用该策略-XX:+UseCMSInitiatingOccupancyOnly</li>
<li>因为CMS采用标记-清除算法，所以可能会带来很多的碎片，如果碎片太多没有清理，jvm会因为无法分配大对象内存而触发GC，因此CMS提供了-XX:+UseCMSCompactAtFullCollection参数，它会在GC执行完后接着进行碎片整理，但是又会有个问题，碎片整理不能并发，所以必须单线程去处理，所以如果每次GC完都整理用户线程stop的时间累积会很长，所以XX:CMSFullGCsBeforeCompaction参数设置隔几次GC进行一次碎片整理（默认为0）。</li>
</ol>
<ul>
<li>G1<br>同优秀的CMS垃圾回收器一样，G1也是关注最小时延的垃圾回收器，也同样适合大尺寸堆内存的垃圾收集，官方也推荐使用G1来代替选择CMS。G1最大的特点是<strong>引入分区</strong>的思路，<strong>弱化分代</strong>的概念，合理利用垃圾收集各个周期的资源，解决了其他收集器甚至CMS的众多缺陷。<br><img src="/images/g1.webp" alt="g1"><br>因为每个区都有E、S、O代，所以在G1中，不需要对整个Eden等代进行回收，而是寻找可回收对象比较多的区，然后进行回收（虽然也需要STW操作，但是花费的时间是很少的），保证高效率。<br>新生代收集<br>G1的新生代收集跟ParNew类似，如果存活时间超过某个阈值，就会被转移到S/O区。<br>年轻代内存由一组不连续的heap区组成, 这种方法使得可以动态调整各代区域的大小<br>老年代收集<br>分为以下几个阶段：<ol>
<li>初始标记 (Initial Mark: Stop the World Event)<br>在G1中, 该操作附着一次年轻代GC, 以标记Survivor中有可能引用到老年代对象的Regions.</li>
<li>扫描根区域 (Root Region Scanning: 与应用程序并发执行)<br>扫描Survivor中能够引用到老年代的references. 但必须在Minor GC触发前执行完</li>
<li>并发标记 (Concurrent Marking : 与应用程序并发执行)<br>在整个堆中查找存活对象, 但该阶段可能会被Minor GC中断</li>
<li>重新标记 (Remark : Stop the World Event)<br>完成堆内存中存活对象的标记. 使用snapshot-at-the-beginning(SATB, 起始快照)算法, 比CMS所用算法要快得多(空Region直接被移除并回收, 并计算所有区域的活跃度).</li>
<li>清理 (Cleanup : Stop the World Event and Concurrent)<br>在含有存活对象和完全空闲的区域上进行统计(STW)、擦除Remembered Sets(使用Remembered Set来避免扫描全堆，每个区都有对应一个Set用来记录引用信息、读写操作记录)(STW)、重置空regions并将他们返还给空闲列表(free list)(Concurrent)</li>
</ol>
</li>
</ul>
<h3 id="JVM中对象的创建过程"><a href="#JVM中对象的创建过程" class="headerlink" title="JVM中对象的创建过程"></a>JVM中对象的创建过程</h3><ol>
<li>拿到内存创建指令<br>当虚拟机遇到内存创建的指令的时候（new 类名），来到了方法区，根据new的参数在常量池中定位一个类的符号引用。</li>
<li>检查符号引用<br>检查该符号引用有没有被加载、解析和初始化过，如果没有则执行类加载过程，否则直接准备为新的对象分配内存</li>
<li>分配内存<br>虚拟机为对象分配内存（堆）分配内存分为指针碰撞和空闲列表两种方式；分配内存还要要保证并发安全，有两种方式。<ul>
<li>指针碰撞<br>所有的存储空间分为两部分，一部分是空闲，一部分是占用，需要分配空间的时候，只需要计算指针移动的长度即可。</li>
<li>空闲列表<br>虚拟机维护了一个空闲列表，需要分配空间的时候去查该空闲列表进行分配并对空闲列表做更新。<br>可以看出，内存分配方式是由java堆是否规整决定的，java堆的规整是由垃圾回收机制来决定的<br>安全性问题的思考<br>假如分配内存策略是指针碰撞，如果在高并发情况下，多个对象需要分配内存，如果不做处理，肯定会出现线程安全问题，导致一些对象分配不到空间等。<br>下面是解决方案：</li>
<li>线程同步策略<br>也就是每个线程都进行同步，防止出现线程安全。</li>
<li>本地线程分配缓冲<br>也称TLAB（Thread Local Allocation Buffer），在堆中为每一个线程分配一小块独立的内存，这样以来就不存并发问题了，Java 层面与之对应的是 ThreadLocal 类的实现</li>
</ul>
</li>
<li>初始化<br>分配完内存后要对对象的头（Object Header）进行初始化，这新信息包括：该对象对应类的元数据、该对象的GC代、对象的哈希码。<br>抽象数据类型默认初始化为null，基本数据类型为0，布尔为false….</li>
<li>调用对象的初始化方法<br>也就是执行构造方法。</li>
</ol>

    </div>

    
    
    
    
      <div>
        <div id="reward-container">
  <div>吃饱饭才能好好学习o(*￣▽￣*)ブ</div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
        
      
      <div style="display: inline-block">
        <img src="/images/wechatpay.jpg" alt="kepler 微信支付">
        <p>微信支付</p>
      </div>
        
      
      <div style="display: inline-block">
        <img src="/images/alipay.jpg" alt="kepler 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

      </div>

    <footer class="post-footer">
          
        
        <div class="post-tags">
            <a href="/tags/java知识点/" rel="tag"># java知识点</a>
          
        </div>
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
              <a href="/2019/08/01/Markdown入门教程/" rel="next" title="Markdown入门教程">
                <i class="fa fa-chevron-left"></i> Markdown入门教程
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
              <a href="/2019/08/12/Java网络/" rel="prev" title="Java网络篇">
                Java网络篇 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
    </footer>
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    <div class="comments" id="comments"></div>
  


        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/avatar.jpg"
      alt="kepler">
  <p class="site-author-name" itemprop="name">kepler</p>
  <div class="site-description motion-element" itemprop="description">GGS  DDU</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/kepler-ecnu" title="GitHub &rarr; https://github.com/kepler-ecnu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://weibo.com/3251667762" title="Weibo &rarr; https://weibo.com/3251667762" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://space.bilibili.com/12737596" title="Bilibili &rarr; https://space.bilibili.com/12737596" rel="noopener" target="_blank"><i class="fa fa-fw fa-paper-plane"></i>Bilibili</a>
      </span>
    
  </div>


  <div class="links-of-blogroll motion-element links-of-blogroll-inline">
    <div class="links-of-blogroll-title">
      <i class="fa  fa-fw fa-share"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://ailee1.github.io/" title="https://ailee1.github.io/" rel="noopener" target="_blank">Blog_Home</a>
        </li>
      
        <li class="links-of-blogroll-item">
          <a href="https://www.lixint.me/hexo-blog.html" title="https://www.lixint.me/hexo-blog.html" rel="noopener" target="_blank">博客搭建教程</a>
        </li>
      
        <li class="links-of-blogroll-item">
          <a href="https://xuzhixiong.gitlab.io/blog/" title="https://xuzhixiong.gitlab.io/blog/" rel="noopener" target="_blank">DaXiong</a>
        </li>
      
    </ul>
  </div>

        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java基础知识点"><span class="nav-number">1.</span> <span class="nav-text">Java基础知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简述什么是跨平台"><span class="nav-number">1.1.</span> <span class="nav-text">简述什么是跨平台</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java有几种基本数据类型"><span class="nav-number">1.2.</span> <span class="nav-text">Java有几种基本数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象特征"><span class="nav-number">1.3.</span> <span class="nav-text">面向对象特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象六大原则"><span class="nav-number">1.4.</span> <span class="nav-text">面向对象六大原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String属于基础的数据类型吗"><span class="nav-number">1.5.</span> <span class="nav-text">String属于基础的数据类型吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要有包装类型"><span class="nav-number">1.6.</span> <span class="nav-text">为什么要有包装类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自动装箱和自动拆箱"><span class="nav-number">1.7.</span> <span class="nav-text">自动装箱和自动拆箱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-str-“i”-与-String-str-new-String-“i”-一样么"><span class="nav-number">1.8.</span> <span class="nav-text">String str = “i” 与 String str = new String(“i”)一样么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何将字符串反转"><span class="nav-number">1.9.</span> <span class="nav-text">如何将字符串反转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-类常用方法"><span class="nav-number">1.10.</span> <span class="nav-text">String 类常用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#和-equals-区别"><span class="nav-number">1.11.</span> <span class="nav-text">== 和 equals 区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String、StringBuffer和StringBuilder区别"><span class="nav-number">1.12.</span> <span class="nav-text">String、StringBuffer和StringBuilder区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两个对象的-hashCode-相同，则equals-也一定为true，对吗？"><span class="nav-number">1.13.</span> <span class="nav-text">两个对象的 hashCode()相同，则equals()也一定为true，对吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两个对象值相同-x-equals-y-true-，Hashcode是否一定相同"><span class="nav-number">1.14.</span> <span class="nav-text">两个对象值相同(x.equals(y)==true)，Hashcode是否一定相同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么时候需要重写equals方法和hashCode方法"><span class="nav-number">1.15.</span> <span class="nav-text">什么时候需要重写equals方法和hashCode方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final在Java中有什么作用"><span class="nav-number">1.16.</span> <span class="nav-text">final在Java中有什么作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static和final区别"><span class="nav-number">1.17.</span> <span class="nav-text">static和final区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引用类型占用几个字节"><span class="nav-number">1.18.</span> <span class="nav-text">引用类型占用几个字节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-lt-3-quot-a-quot-quot-b-quot-3-4和-1-lt-3-quot-a-quot-quot-b-quot-3-4-区别"><span class="nav-number">1.19.</span> <span class="nav-text">(1&lt;3)?&quot;a&quot;:&quot;b&quot;)+3+4和(1&lt;3)?&quot;a&quot;:&quot;b&quot;)+(3+4)区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-amp-5-4-5-4-amp-10-gt-gt-1各等于多少"><span class="nav-number">1.20.</span> <span class="nav-text">4&amp;5 4^5 4&amp;10&gt;&gt;1各等于多少</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java中-Math-round-1-5-等于多少？Math-round-2-5-等于多少？"><span class="nav-number">1.21.</span> <span class="nav-text">Java中 Math.round(-1.5)等于多少？Math.round(-2.5)等于多少？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象类必须要有抽象方法吗？"><span class="nav-number">1.22.</span> <span class="nav-text">抽象类必须要有抽象方法吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#普通类和抽象类有哪些区别"><span class="nav-number">1.23.</span> <span class="nav-text">普通类和抽象类有哪些区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象类能使用final修饰吗"><span class="nav-number">1.24.</span> <span class="nav-text">抽象类能使用final修饰吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口和抽象类的区别"><span class="nav-number">1.25.</span> <span class="nav-text">接口和抽象类的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java中IO流分为几种"><span class="nav-number">1.26.</span> <span class="nav-text">Java中IO流分为几种</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BIO、NIO和AIO区别"><span class="nav-number">1.27.</span> <span class="nav-text">BIO、NIO和AIO区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Files常用方法有哪些"><span class="nav-number">1.28.</span> <span class="nav-text">Files常用方法有哪些</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器"><span class="nav-number">2.</span> <span class="nav-text">容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java容器都有哪些"><span class="nav-number">2.1.</span> <span class="nav-text">Java容器都有哪些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简述Java中的集合"><span class="nav-number">2.2.</span> <span class="nav-text">简述Java中的集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List、Set、Map之间的区别"><span class="nav-number">2.3.</span> <span class="nav-text">List、Set、Map之间的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap、HashTable和ConcurrentHashMap区别"><span class="nav-number">2.4.</span> <span class="nav-text">HashMap、HashTable和ConcurrentHashMap区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#如何保证线程安全又效率高"><span class="nav-number">2.4.1.</span> <span class="nav-text">如何保证线程安全又效率高</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#我们能否让HashMap同步"><span class="nav-number">2.4.2.</span> <span class="nav-text">我们能否让HashMap同步</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何决定使用HashMap还是TreeMap"><span class="nav-number">2.5.</span> <span class="nav-text">如何决定使用HashMap还是TreeMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#说一下-HashMap-的实现原理"><span class="nav-number">2.6.</span> <span class="nav-text">说一下 HashMap 的实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#说一下-HashSet-的实现原理"><span class="nav-number">2.7.</span> <span class="nav-text">说一下 HashSet 的实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList-和-LinkdList-区别"><span class="nav-number">2.8.</span> <span class="nav-text">ArrayList 和 LinkdList 区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何实现数组和-List-之间的转换"><span class="nav-number">2.9.</span> <span class="nav-text">如何实现数组和 List 之间的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList-和-Vector-的区别"><span class="nav-number">2.10.</span> <span class="nav-text">ArrayList 和 Vector 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Array-和-ArrayList-有何区别"><span class="nav-number">2.11.</span> <span class="nav-text">Array 和 ArrayList 有何区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在-Queue-中-poll-和-remove-有什么区别"><span class="nav-number">2.12.</span> <span class="nav-text">在 Queue 中 poll()和 remove()有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哪些集合类是线程安全的"><span class="nav-number">2.13.</span> <span class="nav-text">哪些集合类是线程安全的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代器-Iterator-是什么"><span class="nav-number">2.14.</span> <span class="nav-text">迭代器 Iterator 是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Iterator-怎么使用？有什么特点？"><span class="nav-number">2.15.</span> <span class="nav-text">Iterator 怎么使用？有什么特点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentModificationException异常出现的原因"><span class="nav-number">2.16.</span> <span class="nav-text">ConcurrentModificationException异常出现的原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#怎么确保一个集合不能被修改"><span class="nav-number">2.17.</span> <span class="nav-text">怎么确保一个集合不能被修改</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程"><span class="nav-number">3.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#并行和并发有什么区别"><span class="nav-number">3.1.</span> <span class="nav-text">并行和并发有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程和进程的区别"><span class="nav-number">3.2.</span> <span class="nav-text">线程和进程的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#守护线程是什么"><span class="nav-number">3.3.</span> <span class="nav-text">守护线程是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建线程的方式"><span class="nav-number">3.4.</span> <span class="nav-text">创建线程的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#说一下runnable和callable区别"><span class="nav-number">3.5.</span> <span class="nav-text">说一下runnable和callable区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程有哪些状态"><span class="nav-number">3.6.</span> <span class="nav-text">线程有哪些状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sleep-和-wait-有什么区别"><span class="nav-number">3.7.</span> <span class="nav-text">sleep() 和 wait() 有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#notify-和-notifyAll-有什么区别"><span class="nav-number">3.8.</span> <span class="nav-text">notify()和 notifyAll()有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程的-run-和-start-有什么区别"><span class="nav-number">3.9.</span> <span class="nav-text">线程的 run() 和 start() 有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建线程池有哪几种方式？"><span class="nav-number">3.10.</span> <span class="nav-text">创建线程池有哪几种方式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池都有哪些状态？"><span class="nav-number">3.11.</span> <span class="nav-text">线程池都有哪些状态？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池中-submit-和-execute-方法有什么区别？"><span class="nav-number">3.12.</span> <span class="nav-text">线程池中 submit() 和 execute() 方法有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在-Java-程序中怎么保证多线程的运行安全"><span class="nav-number">3.13.</span> <span class="nav-text">在 Java 程序中怎么保证多线程的运行安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多线程中-synchronized-锁升级的原理是什么"><span class="nav-number">3.14.</span> <span class="nav-text">多线程中 synchronized 锁升级的原理是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是死锁？"><span class="nav-number">3.15.</span> <span class="nav-text">什么是死锁？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#怎么防止死锁？"><span class="nav-number">3.16.</span> <span class="nav-text">怎么防止死锁？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal-是什么？有哪些使用场景？"><span class="nav-number">3.17.</span> <span class="nav-text">ThreadLocal 是什么？有哪些使用场景？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#说一下-synchronized-底层实现原理？"><span class="nav-number">3.18.</span> <span class="nav-text">说一下 synchronized 底层实现原理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-和-volatile-的区别是什么？"><span class="nav-number">3.19.</span> <span class="nav-text">synchronized 和 volatile 的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-和-Lock-有什么区别？"><span class="nav-number">3.20.</span> <span class="nav-text">synchronized 和 Lock 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-和-ReentrantLock-区别是什么？"><span class="nav-number">3.21.</span> <span class="nav-text">synchronized 和 ReentrantLock 区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#说一下-atomic-的原理？"><span class="nav-number">3.22.</span> <span class="nav-text">说一下 atomic 的原理？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#反射"><span class="nav-number">4.</span> <span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是反射"><span class="nav-number">4.1.</span> <span class="nav-text">什么是反射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是-Java-序列化？什么情况下需要序列化？"><span class="nav-number">4.2.</span> <span class="nav-text">什么是 Java 序列化？什么情况下需要序列化？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#某些java类为什么要实现Serializable接口"><span class="nav-number">4.3.</span> <span class="nav-text">某些java类为什么要实现Serializable接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态代理是什么？有哪些应用？"><span class="nav-number">4.4.</span> <span class="nav-text">动态代理是什么？有哪些应用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#怎么实现动态代理？"><span class="nav-number">4.5.</span> <span class="nav-text">怎么实现动态代理？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象拷贝"><span class="nav-number">5.</span> <span class="nav-text">对象拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要使用克隆"><span class="nav-number">5.1.</span> <span class="nav-text">为什么要使用克隆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何实现对象克隆"><span class="nav-number">5.2.</span> <span class="nav-text">如何实现对象克隆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深拷贝和浅拷贝区别是什么"><span class="nav-number">5.3.</span> <span class="nav-text">深拷贝和浅拷贝区别是什么</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异常"><span class="nav-number">6.</span> <span class="nav-text">异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#throw-和-throws-的区别"><span class="nav-number">6.1.</span> <span class="nav-text">throw 和 throws 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final、finally、finalize-有什么区别？"><span class="nav-number">6.2.</span> <span class="nav-text">final、finally、finalize 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#try-catch-finally-中哪个部分可以省略"><span class="nav-number">6.3.</span> <span class="nav-text">try-catch-finally 中哪个部分可以省略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？"><span class="nav-number">6.4.</span> <span class="nav-text">try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见的异常类有哪些？"><span class="nav-number">6.5.</span> <span class="nav-text">常见的异常类有哪些？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设计模式"><span class="nav-number">7.</span> <span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#说一下你熟悉的设计模式"><span class="nav-number">7.1.</span> <span class="nav-text">说一下你熟悉的设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简单工厂、工程方法和抽象工厂有什么区别？"><span class="nav-number">7.2.</span> <span class="nav-text">简单工厂、工程方法和抽象工厂有什么区别？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM"><span class="nav-number">8.</span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#说一下-JVM-的主要组成部分？及其作用？"><span class="nav-number">8.1.</span> <span class="nav-text">说一下 JVM 的主要组成部分？及其作用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#说一下-JVM-运行时数据区？"><span class="nav-number">8.2.</span> <span class="nav-text">说一下 JVM 运行时数据区？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#说一下堆栈的区别？"><span class="nav-number">8.3.</span> <span class="nav-text">说一下堆栈的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#队列和栈是什么？有什么区别？"><span class="nav-number">8.4.</span> <span class="nav-text">队列和栈是什么？有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#说一下类装载的执行过程？"><span class="nav-number">8.5.</span> <span class="nav-text">说一下类装载的执行过程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#怎么判断对象是否可以被回收？"><span class="nav-number">8.6.</span> <span class="nav-text">怎么判断对象是否可以被回收？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-中都有哪些引用类型？"><span class="nav-number">8.7.</span> <span class="nav-text">Java 中都有哪些引用类型？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM垃圾处理方法"><span class="nav-number">8.8.</span> <span class="nav-text">JVM垃圾处理方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#说一下-JVM-有哪些垃圾回收器？"><span class="nav-number">8.9.</span> <span class="nav-text">说一下 JVM 有哪些垃圾回收器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#详细介绍一下-CMS-垃圾回收器？"><span class="nav-number">8.10.</span> <span class="nav-text">详细介绍一下 CMS 垃圾回收器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"><span class="nav-number">8.11.</span> <span class="nav-text">新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#新生代、老年代、持久代都存储哪些东西"><span class="nav-number">8.12.</span> <span class="nav-text">新生代、老年代、持久代都存储哪些东西</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可达性算法中，哪些对象可作为GC-Roots对象"><span class="nav-number">8.13.</span> <span class="nav-text">可达性算法中，哪些对象可作为GC Roots对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么时候进行MinGC和FullGC"><span class="nav-number">8.14.</span> <span class="nav-text">什么时候进行MinGC和FullGC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何判定对象为垃圾对象"><span class="nav-number">8.15.</span> <span class="nav-text">如何判定对象为垃圾对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#你能说出来几个垃圾收集器"><span class="nav-number">8.16.</span> <span class="nav-text">你能说出来几个垃圾收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM中对象的创建过程"><span class="nav-number">8.17.</span> <span class="nav-text">JVM中对象的创建过程</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-rocket"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">kepler</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">103k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:34</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.3.0</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>

    

  </div>

  
    
    
  
    
    
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  <script defer src="/lib/three/three.min.js"></script>
  <script defer src="/lib/three/three-waves.min.js"></script>

  <script src="/js/utils.js?v=7.3.0"></script>
  <script src="/js/motion.js?v=7.3.0"></script>

  
  <script src="/js/affix.js?v=7.3.0"></script>
  <script src="/js/schemes/pisces.js?v=7.3.0"></script>



  
  <script src="/js/scrollspy.js?v=7.3.0"></script>
<script src="/js/post-details.js?v=7.3.0"></script>



  <script src="/js/next-boot.js?v=7.3.0"></script>

  

  

  


  























  <script src="/js/local-search.js?v=7.3.0"></script>













    
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'HxHbd9cEJ5n3LYXQ9qrn8Ka9-gzGzoHsz',
    appKey: 'q0LRP1j5X1pLwLHDAhWNPXBg',
    placeholder: '欢迎留言指正',
    avatar: 'robohash',
    meta: guest,
    pageSize: '10' || 10,
    visitor: true,
    lang: '' || 'zh-cn'
  });
</script>




  <script type="text/javascript" src="/js/src/love.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
